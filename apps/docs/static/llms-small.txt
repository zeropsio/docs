----------------------------------------

# Alpine > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Alpine application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: alpine@3.20
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - apk add --no-cache something
        - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - 
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles: app
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      cache: some_file
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: alpine@3.20
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 8080
      # OPTIONAL. Customize the runtime Alpine environment by installing additional
      # dependencies to the base Alpine runtime environment.
      prepareCommands:
        - apk add --no-cache something
        - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Alpine application is started.
      initCommands:
       - rm -rf ./cache
      # OPTIONAL. Your Alpine application start command
      start: ./app
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Alpine builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: alpine@3.20
      ...
```
  The base build environment contains {data.alpine.default}, Zerops command line tool, `git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - alpine@3.20
      prepareCommands:
        - zsc add nodejs@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customize your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### prepareCommands
_OPTIONAL._ Customizes the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- [Zerops command line tool](/references/cli)
- `git` and `wget`
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: alpine@3.20
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - apk add --no-cache something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/alpine/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: alpine@3.20
      # OPTIONAL. Build your application
      buildCommands:
        - 
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
For detailed information about build commands, refer to the documentation for your specific technology (e.g., [Node.js](/nodejs/how-to/build-pipeline), [Go](/go/how-to/build-pipeline), [Python](/python/how-to/build-pipeline), etc.).
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
buildCommands:
  - |
    cd src
    ./build.sh
```
#### Run build commands as separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
buildCommands:
  - cd src
  - ./build.sh
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/alpine/how-to/logs#build-log) to troubleshoot the error.
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - app
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - app
  - file.txt
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: alpine@3.20
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        MODE: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/alpine/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Alpine version for your runtime.
Following options are available for Alpine builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: alpine@3.20
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: alpine@3.20
      ...
```
  The base runtime environment contains {data.alpine.default}, Zerops command line tool, `git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: alpine@3.20
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - alpine@3.20
      prepareCommands:
        - zsc add nodejs@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customise your build environment use the `prepareCommands` attribute.
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to an Alpine service with hostname = "app" and port = 8080 from another service of the same project, simply use `app:8080`. Read more about [how to access an Alpine service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customises the Alpine runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Alpine environment contains {data.alpine.default}, Zerops command line tool and `git` and `wget`. To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Alpine runtime environment.
      prepareCommands:
        - apk add --no-cache something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/alpine/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
When the prepare cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, Zerops command line tool and `git` and `wget`.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Alpine runtime environment.
      prepareCommands:
        - apk add --no-cache something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Alpine application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Alpine application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/alpine/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/alpine/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        MODE: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/alpine/how-to/env-variables) in Zerops.
### start
_OPTIONAL._ Defines the start command for your Alpine application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Your Alpine application start command
      start: ./app
```
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Your Alpine application start command
      start: ./app
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Alpine application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Alpine application start command
      start: ./app
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/alpine/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/alpine/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Alpine application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/alpine/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Alpine > How To > Build Process

  
## Build process overview
Zerops starts a temporary build container and performs the following actions:
1. **Installs the build environment** - Sets up base system and  runtime
2. **Downloads your application source code** - From [GitHub ↗](https://www.github.com), [GitLab ↗](https://www.gitlab.com) or via [Zerops CLI](/references/cli)
3. **Optionally customizes the build environment** - Runs prepare commands if configured
4. **Runs the build commands** - Executes your build process
5. **Uploads the application artifact** - Stores build output to internal Zerops storage
6. **Caches selected files** - Preserves specified files for faster future builds
The build container is automatically deleted after the build has finished or failed.
## Build configuration
Configure your  build process in your `zerops.yaml` file according to the full build & deploy  pipeline guide.
## Build environment
### Default  build environment
The default  build environment contains:
- {data.alpine.default}
- [zCLI](/references/cli), Zerops command line tool
- 
### Customize build environment
To install additional packages or tools, add one or more build.prepareCommands to your `zerops.yaml`.
:::info
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::
### Build hardware resources
All runtime services use the same hardware resources for build containers:
  
      HW resource
      Minimum
      Maximum
    
      CPU cores
      1
      5
    
      RAM
      8 GB
      8 GB
    
      Disk
      1 GB
      100 GB
    
Build containers start with minimum resources and scale vertically up to maximum capacity as needed.
### Build time limit
The time limit for the whole build pipeline is **1 hour**. After 1 hour, Zerops will terminate the build pipeline and delete the build container.
:::info
Build container resources are not charged separately. Limited build time is included in your [project core plan](/company/pricing#project-core-plans), with additional build time available if needed.
:::
## Troubleshooting  builds
:::tip Advanced troubleshooting
For complex build issues that require investigation, you can enable [debug mode](/features/debug-mode) to pause the build process at specific points and inspect the build container state interactively.
:::
### Build and prepare command failures
If any build command or prepare command fails (returns non-zero exit code), the build is canceled. Check the build log to troubleshoot the error.
### Build cache issues
If you encounter unexpected build behavior or dependency issues, the problem might be related to cached build data. While Zerops maintains the build cache to speed up deployments, sometimes you may need to start fresh.
To invalidate the build cache:
1. Go to your service detail in Zerops GUI
2. Choose **Pipelines & CI/CD Settings** from the left menu
3. Click on the **Invalidate build cache** button
This will force Zerops to run the next build clean, including all prepare commands.
Learn more about [build cache behavior](/features/build-cache).
## More resources
For more details about the build and deploy pipeline, including how to cancel builds and manage application versions, see the [general pipeline documentation](/features/pipeline).
## Next steps
- Understand the deployment process
- Learn how to customize the runtime environment
- Explore build and runtime logs

----------------------------------------

# Alpine > How To > Controls



----------------------------------------

# Alpine > How To > Create

Zerops provides a Alpine runtime service with extensive build support. Alpine runtime is highly scalable and customisable to suit both development and production.
## Create Alpine service using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new Alpine service:
### Choose Alpine version
Following Alpine versions are currently supported:
:::info
You can [change](/alpine/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app","cache", "gui" etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
- maximum 25 characters
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created. It can't be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as password, tokens, salts, certificates etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting the secret environment variables is optional. You can set them later in Zerops GUI.
Read more about [different types of env variables](/alpine/how-to/env-variables#service-env-variables) in Zerops.
## Create Alpine service using zCLI
zCLI is the Zerops command-line tool. To create a new Alpine service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/alpine/how-to/create#create-a-project-description-file)
3. [Create a project with a Alpine and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a yaml format to describe the project infrastructure.
#### Basic example:
Create a directory `my-project`. Create an `description.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in alpine@{version} format
    type: alpine@3.20
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Alpine service with default [auto scaling](/alpine/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/alpine/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Alpine and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in alpine@{version} format
    type: alpine@3.20
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create secret env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain an Alpine service and a [PostgreSQL](/postgresql/overview) service.
Alpine service with "app" hostname, the internal port(s) the service listens on will be defined later in the zerops.yaml. Alpine service will run with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
         
        The hostname of the new database will be set to the `hostname` value.
         
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the service type and version.
        
        See what [Alpine service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
      verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
      - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
      - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
      - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
      - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
      minContainers
      
        Optional. Default = 1. Defines the minimum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      envSecrets
      
        Optional. Defines one or more secret env variables as a key value map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Alpine service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in alpine@{version} format
    type: alpine@3.20
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Alpine service version 1 with default [auto scaling](/alpine/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Alpine > How To > Customize Runtime

System packages: Install any packages you need via apk, such as imagemagick, ffmpeg, or chromium',
  'Specific language versions: Install versions of Go, Node.js, PHP, Python, or other runtimes that are not available as dedicated Zerops services (e.g., older or cutting-edge versions)',
  'Custom binaries: Add compiled binaries or tools not available in the default repositories',
  'Development tools: Include debugging tools, profilers, or other utilities',
  'Specific libraries: Install dependencies required by your application'
]} />
## Build Custom Runtime Images
Zerops allows you to build custom runtime images (CRI) when the default base runtime images don't meet your application's requirements. This is an optional phase in the [build and deploy pipeline](/features/pipeline#runtime-prepare-phase-optional).
Alpine is a versatile base for running anything not explicitly offered as a dedicated Zerops runtime. You can install any packages and tools you need, treating it as a clean OS to customize however you want.
It is also a great option when you need a specific version of a technology (like Go, Node.js, or PHP) that Zerops doesn't support by default—whether it's an older version for legacy projects or a newer release not yet available.
## Configuration
### Default  Runtime Environment
The default  runtime environment contains:
- {data.alpine.default}
- [zCLI](/references/cli)
- 
### When You Need a Custom Runtime Image
Since Alpine serves as a general-purpose base, you'll likely want to customize it for your specific use case. Common scenarios include:
:::important
You should not include your application code in the custom runtime image, as your built/packaged code is deployed automatically into fresh containers.
:::
Here are examples of configuring custom runtime images in your `zerops.yml`:
### Basic  Setup
### Using Build Files in Runtime Preparation
For complete configuration details, see the [runtime prepare phase configuration guide](/features/pipeline#configuration).
## Process and Caching
### How Runtime Prepare Works
The runtime prepare process follows the same steps for all runtimes. See [how runtime prepare works](/features/pipeline#how-it-works) for the complete process details.
### Caching Behavior
Zerops caches custom runtime images to optimize deployment times. Learn about [custom runtime image caching](/features/pipeline#custom-runtime-image-caching) including when images are cached and reused.
### Build Management
For information about managing builds and deployments, see [managing builds and deployments](/features/pipeline#manage-builds-and-deployments).
:::warning
Shared storage mounts are not available during the runtime prepare phase.
:::
## Troubleshooting
If your `prepareCommands` fail, check the prepare runtime log for specific error messages.

----------------------------------------

# Alpine > How To > Delete



----------------------------------------

# Alpine > How To > Deploy Process



----------------------------------------

# Alpine > How To > Env Variables



----------------------------------------

# Alpine > How To > Filebrowser



----------------------------------------

# Alpine > How To > Logs



----------------------------------------

# Alpine > How To > Scaling



----------------------------------------

# Alpine > How To > Shared Storage



----------------------------------------

# Alpine > How To > Trigger Pipeline



----------------------------------------

# Alpine > How To > Upgrade



----------------------------------------

# Alpine > Overview

[Alpine Linux ↗](https://alpinelinux.org/) is a lightweight, security-oriented Linux distribution based on musl libc and busybox, known for its small footprint and efficiency.
Alpine services in Zerops provide a minimal base environment for running applications built with technologies that aren't officially supported by Zerops, or for custom setups requiring full control over the runtime environment while keeping resource usage low.
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you built something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Bun > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Bun application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: bun@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customise the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - bun i
        - bun run build
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - dist
        - package.json
        - node_modules
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      cache: node_modules
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: bun@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 3000
      # OPTIONAL. Customise the runtime Bun environment by installing additional
      # dependencies to the base Bun runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Bun application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your Bun application start command
      start: bun start
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Bun builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: bun@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  major version of Bun,
  Zerops command line tool, `npm`,
  `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - bun@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customise your build environment use the [prepareCommands](build-pipeline#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customises the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of Bun defined in the [base](build-pipeline#base) attribute
- [Zerops command line tool](/references/cli)
- `npm`, `yarn`, `git` and `npx` tools
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: bun@latest
      # OPTIONAL. Customise the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: bun@latest
      # OPTIONAL. Build your application
      buildCommands:
        - bun i
        - bun run build
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](build-pipeline#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](build-pipeline#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
buildCommands:
  - |
    bun i
    bun run build
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
buildCommands:
  - bun i
  - bun run build
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the --verbose option.
```yaml
buildCommands:
  - bun i --verbose
  - bun run build
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - dist
  - package.json
  - node_modules
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - dist
  - package.json
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: bun@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Bun version for your runtime.
Following options are available for Bun runtimes:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: bun@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: bun@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of Bun, Zerops command line tool, `npm`, `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: bun@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - bun@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customise your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Bun service with hostname = "app" and port = 3000 from another service of the same project, simply use `app:3000`. Read more about [how to access a Bun service](/features/access).
Each port has following attributes:
| parameter   | description                                                                                                                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| port        | Defines the port number. You can set any port number between _10_ and _65435_. Ports outside this interval are reserved for internal Zerops systems.                                                                                                                                                                   |
| protocol    | **Optional.** Defines the protocol. Allowed values are `TCP` or `UDP`. Default value is `TCP`.                                                                                                                                                                                                                         |
| httpSupport | **Optional.** `httpSupport = true` is the default setting for TCP protocol. Set `httpSupport = false` if a web server isn't running on the port. Zerops uses this information for the configuration of [public access](/features/access). `httpSupport = true` is available only in combination with the TCP protocol. |
| httpSupport | **Optional.** `httpSupport = true` is the default setting for TCP protocol. Set `httpSupport = false` if a web server isn't running on the port. Zerops uses this information for the configuration of [public access](/features/access). `httpSupport = true` is available only in combination with the TCP protocol. |
### prepareCommands
_OPTIONAL._ Customises the Bun runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Bun environment contains {data.alpine.default} the selected
  major version of Bun, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools. To install
  additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Bun runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](build-pipeline#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the custom runtime cache go to `yyy`
When the custom runtime cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the selected major version of Bun, Zerops command line tool and `npm`,
  `yarn`, `git` and `npx` tools.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Bun runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Bun application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Bun application is started via the [start command](build-pipeline#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the [horizontal scaling](scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](build-pipeline#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your Bun application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Bun application start command
      start: bun start
```
We recommend starting your Bun application using `bun start`.
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Bun application start command
      start: bun start
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
| Parameter   | Description                                                                                                                                                                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **command** | Defines a local command to be run.
The command has access to the same [environment variables](create#set-secret-environment-variables) as your Bun application.
A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below. |
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Bun application start command
      start: bun start
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
<table className="w-full my-1.5">
  <thead>
    <tr>
      <th className="w-fit whitespace-nowrap">Parameter</th>
      <th className="w-fit whitespace-nowrap">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">port</td>
      <td>Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on <code>{'http://127.0.0.1:{port}/{path}'}</code></td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">path</td>
      <td>Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on <code>{'http://127.0.0.1:{port}/{path}'}</code></td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">host</td>
      <td><strong>Optional.</strong> The readiness check is triggered from inside of your runtime container so it always uses the localhost <code>127.0.0.1</code>. If you need to add a <code>host</code> to the request header, specify it in the <code>host</code> attribute.</td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">scheme</td>
      <td><strong>Optional.</strong> The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set <code>scheme: https</code></td>
    </tr>
  </tbody>
</table>
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
| Parameter   | Description                                                                                                                                                                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **command** | Defines a local command to be run.
The command has access to the same [environment variables](create#set-secret-environment-variables) as your Bun application.
A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below. |
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Bun > How To > Build Process



----------------------------------------

# Bun > How To > Controls



----------------------------------------

# Bun > How To > Create

Zerops provides a powerful Bun runtime service with extensive build support. The Bun runtime is highly scalable and customizable to suit your development and production needs. With just a few clicks or commands, you can have a production-ready Bun environment up and running in no time.
## Create a Bun service using Zerops GUI
First, set up a project in the Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu under the **Services** section. From there, you can add a new Bun service:
### Choose a Bun version
Zerops supports the following Bun versions:
:::info
You can easily [upgrade](upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app", "cache", "gui", etc. Duplicate services with the same name within the same project are not allowed.
#### Limitations:
- Maximum 25 characters
- Must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created and cannot be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as passwords, tokens, salts, certificates, etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting secret environment variables is optional. You can always set them later in the Zerops GUI.
Read more about the [different types of environment variables](env-variables#service-env-variables) in Zerops.
## Create a Bun service using zCLI
zCLI is the Zerops command-line tool. To create a new Bun service via the command line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](create#create-a-project-description-file)
3. [Create a project with a Bun and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a YAML format to describe the project infrastructure.
#### Basic example:
Create a directory called `my-project`. Inside the `my-project` directory, create a `description.yaml` file with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in Bun@{version} format
    type: bun@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Bun service with default [auto scaling](scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Bun and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in Bun@{version} format
    type: bun@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Bun service and a [PostgreSQL](/postgresql/overview) service.
Bun service with "app" hostname, the internal port(s) the service listens on will be defined later in the [zerops.yaml](build-pipeline#ports). Bun service will run with custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
| Parameter       | Description                                                                                                                     | Limitations             |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------- | ----------------------- |
| **name**        | The name of the new project. Duplicates are allowed.                                                                            |                         |
| **description** | **Optional.** Description of the new project.                                                                                   | Maximum 255 characters. |
| **tags**        | **Optional.** One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects. |
| **tags**        | **Optional.** One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects. |
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains Bun and PostgreSQL services but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
        hostname
      
        The unique service identifier.
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
        type
      
        Specifies the service type and version.
        
        See what [Bun service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
        verticalAutoscaling
      
        Optional. Defines  custom vertical auto scaling parameters.
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
         - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
         - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
         - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
         - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
        minContainers
      
        Optional. Default = 1. Defines the minimum number of containers
        for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        maxContainers
      
        Defines the maximum number of containers for  horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        envSecrets
      
        Optional. Defines one or more secret env variables as a key value
        map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Bun service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in Bun@{version} format
    type: bun@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Bun service with default [auto scaling](scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Bun > How To > Customize Runtime

System packages for processing: When your app processes images, videos, or files (requiring packages like sudo apk add imagemagick)',
  'Global Bun tools: When you need CLI tools or utilities available system-wide',
  'Native dependencies: When your Bun packages require system libraries that aren\'t in the default environment',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />

----------------------------------------

# Bun > How To > Delete



----------------------------------------

# Bun > How To > Deploy Process



----------------------------------------

# Bun > How To > Env Variables



----------------------------------------

# Bun > How To > Filebrowser



----------------------------------------

# Bun > How To > Logs



----------------------------------------

# Bun > How To > Scaling



----------------------------------------

# Bun > How To > Shared Storage



----------------------------------------

# Bun > How To > Trigger Pipeline



----------------------------------------

# Bun > How To > Upgrade



----------------------------------------

# Bun > Overview

[Bun ↗](https:/bun.org/en) is an asynchronous event-driven JavaScript runtime, which is designed to build scalable network applications.
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-bun), a **_recipe_**, containing the most simple Bun web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of Bun app running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-bun/blob/main/zerops-project-import.yaml)):
```yaml
project:
  name: recipe-bun
  tags:
    - zerops-recipe
services:
  - hostname: api
    type: bun@1.1
    enableSubdomainAccess: true
    buildFromGit: https://github.com/zeropsio/recipe-bun
  - hostname: db
    type: postgresql@16
    mode: NON_HA
    priority: 1
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://api-806-3000.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
{"message":"This is a simple, basic Bun application running in Zerops.io,\n          each request adds an entry to the PostgreSQL database and returns a count.\n          See the source repository (https://github.com/zeropsio/recipe-bun) for more information.","newEntry":"dfd1e873-bfc8-4f36-af07-e32561820b93","count":"1"}
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
It doesn't matter whether it's your first curious introduction to Zerops, you have already mastered the basics and are looking for a tiny detail or inspiration. Below, choose a section that fits your needs:
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Clickhouse > Overview

Zerops provides a fully managed [ClickHouse](https://clickhouse.com/) columnar database optimized for blazing-fast analytical queries on massive datasets, making it ideal for data warehousing and real-time analytics applications.
## Supported Versions
Currently supported ClickHouse version:
Import configuration version:
## Service Configuration
Our ClickHouse implementation features optimized default settings designed for analytical workloads and data warehousing use cases.
### Resource Allocation
Zerops automatically allocates resources to your ClickHouse service based on demand within the limits defined in your [automatic scaling configuration](/features/scaling-ha).
## High Availability and Deployment Modes
:::important
Deployment mode is selected during service creation and cannot be changed later.
:::
### High-Availability (HA) Setup
The recommended solution for production workloads and mission-critical analytics:
* **3 data nodes** with automatic monitoring, repairs, and replication factor of 3
* **Default cluster name:** `zerops` (currently 1 shard with 3 replicas)
#### Replication Configuration
The `Replicated` database engine handles replication automatically, but there are specific requirements you need to follow:
**For Database Operations**
Use this configuration when creating/managing databases:
```sql
CREATE DATABASE uk ON CLUSTER '{cluster}'
ENGINE = Replicated('/clickhouse/databases/{uuid}', '{shard}', '{replica}');
```
**For Table Operations**
Use `ENGINE = ReplicatedMergeTree` when creating tables (without the `ON CLUSTER '{cluster}'` clause):
```sql
CREATE TABLE uk.uk_price_paid
(
    price     UInt32,
    date      Date,
    postcode1 LowCardinality(String),
    postcode2 LowCardinality(String),
    type      Enum8('terraced' = 1, 'semi-detached' = 2, 'detached' = 3, 'flat' = 4, 'other' = 0),
    is_new    UInt8,
    duration  Enum8('freehold' = 1, 'leasehold' = 2, 'unknown' = 0),
    addr1     String,
    addr2     String,
    street    LowCardinality(String),
    locality  LowCardinality(String),
    town      LowCardinality(String),
    district  LowCardinality(String),
    county    LowCardinality(String)
) ENGINE = ReplicatedMergeTree ORDER BY (postcode1, postcode2, addr1, addr2);
```
For more details see:
- https://clickhouse.com/docs/engines/database-engines/replicated
- https://clickhouse.com/docs/engines/table-engines/mergetree-family/replication
- https://clickhouse.com/docs/sql-reference/distributed-ddl
You can use other `Replicated*` engines from the MergeTree family. Replication is only supported for tables in the MergeTree family:
* `ReplicatedMergeTree`
* `ReplicatedSummingMergeTree`
* `ReplicatedReplacingMergeTree`
* `ReplicatedAggregatingMergeTree`
* `ReplicatedCollapsingMergeTree`
* `ReplicatedVersionedCollapsingMergeTree`
* `ReplicatedGraphiteMergeTree`
User management (users, grants, etc.) is replicated by Keeper by default. The `ON CLUSTER '{cluster}'` clause is not needed when creating/deleting users or changing grants.
The default `` database follows these practices. If you don't follow these recommendations, it is possible you will face issues in case of fail and repair scenario.
### Single Container Installation
Suitable for development and testing environments:
* Consists of 1 ClickHouse node
* Lower resource requirements
* No automatic replication
:::warning
Use for development purposes or non-critical data only. **Make sure to have backups enabled** if using in production, as you can lose your data due to container volatility.
:::
## Network Access & Protocols
Zerops automatically configures secure authentication for your ClickHouse service.
### Default Database
Zerops creates a default database with the same name as your service hostname (``) during service creation.
### Default Users
#### `zerops` User
* Created automatically upon service creation
* Has privileges for the default database
* Password available as environment variable `password`
#### `super` User
* Administrative user for cluster management
* Can create new databases, users, and manage permissions
* Password available as environment variable `superUserPassword`
### Access Methods
Services within the same project can access ClickHouse directly using:
```
:
```
For HA cluster setups, you can also access specific data nodes:
```
node-stable-.db..zerops:
```
For external access, use `zcli` VPN to connect using the same connection strings.
ClickHouse offers multiple interfaces for different use cases:
#### Native TCP Protocol
**Port:** `9000` (Environment variable: `port` or `portNative`)
Optimal for high-performance applications and ClickHouse-native clients.
More about it in [official ClickHouse docs](https://clickhouse.com/docs/interfaces/tcp).
#### HTTP/HTTPS Interface
**Port:** `8123` (Environment variable: `portHttp`)
Ideal for web applications and REST API integrations.
It is also possible to setup HTTPS domain access or enable subdomain for access from outside the project. Then you can access the database using following URL:
- `https://clickhouse.my-awesome-domain.tld`
- JDBC connection string example (use `ssl=true&sslmode=NONE` options):
`jdbc:clickhouse:https://clickhouse.my-awesome-domain.tld:443/?ssl=true&sslmode=NONE`
More about it in [official ClickHouse docs](https://clickhouse.com/docs/interfaces/http).
#### MySQL Protocol
**Port:** `9004` (Environment variable: `portMysql`)
Enables connectivity from MySQL-compatible tools and applications.
More about it in [official ClickHouse docs](https://clickhouse.com/docs/interfaces/mysql).
#### PostgreSQL Protocol
**Port:** `9005` (Environment variable: `portPostgresql`)
Allows integration with PostgreSQL-compatible clients and ORMs.
More about it in [official ClickHouse docs](https://clickhouse.com/docs/interfaces/postgresql).
## Backup and Recovery
Zerops provides comprehensive backup functionality using ClickHouse's native backup capabilities.
### Backup Process
* Backups are performed using ClickHouse SQL command `BACKUP ALL ...` with `super` user permissions
* All databases are backed up (excluding system databases)
* Backup files are stored as `tar.gz` archives
* Contains the complete folder structure produced by the SQL backup command
### Restore Options
#### Option 1: Custom S3 Bucket Restore
1. Download backup from Zerops GUI or via API
2. Extract the tar.gz archive and upload to your S3 bucket
3. Restore using ClickHouse SQL commands:
```sql
-- Restore specific table
RESTORE TABLE mydb.mytable AS mydb.mytable2
FROM S3('https://storage-prg1.zerops.io/mybucket/path/to/dir/with/untarred/backup',
        'my-access-key-id', 'my-secret-key');
-- Restore all data
RESTORE ALL FROM S3('https://storage-prg1.zerops.io/mybucket/path/to/backup',
                   'my-access-key-id', 'my-secret-key');
-- see https://clickhouse.com/docs/operations/backup#configuring-backuprestore-to-use-an-s3-endpoint
```
#### Option 2: Support-Assisted Restore
Contact Zerops support on Discord, and we'll place the backup on the container's filesystem for restoration using the `File` driver (see [ClickHouse documentation](https://clickhouse.com/docs/operations/backup) for further info).
:::note
A simple GUI/API action for backup restoration is on our roadmap for future releases.
:::
## Troubleshooting
### Common Issues
#### Connection Problems
* Verify you're using the correct port for your chosen protocol
* Check that your service is running and healthy in the Zerops dashboard
* For HA clusters, try connecting to specific nodes if the main endpoint fails
* Ensure authentication credentials are correct
#### Replication Issues
* Verify you're using `ON CLUSTER '{cluster}'` for database operations
* Confirm tables use `ReplicatedMergeTree` engines
## Learn More
- [Official ClickHouse Documentation](https://clickhouse.com/docs) - Comprehensive guide to ClickHouse features and SQL syntax
- [ClickHouse Replication Guide](https://clickhouse.com/docs/engines/table-engines/mergetree-family/replication) - Detailed replication concepts
- [Distributed DDL Reference](https://clickhouse.com/docs/sql-reference/distributed-ddl) - Cluster operations documentation
## Support
For advanced configurations or custom requirements:
- Join our [Discord community](https://discord.gg/zerops)
- Contact support via [email](mailto:support@zerops.io)

----------------------------------------

# Deno > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Deno application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: deno@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customise the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - deno task build
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - dist
        - deno.jsonc
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      # cache: directory
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: deno@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 3000
      # OPTIONAL. Customise the runtime Deno environment by installing additional
      # dependencies to the base Deno runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Deno application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your Deno application start command
      start: deno task start
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Deno builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: deno@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  major version of Deno, Zerops command line tool, `npm`, `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - deno@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customise your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customises the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of Deno defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `npm`, `yarn`, `git` and `npx` tools
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: deno@latest
      # OPTIONAL. Customise the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/deno/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: deno@latest
      # OPTIONAL. Build your application
      buildCommands:
        - deno task build
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
buildCommands:
  - |
    deno test
    deno task build
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
buildCommands:
  - deno task build
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/deno/how-to/logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the --verbose option.
```yaml
buildCommands:
  - npm i --verbose
  - npm run build
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - dist
  - package.json
  - node_modules
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - dist
  - package.json
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: deno@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/deno/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Deno version for your runtime.
Following options are available for Deno builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: deno@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: deno@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of Deno, Zerops command line tool, `npm`, `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: deno@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - deno@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customise your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Deno service with hostname = "app" and port = 3000 from another service of the same project, simply use `app:3000`. Read more about [how to access a Deno service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
| parameter   | description                                                                                                                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| port        | Defines the port number. You can set any port number between _10_ and _65435_. Ports outside this interval are reserved for internal Zerops systems.                                                                                                                                                                   |
| protocol    | **Optional.** Defines the protocol. Allowed values are `TCP` or `UDP`. Default value is `TCP`.                                                                                                                                                                                                                         |
| httpSupport | **Optional.** `httpSupport = true` is the default setting for TCP protocol. Set `httpSupport = false` if a web server isn't running on the port. Zerops uses this information for the configuration of [public access](/features/access). `httpSupport = true` is available only in combination with the TCP protocol. |
| httpSupport | **Optional.** `httpSupport = true` is the default setting for TCP protocol. Set `httpSupport = false` if a web server isn't running on the port. Zerops uses this information for the configuration of [public access](/features/access). `httpSupport = true` is available only in combination with the TCP protocol. |
### prepareCommands
_OPTIONAL._ Customises the Deno runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Deno environment contains {data.alpine.default} the selected
  major version of Deno, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools. To install
  additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Deno runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/deno/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the custom runtime cache go to `yyy`
When the custom runtime cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the
  selected major version of Deno, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Deno runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Deno application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Deno application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/deno/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/deno/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/deno/how-to/env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your Deno application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Deno application start command
      start: deno task start
```
We recommend starting your Deno application using `deno task start`.
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Deno application start command
      start: deno task start
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
| Parameter   | Description                                                                                                                                                                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **command** | Defines a local command to be run.
The command has access to the same [environment variables](/deno/how-to/create#set-secret-environment-variables) as your Deno application.
A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below. |
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Deno application start command
      start: deno task start
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/deno/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
<table className="w-full my-1.5">
  <thead>
    <tr>
      <th className="w-fit whitespace-nowrap">Parameter</th>
      <th className="w-fit whitespace-nowrap">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">port</td>
      <td>Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on <code>{'http://127.0.0.1:{port}/{path}'}</code></td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">path</td>
      <td>Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on <code>{'http://127.0.0.1:{port}/{path}'}</code></td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">host</td>
      <td><strong>Optional.</strong> The readiness check is triggered from inside of your runtime container so it always uses the localhost <code>127.0.0.1</code>. If you need to add a <code>host</code> to the request header, specify it in the <code>host</code> attribute.</td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">scheme</td>
      <td><strong>Optional.</strong> The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set <code>scheme: https</code></td>
    </tr>
  </tbody>
</table>
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/deno/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
| Parameter   | Description                                                                                                                                                                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **command** | Defines a local command to be run.
The command has access to the same [environment variables](/deno/how-to/create#set-secret-environment-variables) as your Deno application.
A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below. |
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/deno/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Deno > How To > Build Process

  
## Build process overview
Zerops starts a temporary build container and performs the following actions:
1. **Installs the build environment** - Sets up base system and Deno runtime
2. **Downloads your application source code** - From [GitHub ↗](https://www.github.com), [GitLab ↗](https://www.gitlab.com) or via [Zerops CLI](/references/cli)
3. **Optionally customizes the build environment** - Runs prepare commands if configured
4. **Runs the build commands** - Executes your build process
5. **Uploads the application artifact** - Stores build output to internal Zerops storage
6. **Caches selected files** - Preserves specified files for faster future builds
The build container is automatically deleted after the build has finished or failed.
## Build configuration
Configure your Deno build process in your `zerops.yaml` file according to the [full build & deploy Deno pipeline guide](/deno/how-to/build-pipeline).
## Build environment
### Default Deno build environment
The default Deno build environment contains:
- {data.ubuntu.default}
- Selected version of Deno defined in `zerops.yaml` [build.base](/deno/how-to/build-pipeline#base) parameter
- [zCLI](/references/cli), Zerops command line tool
- Deno and Git
### Customize build environment
To install additional packages or tools, add one or more [build.prepareCommands](/deno/how-to/build-pipeline#preparecommands) to your `zerops.yaml`.
:::info
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::
### Build hardware resources
All runtime services use the same hardware resources for build containers:
  
      HW resource
      Minimum
      Maximum
    
      CPU cores
      1
      5
    
      RAM
      8 GB
      8 GB
    
      Disk
      1 GB
      100 GB
    
Build containers start with minimum resources and scale vertically up to maximum capacity as needed.
:::info
Build container resources are not charged separately. Limited build time is included in your [project core plan](/company/pricing#project-core-plans), with additional build time available if needed.
:::
### Build time limit
The time limit for the whole build pipeline is **1 hour**. After 1 hour, Zerops will terminate the build pipeline and delete the build container.
## Troubleshooting Deno builds
### Build command failures
If any [build command](/deno/how-to/build-pipeline#buildcommands) fails (returns non-zero exit code), the build is canceled. Check the [build log](/deno/how-to/logs#build-log) to troubleshoot the error.
For Deno, if the error log doesn't contain specific error messages, try running your build with verbose output:
```yaml
buildCommands:
  - deno cache main.ts
  - deno compile --allow-net --allow-read main.ts
```
### Prepare command failures
If any [prepare command](/deno/how-to/build-pipeline#preparecommands) fails, check the [build log](/deno/how-to/logs#build-log) for specific error messages. Common issues include:
- Missing permissions in Deno commands (add --allow-net, --allow-read, etc.)
- Ubuntu package installation failures (use sudo apt-get update first)
- Deno cache directory permissions
### Build cache issues
If you encounter unexpected build behavior or dependency issues, the problem might be related to [cached build data](/features/build-cache). While Zerops maintains the build cache to speed up deployments, sometimes you may need to start fresh.
To invalidate the build cache:
1. Go to your service detail in Zerops GUI
2. Choose **Pipelines & CI/CD Settings** from the left menu
3. Click on the **Invalidate build cache** button
This will force Zerops to run the next build clean, including all prepare commands. Learn more about [build cache behavior](/features/build-cache).
:::tip Advanced troubleshooting
For complex build issues that require investigation, you can enable [debug mode](/features/debug-mode) to pause the build process at specific points and inspect the build container state interactively.
:::
## More resources
For more details about the build and deploy pipeline, including how to cancel builds and manage application versions, see the [general pipeline documentation](/features/pipeline).
## Next steps
- Understand the [deployment process](/deno/how-to/deploy-process)
- Learn how to [customize the runtime environment](/deno/how-to/customize-runtime)
- Explore [build and runtime logs](/deno/how-to/logs)

----------------------------------------

# Deno > How To > Controls



----------------------------------------

# Deno > How To > Create

Zerops provides a powerful Deno runtime service with extensive build support. The Deno runtime is highly scalable and customizable to suit your development and production needs. With just a few clicks or commands, you can have a production-ready Deno environment up and running in no time.
## Create a Deno service using Zerops GUI
First, set up a project in the Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu under the **Services** section. From there, you can add a new Deno service:
### Choose a Deno version
Zerops supports the following Deno versions:
:::info
You can easily [upgrade](/deno/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app", "cache", "gui", etc. Duplicate services with the same name within the same project are not allowed.
#### Limitations:
- Maximum 25 characters
- Must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created and cannot be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as passwords, tokens, salts, certificates, etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting secret environment variables is optional. You can always set them later in the Zerops GUI.
Read more about the [different types of environment variables](/deno/how-to/env-variables#service-env-variables) in Zerops.
## Create a Deno service using zCLI
zCLI is the Zerops command-line tool. To create a new Deno service via the command line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/deno/how-to/create#create-a-project-description-file)
3. [Create a project with a Deno and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a YAML format to describe the project infrastructure.
#### Basic example:
Create a directory called `my-project`. Inside the `my-project` directory, create a `description.yaml` file with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in deno@{version} format
    type: deno@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Deno version 20 service with default [auto scaling](/deno/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/deno/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Deno and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in deno@{version} format
    type: deno@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Deno service and a [PostgreSQL](/postgresql/overview) service.
Deno service with "app" hostname, the internal port(s) the service listens on will be defined later in the [zerops.yaml](/deno/how-to/build-pipeline#ports). Deno service will run on version 20 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
| Parameter       | Description                                                                                                                     | Limitations             |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------- | ----------------------- |
| **name**        | The name of the new project. Duplicates are allowed.                                                                            |                         |
| **description** | **Optional.** Description of the new project.                                                                                   | Maximum 255 characters. |
| **tags**        | **Optional.** One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects. |
| **tags**        | **Optional.** One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects. |
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains Deno and PostgreSQL services but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
        hostname
      
        The unique service identifier.
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
        type
      
        Specifies the service type and version.
        
        See what [Deno service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
        verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        All verticalAutoscaling attributes are optional. Not specified
        attributes will be set to their default values.
      
         - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
         - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
         - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
         - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
        minContainers
      
        Optional. Default = 1. Defines the minimum number of containers
        for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        envSecrets
      
        Optional. Defines one or more secret env variables as a key value
        map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Deno service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in deno@{version} format
    type: deno@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Deno service version 20 with default [auto scaling](/deno/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Deno > How To > Customize Runtime

## Build Custom Runtime Images
Zerops allows you to build custom runtime images (CRI) when the default base runtime images don't meet your Deno application's requirements. This is an optional phase in the [build and deploy pipeline](/features/pipeline#runtime-prepare-phase-optional).
:::important
You should not include your application code in the custom runtime image, as your built/packaged code is deployed automatically into fresh containers.
:::
## Configuration
### Default Deno Runtime Environment
The default Deno runtime environment contains:
- {data.ubuntu.default}
- Selected version of Deno when the runtime service was created
- [zCLI](/references/cli)
- Deno and Git
### When You Need a Custom Runtime Image
If your Deno application needs more than what's included in the default environment, you'll need to build a custom runtime image. Common scenarios include:
- **System packages for processing**: When your app processes images, videos, or files (requiring packages like `sudo apt-get install -y imagemagick`)
- **Global Deno tools**: When you need CLI tools or utilities available system-wide
- **Native dependencies**: When your Deno modules require system libraries that aren't in the default environment
Here are Deno-specific examples of configuring custom runtime images in your `zerops.yml`:
### Basic Deno Setup
    
### Using Build Files in Runtime Preparation
```yaml
build:
  addToRunPrepare:
    - deno.json
    - import_map.json
run:
  prepareCommands:
    - sudo apt-get update
    - sudo apt-get install -y imagemagick
    - deno cache deps.ts
```
For complete configuration details, see the [runtime prepare phase configuration guide](/features/pipeline#configuration).
## Process and Caching
### How Runtime Prepare Works
The runtime prepare process follows the same steps for all runtimes. See [how runtime prepare works](/features/pipeline#how-it-works) for the complete process details.
### Caching Behavior
Zerops caches custom runtime images to optimize deployment times. Learn about [custom runtime image caching](/features/pipeline#custom-runtime-image-caching) including when images are cached and reused.
### Build Management
For information about managing builds and deployments, see [managing builds and deployments](/features/pipeline#manage-builds-and-deployments).
:::warning
Shared storage mounts are not available during the runtime prepare phase.
:::
## Troubleshooting
If your `prepareCommands` fail, check the [prepare runtime log](/deno/how-to/logs#prepare-runtime-log) for specific error messages.

----------------------------------------

# Deno > How To > Delete



----------------------------------------

# Deno > How To > Deploy Process



----------------------------------------

# Deno > How To > Env Variables



----------------------------------------

# Deno > How To > Filebrowser



----------------------------------------

# Deno > How To > Logs



----------------------------------------

# Deno > How To > Scaling



----------------------------------------

# Deno > How To > Shared Storage



----------------------------------------

# Deno > How To > Trigger Pipeline



----------------------------------------

# Deno > How To > Upgrade



----------------------------------------

# Deno > Overview

[Deno ↗](https://deno.org/en) is an asynchronous event-driven JavaScript runtime, which is designed to build scalable network applications.
:::tip
Have you got any additional question? Join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-deno), a **_recipe_**, containing the most simple Deno web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of Deno app running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-deno/blob/main/zerops-project-import.yaml)):
```yaml
project:
  name: recipe-deno
  tags:
    - zerops-recipe
services:
  - hostname: api
    type: deno@1
    buildFromGit: https://github.com/zeropsio/recipe-deno
    enableSubdomainAccess: true
  - hostname: db
    type: postgresql@16
    mode: NON_HA
    priority: 1
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://api-7f6-8000.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
{"message":"This is a simple, basic Deno / Oak application running in Zerops.io,\n      each request adds an entry to the PostgreSQL database and returns a count.\n      See the source repository (https://github.com/zeropsio/recipe-deno) for more information.","newEntry":"274b0cc1-5b6d-4351-b8ec-53cf82bd9d0f","count":1}
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
It doesn't matter whether it's your first curious introduction to Zerops, you have already mastered the basics and are looking for a tiny detail or inspiration. Below, choose a section that fits your needs:
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Docker > Overview

Zerops provides Docker support through dedicated Virtual Machine (VM) environments, ensuring maximum compatibility and isolation while maintaining integration with the broader Zerops ecosystem. This guide explains how to effectively use Docker services in Zerops, including best practices and important considerations.
## Why VMs
While Zerops primarily uses native Linux containers for optimal performance, this VM-based approach allows you to run virtually any Docker container while maintaining Zerops' robust infrastructure management.
You can learn more about [differences](/features/container-vs-vm) between Containers and Virtual Machines in Zerops.
Before using Docker services, consider these important aspects:
### Virtual Machine Environment
Docker services in Zerops operate in a full VM environment, which has several implications:
- **Slower Boot Times**: VMs require more time to initialize due to full kernel boot
- **Higher Resource Usage**: VMs include additional system overhead compared to native containers
- **Scaling Limitations**:
    - Vertical scaling requires VM restart
    - Resources must be set as fixed values (no min-max ranges)
    - Zerops automatically restarts the VM when resource values are changed in UI
- **Storage Management**: Disk space can only be increased, not decreased without recreation
- **Build Phase Limitations**: Build phase runs in containers, not in the VM environment
### Advantages
Despite these limitations, Docker services offer some benefits:
- **Broad Compatibility**: Run almost any Docker container with minimal modification
- **Familiar Environment**: Standard Docker runtime environment
## Configuration Guide
### Supported Version
Currently supported Docker versions:
### Basic Structure
Docker services in Zerops are configured through the `zerops.yaml` file. Here's a typical configuration pattern:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    run:
      prepareCommands:
        - docker image pull :  # Always use specific version tags
      start: docker run --network=host :
      ports:
        - port: 
          httpSupport: true
```
:::important
Always use specific version tags (like `1.0.0`) instead of `:latest`. Zerops caches the `prepareCommands` output, which means a new `:latest` image won't be automatically pulled on subsequent deployments unless the cache is manually cleared or the commands change.
:::
Refer to the [Docker recipe repository](https://github.com/zeropsio/recipe-docker) for an example configuration.
:::note
We are actively working on improving the speed of image caching after `run.prepareCommands` and reducing the startup time of runtime VMs. These improvements will be released in future updates.
:::
### Network Configuration
Docker services require the `--network=host` flag for proper integration with Zerops:
- **Direct Port Management**: Ports are managed through `zerops.yaml`
- **Simplified Configuration**: Avoids double port exposure in Docker and Zerops
- **Native Performance**: Direct access to host networking
### Docker Compose Support
For projects using Docker Compose, additional configuration is required:
1. **File Deployment**:
   ```yaml title="zerops.yaml"
   build:
     deployFiles: ./docker-compose.yaml
     addToRunPrepare: ./docker-compose.yaml
   ```
2. **Network Mode**:
   ```yaml title="docker-compose.yaml"
   services:
     your-service:
       image: your-image:1.0.0
       network_mode: host
   ```
3. **Start Command**:
   ```yaml title="zerops.yaml"
   run:
     start: docker compose up --force-recreate
   ```
### Environment Variables
When using Docker services, there's an additional layer to consider since environment variables defined in Zerops must be explicitly passed to your Docker containers.
#### 1. Defining Variables in Zerops
Define your environment variables in the `run.envVariables` section of your `zerops.yaml` (example uses [referenced](/features/env-variables#referencing-variables) variables):
```yaml title="zerops.yaml"
zerops:
  - setup: app
    run:
      envVariables:
        DB_HOST: ${db_hostname}
        DB_PORT: ${db_port}
```
#### 2. Passing Variables to Docker Containers
For single containers, pass variables using the `-e` flag:
```yaml title="zerops.yaml"
run:
  prepareCommands:
    - docker image pull my-application:1.0.0  # Use specific version tags, not :latest
  start: docker run -e DB_HOST -e DB_PORT --network=host my-application:1.0.0
```
:::important
Always use specific version tags (like `1.0.0`) instead of `:latest`. Zerops caches the `prepareCommands` output, which means a new `:latest` image won't be automatically pulled on subsequent deployments unless the cache is manually cleared or the commands change.
:::
For Docker Compose setups, pass environment variables in your `docker-compose.yaml`:
```yaml title="docker-compose.yaml"
services:
  api:
    image: my-application:1.0.0
    network_mode: host
    environment:
      - DB_HOST
      - DB_PORT
```
## Implementation Examples
### Single Container
```yaml title="zerops.yaml"
zerops:
  - setup: app
    run:
      prepareCommands:
        - docker image pull crccheck/hello-world:1.0.0  # Always use specific version tags
      start: docker run --network=host crccheck/hello-world:1.0.0
      ports:
        - port: 8000
          httpSupport: true
```
:::important
Always use specific version tags (like `1.0.0`) instead of `:latest`. Zerops caches the `prepareCommands` output, which means a new `:latest` image won't be automatically pulled on subsequent deployments unless the cache is manually cleared or the commands change.
:::
### Single Service with Docker Compose
```yaml title="zerops.yaml"
zerops:
  - setup: api
    build:
      deployFiles: ./docker-compose.yaml
      addToRunPrepare: ./docker-compose.yaml
    run:
      prepareCommands:
        - docker compose pull api
      start: docker compose up api --force-recreate
      ports:
        - port: 8000
          httpSupport: true
```
```yaml title="docker-compose.yaml (excerpt)"
services:
  api:
    image: your-image:1.0.0
    network_mode: host
    # other configuration...
```
### Multiple Services with Docker Compose
```yaml title="zerops.yaml"
zerops:
  - setup: apps
    build:
      deployFiles: ./docker-compose.yaml
      addToRunPrepare: ./docker-compose.yaml
    run:
      prepareCommands:
        - docker compose pull
      start: docker compose up --force-recreate
      ports:
        - port: 8000
          httpSupport: true
```
```yaml title="docker-compose.yaml (excerpt)"
services:
  web:
    image: web-image:1.0.0
    network_mode: host
    # other configuration...
  api:
    image: api-image:1.0.0
    network_mode: host
    # other configuration...
```
## Best Practices
#### Image Management
- **Always use specific version tags** instead of `:latest` - This prevents caching issues as Zerops caches `prepareCommands` output
#### Resource Planning
- Account for VM overhead in resource allocation
- Plan for longer initialization times
- Consider the impact on scaling operations
#### Migration Consideration
- Evaluate if your workload could run on native containers
- Consider gradual migration for complex applications
- Balance development effort against operational benefits
## Limitations and Workarounds
### Build Phase
Since the build phase runs in containers rather than VMs:
- Use `run.prepareCommands` for Docker-specific build steps
- Consider external CI/CD for complex Docker builds
- Leverage pre-built images when possible
### Scaling Operations
Docker services in Zerops have specific scaling characteristics that differ from native containers:
#### Vertical Scaling
- Resources must be defined with **fixed** values instead of min-max ranges
- CPU, RAM, and disk are specified as single values:
  ```yaml
  verticalAutoscaling:
    cpu: 3
    ram: 2
    disk: 20
  ```
- Any change to these values through the UI triggers an automatic VM restart
- Plan your resource allocation carefully to minimize scaling operations
#### Horizontal Scaling
- Still supports multiple containers through `minContainers` and `maxContainers`
- Consider breaking large services into smaller components
- Implement proper health checks for reliable scaling
- Use horizontal scaling when possible to avoid VM restarts

----------------------------------------

# Dotnet > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your .NET application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: dotnet@6
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - npm i
        - npm run build
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - dist
        - package.json
        - node_modules
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      cache: node_modules
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: dotnet@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 5000
      # OPTIONAL. Customize the runtime .NET environment by installing additional
      # dependencies to the base .NET runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your .NET application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your .NET application start command
      start: npm start
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for .NET builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: dotnet@6
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  major version of .NET, Zerops command line tool, `ASP .NET` and `git`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - dotnet@6
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customize your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customized.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customizes the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of .NET defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `ASP .NET` and `git`
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: dotnet@6
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/dotnet/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: dotnet@6
      # OPTIONAL. Build your application
      buildCommands:
        - dotnet build -o app
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
buildCommands:
  - |
    sudo apt-get -y install dotnet-runtime-6.0 aspnetcore-runtime-6.0 dotnet-sdk-6.0 # already installed for .NET service
    dotnet build -o app
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
buildCommands:
  - sudo apt-get -y install dotnet-runtime-6.0 aspnetcore-runtime-6.0 dotnet-sdk-6.0 # already installed for .NET service
  - dotnet build -o app
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/dotnet/how-to/logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the `--verbosity ` option.
```yaml
buildCommands:
  - dotnet build --verbosity detailed
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - app
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - app
  - file.txt
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: dotnet@6
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        DOTNET_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/dotnet/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current .NET version for your runtime.
Following options are available for .NET builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: dotnet@6
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: dotnet@6
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of .NET, Zerops command line tool and `ASP .NET` and `git`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: dotnet@6
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - dotnet@6
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customise your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a .NET service with hostname = "app" and port = 5000 from another service of the same project, simply use `app:5000`. Read more about [how to access a .NET service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customises the .NET runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base .NET environment contains {data.alpine.default}, the selected
  major version of .NET, Zerops command line tool and `ASP .NET` and `git`. To install additional packages
  or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base .NET runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/dotnet/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
When the prepare cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the
  selected major version of .NET,
  Zerops command line tool and
  `ASP .NET` and `git`.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base .NET runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your .NET application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your .NET application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/dotnet/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/dotnet/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        DOTNET_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/dotnet/how-to/env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your .NET application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your .NET application start command
      start: cd app && dotnet dnet.dll
```
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your .NET application start command
      start: cd app && dotnet dnet.dll
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your .NET application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your .NET application start command
      start: cd app && dotnet dnet.dll
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/dotnet/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/dotnet/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your .NET application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/dotnet/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Dotnet > How To > Build Process



----------------------------------------

# Dotnet > How To > Controls



----------------------------------------

# Dotnet > How To > Create

Zerops provides a .NET runtime service with extensive build support. .NET runtime is highly scalable and customisable to suit both development and production.
## Create .NET service using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new .NET service:
### Choose .NET version
Following .NET versions are currently supported:
:::info
You can [change](/dotnet/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app","cache", "gui" etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
- maximum 25 characters
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created. It can't be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as password, tokens, salts, certificates etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting the secret environment variables is optional. You can set them later in Zerops GUI.
Read more about [different types of env variables](/dotnet/how-to/env-variables#service-env-variables) in Zerops.
## Create .NET service using zCLI
zCLI is the Zerops command-line tool. To create a new .NET service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/dotnet/how-to/create#create-a-project-description-file)
3. [Create a project with a .NET and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a yaml format to describe the project infrastructure.
#### Basic example:
Create a directory `my-project`. Create an `description.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in dotnet@6 format
    type: dotnet@6
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one .NET version 6 service with default [auto scaling](/dotnet/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/dotnet/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a .NET and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in dotnet@6 format
    type: dotnet@6
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create secret env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a .NET service and a [PostgreSQL](/postgresql/overview) service.
.NET service with "app" hostname, the internal port(s) the service listens on will be defined later in the [zerops.yaml](/dotnet/how-to/build-pipeline#ports). .NET service will run on version 6 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      
      description
      Optional. Description of the new project.
      Maximum 255 characters.
    
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains .NET and PostgreSQL services but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
         
        The hostname of the new database will be set to the `hostname` value.
         
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the service type and version.
        See what [.NET service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
      verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
      - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
      - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
      - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
      - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
      minContainers
      
        Optional. Default = 1. Defines the minimum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      envSecrets
      
        Optional. Defines one or more secret env variables as a key value map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add .NET service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in dotnet@6 format
    type: dotnet@6
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one .NET service version 6 with default [auto scaling](/dotnet/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Dotnet > How To > Customize Runtime

System packages for processing: When your app processes images, videos, or files (requiring packages like sudo apk add imagemagick)',
  'Native libraries: When your .NET packages require system libraries that aren\'t in the default environment',
  'Development tools: When you need additional debugging or profiling tools',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />

----------------------------------------

# Dotnet > How To > Delete



----------------------------------------

# Dotnet > How To > Deploy Process



----------------------------------------

# Dotnet > How To > Env Variables



----------------------------------------

# Dotnet > How To > Filebrowser



----------------------------------------

# Dotnet > How To > Logs



----------------------------------------

# Dotnet > How To > Scaling



----------------------------------------

# Dotnet > How To > Shared Storage



----------------------------------------

# Dotnet > How To > Trigger Pipeline



----------------------------------------

# Dotnet > How To > Upgrade



----------------------------------------

# Dotnet > Overview

[.NET ↗](https://dotnet.microsoft.com/en-us/) is the free, open-source, cross-platform framework for building modern apps and powerful cloud services..
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-dotnet-hello-world), a **_recipe_**, containing the most simple .NET web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of .NET running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-dotnet-hello-world/blob/main/import-project/description.yaml)):
```yaml
project:
  name: my-first-project
services:
  - hostname: helloworld
    type: dotnet@latest
    minContainers: 1
    maxContainers: 3
    buildFromGit: https://github.com/zeropsio/recipe-dotnet-hello-world@main
    enableSubdomainAccess: true
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://helloworld-24-8080.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
Hello, World!
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Elasticsearch > Overview

Deploy [Elasticsearch](https://www.elastic.co/elasticsearch/) instances in Zerops with flexible scaling options, from standalone nodes to highly available clusters.
## Supported Versions
Currently supported Elasticsearch versions:
Import configuration version:
## Connection Details
- **Port**: 9200
- **Protocol**: HTTP only
- **Internal Access**: `http://{hostname}:9200`
- **Basic auth security**
    - **User**: `elastic`
    - **Password**: randomly generated during service creation, find under **Access Details** in service detail
#### Example
```sh
curl -u elastic:generatedpassword http://elasticsearch:9200
```
## Configuration Options
### Plugin Management
You can configure Elasticsearch plugins using a comma-separated list in your environment secrets:
```yaml
envSecrets:
  PLUGINS: "analysis-icu,ingest-attachment"
```
**Plugin Configuration Details:**
- Defines plugins to install at service startup
- **Format**: `plugin1,plugin2,...`
- Service automatically installs specified plugins during initialization
- Removing a plugin from this list triggers uninstallation on service restart
### JVM Heap Allocation
Control the JVM heap size as a percentage of container memory:
```yaml
envSecrets:
  HEAP_PERCENT: "75"
```
**Heap Configuration Details:**
- Value represents the percentage of container memory allocated to JVM heap
- **Default**: 50% of available container memory
- **Valid range**: 1-100
- To increase available memory, adjust the service's RAM allocation in scaling configuration
:::note Requires Restart
Changes to HEAP_PERCENT require a service restart to take effect.
:::
## Backup
Elasticsearch backups are created using `elasticdump`:
- **Format**: `.gz` (per index/component dump)
- **Tooling**: `elasticdump`
- **Compression**: Gzip compressed JSON data
For backup configuration, scheduling, retention policies, and management options, see the [Zerops Backups](/features/backup) documentation.
### Restoring Backups
To restore an Elasticsearch backup:
1. **Download** the backup file (`.gz`) from the Zerops UI
2. **Extract** the compressed files to access the JSON data
3. **Prepare** your target environment (clean existing indices or use a new instance)
4. **Restore** using either:
   - **elasticdump tool**: Use the same tool that created the backup for restoration via Zerops VPN or during deployment
   - **Elasticsearch API**: Import the data through REST API [calls](https://www.elastic.co/docs/deploy-manage/tools/snapshot-and-restore/restore-snapshot)
For assistance with the restoration process, contact Zerops support.
## Example Configuration
```yaml
services:
  - hostname: elasticsearch
    type: elasticsearch@8.16
    mode: HA
    envSecrets:
      PLUGINS: "analysis-icu,ingest-attachment"
      HEAP_PERCENT: "75"
```
## Related Resources
- [Elasticsearch Official Documentation](https://www.elastic.co/guide/index.html)
- [Available Elasticsearch Plugins](https://www.elastic.co/guide/en/elasticsearch/plugins/current/index.html)

----------------------------------------

# Elixir > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Elixir application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: elixir@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customise the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - mix deps.get --only prod
        - mix compile
        - mix release
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles: _build/prod/rel/app/
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      cache: node_modules
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: elixir@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 3000
      # OPTIONAL. Customise the runtime Elixir environment by installing additional
      # dependencies to the base Elixir runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Elixir application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your Elixir application start command
      start: npm start
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Elixir builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: elixir@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  major version of Elixir, Zerops command line tool, `npm`, `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - elixir@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customise your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customises the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of Elixir defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `npm`, `yarn`, `git` and `npx` tools
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: elixir@latest
      # OPTIONAL. Customise the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/elixir/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: elixir@latest
      # OPTIONAL. Build your application
      buildCommands:
        - npm i
        - npm run build
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
buildCommands:
  - |
    npm i
    npm run build
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
buildCommands:
  - npm i
  - npm run build
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/elixir/how-to/logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the --verbose option.
```yaml
buildCommands:
  - npm i --verbose
  - npm run build
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - dist
  - package.json
  - node_modules
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - dist
  - package.json
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: elixir@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/elixir/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Elixir version for your runtime.
Following options are available for Elixir builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: elixir@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: elixir@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of Elixir, Zerops command line tool, `npm`, `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: elixir@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - elixir@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customise your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Elixir service with hostname = "app" and port = 3000 from another service of the same project, simply use `app:3000`. Read more about [how to access a Elixir service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
| parameter   | description                                                                                                                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| port        | Defines the port number. You can set any port number between _10_ and _65435_. Ports outside this interval are reserved for internal Zerops systems.                                                                                                                                                                   |
| protocol    | **Optional.** Defines the protocol. Allowed values are `TCP` or `UDP`. Default value is `TCP`.                                                                                                                                                                                                                         |
| httpSupport | **Optional.** `httpSupport = true` is the default setting for TCP protocol. Set `httpSupport = false` if a web server isn't running on the port. Zerops uses this information for the configuration of [public access](/features/access). `httpSupport = true` is available only in combination with the TCP protocol. |
| httpSupport | **Optional.** `httpSupport = true` is the default setting for TCP protocol. Set `httpSupport = false` if a web server isn't running on the port. Zerops uses this information for the configuration of [public access](/features/access). `httpSupport = true` is available only in combination with the TCP protocol. |
### prepareCommands
_OPTIONAL._ Customises the Elixir runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Elixir environment contains {data.alpine.default} the selected
  major version of Elixir, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools. To install
  additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Elixir runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/elixir/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the custom runtime cache go to `yyy`
When the custom runtime cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the
  selected major version of Elixir, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Elixir runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Elixir application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Elixir application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/elixir/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/elixir/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/elixir/how-to/env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your Elixir application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Elixir application start command
      start: npm start
```
We recommend starting your Elixir application using `npm start`.
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Elixir application start command
      start: npm start
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
| Parameter   | Description                                                                                                                                                                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **command** | Defines a local command to be run.
The command has access to the same [environment variables](/elixir/how-to/create#set-secret-environment-variables) as your Elixir application.
A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below. |
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Elixir application start command
      start: npm start
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/elixir/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
<table className="w-full my-1.5">
  <thead>
    <tr>
      <th className="w-fit whitespace-nowrap">Parameter</th>
      <th className="w-fit whitespace-nowrap">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">port</td>
      <td>Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on <code>{'http://127.0.0.1:{port}/{path}'}</code></td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">path</td>
      <td>Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on <code>{'http://127.0.0.1:{port}/{path}'}</code></td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">host</td>
      <td><strong>Optional.</strong> The readiness check is triggered from inside of your runtime container so it always uses the localhost <code>127.0.0.1</code>. If you need to add a <code>host</code> to the request header, specify it in the <code>host</code> attribute.</td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">scheme</td>
      <td><strong>Optional.</strong> The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set <code>scheme: https</code></td>
    </tr>
  </tbody>
</table>
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/elixir/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
| Parameter   | Description                                                                                                                                                                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **command** | Defines a local command to be run.
The command has access to the same [environment variables](/elixir/how-to/create#set-secret-environment-variables) as your Elixir application.
A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below. |
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/elixir/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Elixir > How To > Build Process



----------------------------------------

# Elixir > How To > Controls



----------------------------------------

# Elixir > How To > Create

Zerops provides a powerful Elixir runtime service with extensive build support. The Elixir runtime is highly scalable and customizable to suit your development and production needs. With just a few clicks or commands, you can have a production-ready Elixir environment up and running in no time.
## Create a Elixir service using Zerops GUI
First, set up a project in the Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu under the **Services** section. From there, you can add a new Elixir service:
### Choose a Elixir version
Zerops supports the following Elixir versions:
:::info
You can easily [upgrade](/elixir/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app", "cache", "gui", etc. Duplicate services with the same name within the same project are not allowed.
#### Limitations:
- Maximum 25 characters
- Must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created and cannot be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as passwords, tokens, salts, certificates, etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting secret environment variables is optional. You can always set them later in the Zerops GUI.
Read more about the [different types of environment variables](/elixir/how-to/env-variables#service-env-variables) in Zerops.
## Create a Elixir service using zCLI
zCLI is the Zerops command-line tool. To create a new Elixir service via the command line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/elixir/how-to/create#create-a-project-description-file)
3. [Create a project with a Elixir and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a YAML format to describe the project infrastructure.
#### Basic example:
Create a directory called `my-project`. Inside the `my-project` directory, create a `description.yaml` file with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in elixir@{version} format
    type: elixir@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Elixir version 20 service with default [auto scaling](/elixir/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/elixir/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Elixir and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in elixir@{version} format
    type: elixir@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Elixir service and a [PostgreSQL](/postgresql/overview) service.
Elixir service with "app" hostname, the internal port(s) the service listens on will be defined later in the [zerops.yaml](/elixir/how-to/build-pipeline#ports). Elixir service will run on version 20 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
| Parameter       | Description                                                                                                                     | Limitations             |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------- | ----------------------- |
| **name**        | The name of the new project. Duplicates are allowed.                                                                            |                         |
| **description** | **Optional.** Description of the new project.                                                                                   | Maximum 255 characters. |
| **tags**        | **Optional.** One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects. |
| **tags**        | **Optional.** One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects. |
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains Elixir and PostgreSQL services but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
        hostname
      
        The unique service identifier.
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
        type
      
        Specifies the service type and version.
        
        See what [Elixir service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
        verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        All verticalAutoscaling attributes are optional. Not specified
        attributes will be set to their default values.
      
         - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
         - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
         - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
         - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
        minContainers
      
        Optional. Default = 1. Defines the minimum number of containers
        for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        envSecrets
      
        Optional. Defines one or more secret env variables as a key value
        map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Elixir service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in elixir@{version} format
    type: elixir@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Elixir service version 20 with default [auto scaling](/elixir/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Elixir > How To > Customize Runtime

System packages for processing: When your app processes images, videos, or files (requiring packages like sudo apk add imagemagick)',
  'Erlang libraries: When you need additional Erlang libraries not included by default',
  'Native dependencies: When your Mix dependencies require system libraries that aren\'t in the default environment',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />

----------------------------------------

# Elixir > How To > Delete



----------------------------------------

# Elixir > How To > Deploy Process



----------------------------------------

# Elixir > How To > Env Variables



----------------------------------------

# Elixir > How To > Filebrowser



----------------------------------------

# Elixir > How To > Logs



----------------------------------------

# Elixir > How To > Scaling



----------------------------------------

# Elixir > How To > Shared Storage



----------------------------------------

# Elixir > How To > Trigger Pipeline



----------------------------------------

# Elixir > How To > Upgrade



----------------------------------------

# Elixir > Overview

[Elixir ↗](https://elixir.org/en) is an asynchronous event-driven JavaScript runtime, which is designed to build scalable network applications.
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-elixir), a **_recipe_**, containing the most simple Elixir web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of Elixir app running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-elixir/blob/main/zerops-project-import.yaml)):
```yaml
project:
  name: recipe-elixir
  tags:
    - zerops-recipe
services:
  - hostname: api
    type: elixir@1.16
    enableSubdomainAccess: true
    buildFromGit: https://github.com/zeropsio/recipe-elixir
  - hostname: db
    type: postgresql@16
    mode: NON_HA
    priority: 1
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://api-808-4000.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
{"message":"This is a simple Elixir application running in Zerops.io, each request adds an entry to the PostgreSQL database and returns a count. See the source repository (https://github.com/zeropsio/recipe-elixir) for more information.","newEntry":"e64be640-d6c2-4be8-93ac-d1e40e56fa06","count":1}
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
It doesn't matter whether it's your first curious introduction to Zerops, you have already mastered the basics and are looking for a tiny detail or inspiration. Below, choose a section that fits your needs:
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Features > Access

Zerops provides multiple ways to access your services, whether you need internal communication between services, secure access from your development machine, or public access from the internet.
:::note
By default, your services are not publicly accessible until you configure external access. Internal communication between services within the same project works automatically.
:::
## How Zerops Networking Works
Every Zerops project includes a **shared networking infrastructure** that handles all access methods:
**Private Project Network:**
- All services within a project share a dedicated private network
- Services communicate directly using hostnames and internal ports
- Traffic stays isolated within your project
**Public Access Infrastructure:**
- **Core (L3) Balancer** manages IP addresses and direct port access
- **L7 HTTP Balancer** handles domain routing and SSL termination
  - Can be extensively configured for advanced routing, performance optimization, and custom behaviors
  - See the [L7 Balancer Configuration Guide](/references/networking/l7-balancer-config) for detailed options
- Both are shared across all services in your project
**Secure External Access:**
- **Built-in VPN** provides secure tunnel access to your project's private network
- Useful for development, debugging, and administration
## Internal Access
:::tip Complete Internal Access Setup
See the [Internal access reference guide](/references/networking/internal-access).
:::
Services within the same project can communicate directly using hostnames and internal ports. No additional configuration required.
**Example:** Connect to your `api` service on port 3000:
```
http://api:3000
```
**Key points:**
- Use service hostname as the address
- Use HTTP (not HTTPS) for internal communication
- Access internal ports defined in your service configuration
- Communication is automatically isolated from other projects
### Environment Variables
Zerops automatically creates environment variables to help with internal connections between services.
## VPN Access
:::tip Complete VPN Setup
See the [VPN reference guide](/references/networking/vpn).
:::
Connect securely to your project's internal network from your local machine:
```bash
# Connect to your project
zcli vpn up 
# Access services using internal hostnames
curl http://api:3000/health
# Disconnect when done
zcli vpn down
```
## Public Access
:::tip Complete Public Access Setup
See the [Public access reference guide](/references/networking/public-access).
:::
Make your services accessible from the internet using one of three methods:
### Zerops Subdomain
**Best for:** Development and testing
- Quick setup with automatic `.zerops.app` subdomains
- Each service gets its own unique subdomain
- Automatic SSL certificate management
- Shared infrastructure (has limitations for production use)
### Custom Domain
**Best for:** Production deployments
- Use your own domain names
- Better performance with dedicated balancer
- Full control over SSL and routing
- Requires DNS configuration
### Direct Port Access
**Best for:** Non-HTTP protocols and specialized use cases
- Direct access to specific ports on your services
- Supports any protocol (TCP/UDP)
- Optional firewall configuration
- Uses your project's IP addresses
## Next Steps
- **Internal access setup:** [Internal Access Reference Guide](/references/networking/internal-access)
- **Public access configuration:** [Public Access Reference Guide](/references/networking/public-access)
- **VPN setup and troubleshooting:** [VPN Reference Guide](/references/networking/vpn)
- **Advanced routing and SSL:** [L7 Balancer Configuration Guide](/references/networking/l7-balancer-config)

----------------------------------------

# Features > Backup

Zerops provides an automated, secure backup system for supported services. This guide covers how to configure, manage, and restore your backups.
## Supported Services
Zerops provides automated backup functionality for the following services. For specific backup format details and restore instructions, visit each service's documentation: [MariaDB](/mariadb/how-to/backup), [PostgreSQL](/postgresql/how-to/backup), [Qdrant](/qdrant/overview), [Elasticsearch](/elasticsearch/overview), [NATS](/nats/overview), [Meilisearch](/meilisearch/overview), and [Shared Storage](/shared-storage/how-to/backup).
## Managing Backups in the UI
By default, your data is backed up automatically **every day** between 00:00:00 UTC and 01:00:00 UTC, unless you update your settings.
To manage backups, go to the service detail and choose **Backups List & Configuration** in the left menu.
From this section, you can:
- Create a one-time backup
- Change the frequency/disable of automatic backups
- Configure retention policies and limits
  
### Backup Frequency Options
Available schedules:
- **No backups**: Disable automatic backups (not recommended)
- **Once a day**: Daily backups at a specified time
- **Once a week**: Weekly backups on a specific day and time
- **Once a month**: Monthly backups on a specific day and time
- **Custom CRON**: Define a custom schedule using CRON syntax
For the Custom CRON option, you can use the following syntax:
  
      Field name
      Allowed values
    
      Minute
      0-59
    
      Hour
      0-23
    
      Day
      1-31
    
      Month
      1-12
    
      Week Day
      0–7; both 0 and 7 represent Sunday
    
Examples:
- `0 2 * * *` - Every day at 2:00 AM
- `0 4 * * 0` - Every Sunday at 4:00 AM
- `0 0 1 * *` - First day of every month at midnight
- `0 */6 * * *` - Every 6 hours
### Backup Tagging
Zerops uses tags to categorize and manage backups:
**Time-Based Tags** (assigned automatically):
- `daily`: Every automatic backup
- `weekly`: First backup of each week (Monday UTC)
- `monthly`: First backup of each month (1st UTC)
**User Tags** (custom labels you create):
- Used for organization and identification (e.g., `v2.1-release`, `before-migration`, `monthly-snapshot`)
- Add when creating manual backups - up to 24 characters (letters, numbers, `:-_`)
**Protected Tags** (configured in retention policy):
- Backups with these tag names are exempt from automatic deletion, regardless of storage limits
- Define in the backup retention configuration section of the UI and add when creating manual backups
:::important
Manual backups don't get automatic time-based tags. Always add a protected tag to preserve critical manual backups.
:::
### View and Manage Backup Files
In this section, you can:
- Create manual backups
- View all backups with their timestamps and sizes
- Download backups
- Delete backups
  
:::note
When creating manual backups via the UI, you'll see immediate feedback. If the backup takes longer than 10 seconds, the process continues in the background. You can verify completion by refreshing the backup list or checking service logs.
:::
## Storage and Limits
### Project Storage Quotas
Each Zerops project has a **technical maximum backup storage limit of 1 TiB**:
- Only full backups are stored
- If a backup would exceed the storage limit, it will not be stored
- This quota is shared across all service backups within the project
### Billing
- **Lightweight Project Core**: 5 GB backup storage and 100 GB egress included
- **Serious Project Core**: 25 GB backup storage and 3 TB egress included
When you exceed your plan's free limits, **additional charges apply** according to our [pricing](/company/pricing#overage-costs).
### Retention Policy and Configuration
Zerops manages which backups are kept using a retention policy that you can customize through the UI:
**Default Time-Based Retention** (minimums):
- At least 7 daily backups
- At least 4 weekly backups
- At least 3 monthly backups
**Default Resource Limits** (maximums):
- Max 50 total backups per service
- Storage limited to your project's 1 TiB technical maximum (with billing for usage beyond free tier)
**Customization Options:**
You can modify these defaults in the backup retention configuration interface:
- **Set Protected Tags**: Define tag names that prevent automatic deletion of backups
- **Configure Maximum Limits**: Adjust total number of backups and storage size limits per service
- **Customize Minimum Retention**: Change how many daily, weekly, and monthly backups to keep
- **Set Type-Specific Limits**: Control maximum backups for each type (0 means unlimited, subject to total limits)
:::important
Backups with [protected tags](#backup-tagging) and the minimum required time-based backups will always be kept, even if they exceed the limits above. This ensures your critical recovery points are preserved.
:::
If you need more storage space, contact our support team.
### When Deleting Services or Projects
Deleted services/projects have their backups kept for a 7-day grace period before final removal.
## Command Line Interface
You can also manage backups using the Zerops CLI (zCLI):
```bash
# Create a backup
zcli backup create myServiceName
# Create a backup with tags (including protection)
zcli backup create myServiceName --tags pre-deploy,protected
```
Check `zcli backup --help` for current commands.
:::note
zCLI currently focuses on creation; listing/deletion/tag management is primarily via UI.
:::
## Restoring Backups
Restoration involves downloading backups and using service-specific methods. Zerops facilitates the backup creation and download; the restore action uses service-specific tools and APIs.
1. **Download**: Find the backup in the UI (by date/tag) and download it
2. **Prepare**: Set up your target environment (clean existing data or use a new instance)
3. **Restore**: Use service-specific tools via Zerops VPN, run the restore during deployment, or use the service API if available. For service-specific restore instructions, see each service's documentation linked in the [Supported Services](#supported-services) section above.
:::info Continuous Improvement
We're working on enhancing the restore experience, potentially including more automated options in the future.
:::
For assistance with restoration, contact Zerops support.
## High Availability (HA)
For multi-node HA services:
- **Automatic Backups**: Run on a randomly selected healthy node
- **Manual Backups**: Typically run on the primary/designated node (check logs)
- **Cluster State**: Other nodes stay operational
## Security
Backups are protected with end-to-end encryption:
- **Unique Encryption**: Each project gets its own encryption key (X25519)
- **Secure Process**: Data is encrypted immediately as backups are created
- **Zero-Trust**: Even Zerops staff cannot access your raw backup data
- **Isolated Storage**: Backups are stored separately from your regular data
- **Secure Download**: Backups are only decrypted when you download them
:::important
When a project is deleted, the encryption key is permanently destroyed after 7 days, making the backup data unrecoverable.
:::
## Best Practices
1. **Create backups before major changes**:
   - Always create a manual backup with a protected tag before database migrations, deployments, or large data operations
   - Use descriptive tags like `pre-migration` or `pre-release-v2`
2. **Manage storage efficiently**:
   - Regularly check usage in the Project Overview & Service Backup tabs to monitor free tier usage and stay within the 1 TiB technical limit
   - Remove unnecessary backups, especially those with [protected tags](#backup-tagging)
   - Adjust [retention policies](#retention-policy-and-configuration) based on your recovery needs
   - Regularly review and clean up old backups to optimize storage usage and minimize overage costs
3. **Test your restore process** periodically in a non-production environment to ensure you can recover when needed
## Troubleshooting
### Storage Quota Issues
**Cause**: High backup frequency, long retention periods, or many protected tags can lead to exceeding free tier limits or approaching technical maximums.
**Solutions**:
1. **Review & Prune**: Delete unnecessary manual backups or remove protected status from older backups
2. **Adjust Retention Policy**: Reduce minimum retention counts if your recovery requirements allow
3. **Optimize Schedule**: Reduce backup frequency if daily backups aren't essential
4. **Monitor Costs**: Check usage against your free tier (5GB/25GB) to avoid unexpected overage charges
5. **Contact Support**: If you need assistance managing storage
### Backup Failures
**Cause**: Service health issues, resource exhaustion, or platform problems.
**Solutions**:
1. **Check Service Logs**: Look for error messages around the scheduled backup time
2. **Verify Service Health**: Ensure the service is running properly with adequate resources
3. **Check Platform Status**: Visit status.zerops.io for any ongoing incidents
4. **Contact Support**: If issues persist, reach out with service name, failure time, and relevant logs

----------------------------------------

# Features > Build Cache

> Zerops implements a sophisticated two-layer caching strategy that optimizes build times while maintaining complete control over the build environment. This documentation explores the architecture, configuration patterns, and practical implementation of the build cache system.
## Architecture Overview
The build cache operates through two distinct layers:
1. **Base Layer**: Comprises the OS, installed dependencies, and prepare commands
2. **Build Layer**: Contains the state after executing build commands
The layers work together to create an efficient and predictable build environment, though they are currently coupled in their cache invalidation behavior (invalidating one layer affects the other).
### Cache Implementation
The caching mechanism is implemented through an efficient file movement strategy. This approach ensures near-instantaneous cache operations through simple directory relocation within the container, implementing the following characteristics:
- Files are moved between `/build/source` and `/build/cache` using container-level rename operations
- No packaging, compression, or network transfer is involved
- Cache preservation is achieved through simple directory relocation within the container
- Files maintain their original state and permissions throughout the process
:::note
See detailed [build process lifecycle](#build-process-lifecycle).
:::
## Configuration Guide
### Essential zerops.yaml Fields
The following fields in `zerops.yaml` affect build cache behavior:
**Direct Cache Configuration**:
- `build.cache`: Explicitly defines what should be cached through paths or patterns
**Cache Invalidation Triggers**:
These parameters trigger cache invalidation when modified:
- `build.os`: Base operating system selection
- `build.base`: Pre-installed software stacks and runtimes
- `build.prepareCommands`: System preparation and dependency installation
- `build.cache`: Changes to cache configuration
**Build Artifact Generation**:
- `build.buildCommands`: Generates the build artifact that will be deployed.
## Cache Configuration Patterns
### Pattern 1: System-Wide Cache Control
```yaml
build:
  cache: true   # Cache everything
  # OR
  cache: false  # Intended to disable all caching
```
The boolean values provide system-wide cache control:
`cache: true`:
- Preserves the entire build container state
- Maintains system-level package installations
- Ideal for globally installed packages (Python/PHP packages, Go modules)
`cache: false`:
- Intended to disable all caching
- Currently, due to layer coupling, only files within `/build/source` are not cached
- Everything outside `/build/source` remains cached (see [Common Pitfalls: Layer Coupling](#current-pitfalls))
### Pattern 2: Path-Specific Caching
```yaml
# Single path
build:
  cache: node_modules
# Multiple paths
build:
  cache:
    - node_modules
    - package-lock.json
    - .build
```
Execution flow:
1. Source code extraction to `/build/source`
2. Build command execution
3. Specified path preservation in `/build/cache`
4. Cached content restoration (no-clobber mode - source files take precedence)
:::tip
Ideal for non-versioned dependencies in your working directory (e.g., `node_modules`, `vendor`, `.venv`).
:::
## Path Pattern Reference
Zerops supports [Go's filepath.Match](https://pkg.go.dev/path/filepath#Match) syntax. Consider this example structure:
```
├── node_modules/
├── package.json
├── package-lock.json
└── subdir/
    ├── file1.txt
    ├── file2.txt
    └── file3.md
```
Pattern examples and matches:
```yaml
build:
  cache:
    - "subdir/*.txt"      # Matches: subdir/file1.txt, subdir/file2.txt
    - "package*"          # Matches: package.json, package-lock.json
    - "node_modules"      # Matches: entire node_modules directory recursively
```
:::note
All patterns resolve relative to `/build/source`. Path variations like `./node_modules`, `node_modules`, and `node_modules/` are treated identically.
:::
## Build Process Lifecycle
1. **Initialization Phase**
   - Build container startup
   - Builder process launch
   - Source code loading into `/build/source`
2. **Cache Restoration Phase**
   - Cached file movement to `/build/source` (no-clobber mode)
   - Source file precedence handling
   - Conflict logging (no build interruption)
   - Cache directory cleanup
3. **Build Execution Phase**
   - Build command processing
   - Artifact packaging (`build.deployFiles`)
4. **Cache Preservation Phase**
   - Specific cache files movement outside `/build/source`
   - `/build/source` directory cleanup
   - Container termination
## Cache Invalidation Reference
The build cache invalidates under these conditions:
1. **Manual Triggers**
   - API call: `DELETE /service-stack/{id}/build-cache`
   - GUI: Manual cache clear action
2. **Version Management**
   - Backup app version activation via `PUT /app-version/{id}/deploy`
3. **Configuration Changes**
   Any modifications to:
   ```yaml
   build.os
   build.base
   build.prepareCommands
   build.cache
   ```
### Current Pitfalls
The current implementation has some important characteristics:
1. **Layer Coupling**
   ```yaml
   build:
     base: go@1
     prepareCommands:
       - sudo apk update
       - sudo apk add sqlite
     buildCommands:
       - go build -o app main.go
     cache: false
   ```
   Even with `cache: false`, Go modules outside `/build/source` remain cached.
2. **Cascade Invalidation**
   ```yaml
   build:
     base: node@22
     prepareCommands:
       - sudo apk update
       - sudo apk add sqlite vim  # Adding 'vim' invalidates everything
     buildCommands:
       - npm install
       - npm build
     cache:
       - node_modules
   ```
   Modifying `prepareCommands` invalidates both layers, including cached `node_modules`.
## Real-World Implementation Examples
### Node.js Project with TypeScript
```yaml
build:
  base: node@22
  buildCommands:
    - npm ci
    - npm run build
  cache:
    - node_modules
    - .next
    - .turbo
    - package-lock.json
```
### Go Project with Multiple Dependencies
```yaml
build:
  base: go@1
  prepareCommands:
    - sudo apk add build-base
  buildCommands:
    - go mod download
    - go build -o bin/app cmd/main.go
  cache: true  # Caches entire Go modules directory
```
### PHP/Laravel Project
```yaml
build:
  base: php@8.3
  buildCommands:
    - composer install --no-dev
    - php artisan optimize
  cache:
    - vendor
    - composer.lock
```
## Debugging and Monitoring
* **Build Logs**
   - Cache operations are detailed in build logs
   - File conflicts during restoration are logged
   - Cache preservation status is visible
## Implementation Best Practices
### Cache Strategy Optimization
1. **Layer Management**
   - Maintain stable `prepareCommands` to prevent cache invalidation
   - Group related prepare commands logically
2. **Performance Optimization**:
   - Cache package manager lock files alongside dependency directories
   - Use system-wide caching (`cache: true`) for languages with global package managers
3. **Performance Tuning**
   - Leverage system-wide caching for complex builds
   - Monitor build logs for cache operations and potential conflicts
   - Use explicit patterns for precise control
   - Don't over-optimize – the system handles large caches efficiently
## Future Development
Planned system enhancements include:
- Layer independence implementation
- Granular cache control mechanisms
- Enhanced layer management capabilities
- Improved cache invalidation patterns

----------------------------------------

# Features > Cdn

Zerops CDN is a global content delivery network that brings your static content closer to your users, resulting in faster load times and improved user experience. Built on Nginx and Cloudflare geo-steering technology, our CDN automatically routes users to the nearest server location based on their DNS request.
## Key Benefits
- **Global Reach**: Serve content from strategic locations across the world
- **Reduced Latency**: Content is delivered from the server closest to your users
- **Simple Integration**: No complex configuration required
## Global CDN Infrastructure
Zerops CDN operates across **6 strategic regions** to ensure your content is always delivered from a location close to your users:
  
      Region
      Location
      Coverage Area
    
      EU
      CZ
      Prague, Czech Republic
      Primary European coverage + failover for all regions
    
      DE
      Falkenstein, Germany
    
      UK
      London, United Kingdom
      UK and surrounding areas
    
      AU
      Sydney, Australia
      Australia and Oceania
    
      SG
      Singapore, Singapore
      Southeast Asia
    
      CA
      Beauharnois, Canada
      North America
    
### Geo-Steering Technology
Zerops CDN's geo-steering technology automatically routes users to the server location closest to them. Here's how it works:
* **Automatic routing**: Users are directed to the optimal CDN node based on their geographic location
* **Quick failover**: The DNS TTL is set to just 30 seconds, allowing fast recovery if a node fails
* **Redundancy**: If any node becomes unavailable, Cloudflare automatically redirects traffic to the next closest node
* **Reliable backup**: The EU region serves as the ultimate fallback - if all other nodes go down, EU will always be served in DNS
## CDN Modes and Implementation
Zerops CDN currently supports two distinct usage modes (with a third mode coming soon), each designed for specific content delivery needs.
### Object Storage Mode
Perfect for efficiently delivering media files, documents, and other static assets stored in Zerops [Object Storage](/object-storage/overview) to users across different geographical regions.
**Setup process:**
1. Create an Object Storage service or select an existing one
2. Enable the CDN option for this service
3. Set appropriate public read access policies for objects you want to serve via CDN
**Accessing content:**
```txt
https://storage.cdn.zerops.app/your-bucket/path/to/file
```
:::tip
Access the storage CDN URL via the `storageCdnUrl` **project** environment variable `${storageCdnUrl}/your-bucket/path/to/file`.
:::
### Static Mode
Ideal for caching and delivering static website assets like HTML, CSS, JavaScript, and images served from your custom domains.
**Setup process:**
1. Configure domain access for your service through the L7 HTTP Balancer section
2. Access domain settings via the **three dots menu** or **gear icon** next to your domain entry
3. In the "Project Domain Access Modification" dialog, enable the **"Enable CDN for static files"** toggle
4. Optionally enable "Automatically install SSL Certificates" if not already configured
**Accessing content:**
```txt
https://static.cdn.zerops.app/your-domain.com/path/to/file
```
:::tip
Access the static CDN URL via the `staticCdnUrl` **project** environment variable `${staticCdnUrl}/your-domain.com/path/to/file`.
:::
:::warning Wildcard Domains Not Supported
Static CDN cannot be activated for wildcard domains (e.g., *.example.com). You must use specific domain names.
:::
### API Mode *(Coming Soon)*
Designed for caching API responses to reduce load on your backend services and deliver faster responses to clients.
**Environment variable:** Once available, you'll be able to access the API CDN URL via the `apiCdnUrl` **project** environment variable.
:::warning
API Mode is currently under development and will be available in a future release.
:::
### HTML Implementation Examples
Here's how to integrate CDN URLs in your HTML code:
```html
```
### Testing Specific CDN Nodes
For testing or debugging purposes, you can bypass the automatic geo-steering and access a specific CDN node directly:
```
https://{region}-{mode}.cdn.zerops.app/path/to/content
```
Available region prefixes: `cz`, `de`, `au`, `sg`, `uk`, and `ca`
**Examples:**
- Test Australia node: `https://au-storage.cdn.zerops.app/my-bucket/test.jpg`
- Test UK node: `https://uk-static.cdn.zerops.app/my-domain.com/index.html`
## Managing CDN Content
### Cache Lifecycle
Content served through Zerops CDN follows this lifecycle:
1. **First Request**: When a user requests content not yet in the CDN cache, the request goes to the origin server (your Zerops service), and the response is cached at the CDN node
2. **Subsequent Requests**: Further requests for the same content are served directly from the CDN cache, reducing latency and origin server load
3. **Cache Expiration**: By default, content remains cached for 30 days unless explicitly purged
4. **Automatic Management**: When CDN storage reaches capacity, the least recently used content is automatically removed
:::note Important Cache Behavior
Zerops CDN implements a fixed 30-day TTL policy. Currently, HTTP caching headers such as `Cache-Control`, `Expires`, `Pragma`, etc. do not influence CDN caching behavior. To refresh content sooner than the 30-day period, use the [purge API](#api-reference).
Your `Cache-Control` headers will still affect browser caching behavior.
:::
### When to Purge Cache
You should consider purging cached content when:
- **Content Updates**: You've updated content but kept the same URL (e.g., updated images, CSS files)
- **Deployment Rollouts**: You've deployed a new version of your application
- **Emergency Removal**: You need to immediately remove content that was accidentally made public
- **Testing Changes**: You want to ensure users see the latest version during testing
### Purging Cached Content
Zerops provides multiple ways to manage and purge cached content before its normal expiration:
- **Command Line**: Use the `zsc cdn purge` [command](/references/zsc#cdn) available in all Zerops containers:
  ```sh
  # Purge all content for a domain
  zsc cdn purge example.com
  # Purge all content (wildcard)
  zsc cdn purge example.com "/*"
  # Purge specific file
  zsc cdn purge example.com "/path/to/my-file$"
  ```
  :::important
    - This command must be executed in any container within the project that has the CDN-enabled domain active
    - Currently only works for [Static Mode](#static-mode) CDN
  :::
- **API Endpoints**: For programmatic control, use the [API endpoints](#api-reference). Here are ready-to-use curl examples for quickly purging content in your scripts:
  ```sh
  # Static mode: Purge all content for a domain
  curl --location --request PUT "https://api.app-prg1.zerops.io/api/rest/public/project/$PROJECT_ID/purge-cdn/static/$DOMAIN/*" \
  --header "Authorization: Bearer $USER_OR_ACCESS_TOKEN"
  ```
  ```sh
  # Storage mode: Purge all content for object storage
  curl --location --request PUT "https://api.app-prg1.zerops.io/api/rest/public/service-stack/$OBJECT_STORAGE_SERVICE_ID/purge-cdn/*" \
  --header "Authorization: Bearer $USER_OR_ACCESS_TOKEN"
  ```
#### Purge Pattern Examples
  
      Pattern
      Description
      Example
    
      `/*`
      Purges all content
      Useful after major updates
    
      `/images/*`
      Purges all content in a directory
      Clear all cached images
    
      `/css/main.css$`
      Purges a specific file
      Update a single CSS file
    
      `/2023*`
      Purges content starting with pattern
      Clear content with date prefix
    
:::warning Pattern Rules
- Wildcards (`*`) must be at the end of the pattern
- Specific files must include `$` at the end
- Nested wildcards (e.g., `/dir/*.jpg`) are not supported
:::
## API Reference
Zerops provides a comprehensive set of API endpoints to manage your CDN configuration and content. For complete information about base URLs, authorization, and general API usage, please refer to our [API specification](/references/api).
The endpoint links below will take you to the Swagger documentation with detailed request/response schemas and examples:
### CDN Management API
- **[Enable CDN for Storage ↗](https://api.app-prg1.zerops.io/api/rest/public/swagger/#/PublicServiceStack/EnableStorageCdn)** `PUT /api/rest/public/service-stack/{id}/cdn`
- **[Disable CDN for Storage ↗](https://api.app-prg1.zerops.io/api/rest/public/swagger/#/PublicServiceStack/DisableStorageCdn)** `DELETE /api/rest/public/service-stack/{id}/cdn`
- **[Create Object Storage with CDN ↗](https://api.app-prg1.zerops.io/api/rest/public/swagger/#/PublicServiceStackObjectStorage/CreateObjectStorageV1)** `POST /api/rest/public/service-stack/object_storage_v1`
- **[Create Domain Routing with CDN ↗](https://api.app-prg1.zerops.io/api/rest/public/swagger/#/PublicPublicHttpRouting/CreatePublicHttpRouting)** `POST /api/public/public-http-routing`
- **[Update Domain Routing with CDN ↗](https://api.app-prg1.zerops.io/api/rest/public/swagger/#/PublicPublicHttpRouting/UpdatePublicHttpRouting)** `PUT /api/public/public-http-routing/{id}`
### Cache Purge API
- **[Purge Storage Mode Cache ↗](https://api.app-prg1.zerops.io/api/rest/public/swagger/#/PublicServiceStack/PurgeStorageCdn)** `PUT /api/rest/public/service-stack/{id}/purge-cdn/{path}`
- **[Purge Static Mode Cache ↗](https://api.app-prg1.zerops.io/api/rest/public/swagger/#/PublicProject/PurgeStaticCdn)** `PUT /api/rest/public/project/{id}/purge-cdn/static/{domain}/{path}`
- **Purge Api Mode Cache *(Coming soon)*** 
## Troubleshooting
Having issues with your CDN? Here are solutions to the most common problems:
#### Content Not Updated After Changes
* **Issue:** You've updated content, but users still see the old version.
* **Possible Cause:** The CDN cache is continuing to serve the previously cached version.
* **Solution:**
    - Use the [purge API](#api-reference) with the specific content path
    - For immediate changes, use versioned file names (e.g., `style.v2.css` instead of just `style.css`)
#### Content Not Being Cached
* **Issue:** Your content isn't being cached by the CDN.
* **Possible Cause:** Missing public read permissions on objects.
* **Solution:**
    - For object storage: Check bucket and object access policies
    - Verify the object is accessible directly before attempting CDN access
:::note
Remember that only publicly accessible objects will be cached by the CDN. Private objects will always be fetched directly from the origin.
:::
#### Environment Variables Not Available
* **Issue:** You can't access the new CDN-related project level environment variables in your containers.
* **Possible Cause:** When new environment variables are created, existing services need to be restarted to access them. Services created before the CDN feature release require special handling.
* **Solution:**
    - For services created after CDN release: Restart the service to apply the new environment variables
    - For services created before CDN release: Add and then remove a dummy environment variable in the project settings adn restart the service
#### Unexpected 404 Errors
* **Issue:** Users receive 404 errors when accessing content via CDN.
* **Possible Cause:** Incorrect CDN URL formatting or missing content at origin.
* **Solution:**
    - Double-check your [URL structure](#) (pay attention to domain names and paths)
    - Verify content exists at the origin before attempting CDN access
    - Test accessing the content directly from origin first
**Correct URL patterns:**
- Object Storage: `https://storage.cdn.zerops.app/your-bucket/path/to/file`
- Static Mode: `https://static.cdn.zerops.app/your-domain.com/path/to/file`
---
*Need help implementing CDN in your project? Join our [Discord community](https://discord.gg/zeropsio) where our team and other Zerops users can assist you!*

----------------------------------------

# Features > Container Vs Vm

Ever wondered why container technologies like Docker took over the development world so quickly? Let's break down the real differences between traditional VMs and containers - and why you might want to use one over the other.
## Key Distinctions
**Containers** are like lightweight packages that contain just your app and what it needs to run, sharing resources with your main system.
**Virtual Machines** are like having a whole computer inside your computer. Complete with its own operating system, memory, and everything else.
### Why Developers Love Containers
#### They're Fast
- Start up in seconds (not minutes)
- Take up way less space
- You can run many more of them on the same hardware
#### They're Consistent
- Works on your machine? Will work on everyone's machine
- No more "but it works locally" problems
- Same environment from development to production
#### They're Simple
- Easy to share with your team
- Quick to update and modify
- Less configuration headaches
### When VMs Still Make Sense
Sometimes you actually want a full computer-within-a-computer:
- You need to run a completely different operating system
- You're dealing with legacy applications that need specific system configurations
- You require maximum isolation for security reasons
### Real-World Comparison
Think of it like this:
- **Containers** are like apartments in a well-managed building (shared infrastructure, efficient, but with some limitations)
- **VMs** are like having your own house (complete control, but with more overhead)
## Containers and VMs in Zerops
### Why Zerops Uses Both
At Zerops, we use **containers** as our primary runtime environment - they're fast, efficient, and perfect for most modern development workflows. We've optimized our container infrastructure to handle nearly every type of application you might need to run.
However, we also provide **VMs** when you need them, particularly for Docker-based workloads where the additional isolation is essential. Docker containers are a special case - in Zerops, they actually need to run inside VMs for proper security and isolation. While it's technically possible to run Docker in containers using privileged mode, this creates security vulnerabilities.
### When to Use What
  
    Go with Containers when:
  
        Building modern web applications
      
        Working with microservices
      
        Need quick deployment and vertical scaling
      
        Want efficient resource usage
      
    Consider VMs when:
  
        Running legacy applications
      
        Need complete OS isolation
      
        Require specific hardware access
      
        Need to run Docker containers
      
### Resource Allocation
Both containers and VMs in Zerops can have guaranteed resources:
- Specific CPU cores
- Dedicated memory
- Controlled disk space
The difference isn't in resource guarantee capabilities, but rather in how these resources are managed and isolated.
## The Bottom Line
For most modern development work, containers are the way to go. They're faster, more efficient, and easier to work with. VMs still have their place, but unless you have a specific reason to use them, containers will usually make your life easier.
*Remember: The goal is to spend less time managing infrastructure and more time building great applications. Choose the tool that lets you do that most effectively.*
:::tip Pro Tip
Not sure which to choose? Start with containers. You can always switch to VMs if you discover you need them for specific use cases.
:::

----------------------------------------

# Features > Debug Mode

This document describes the debug mode configuration capabilities for service stacks in Zerops, allowing developers to pause execution at specific points during build and runtime processes for debugging purposes.
## Overview
Debug mode introduces control over two distinct phases of deployment:
- **Build phase** - When the `buildCommands` are executed
- **Runtime prepare phase** - When the `prepareCommands` are executed
For each phase, you can choose when to pause the execution:
- **Disable** - No pausing, execution proceeds normally
- **Before first command** - Execution stops before running any commands
- **After last command** - Execution stops after all commands complete
- **On command fail** - Execution stops when a command fails
Each phase can be configured with its own debug settings without affecting the other phase.
:::warning Important
The entire build process, including any time spent in debug mode, has a maximum duration of 60 minutes. After this time limit is reached, the build process is automatically cancelled.
:::
## Configuration
The debug mode configuration can be found in your service detail under the **Pipelines & CI/CD settings**.
  
## Debug Control
When execution is paused in debug mode, you have several commands available to control the debugging process. Each command serves a specific purpose and affects the deployment process differently.
### Debug Pause Points
There are three key points where execution can pause during deployment:
- ➠ **Disable** - Do not pause
- ↪ **Before First Command** - Paused before any commands run
- ✖ **On Command Failure** - Paused when a command fails
- ✔ **After Last Command** - Paused after all commands complete
### Available Commands
#### Continuing Execution
To proceed with the normal deployment process, use:
```bash
zsc debug continue
```
  
      Pause Point
      Behavior
    
      ↪ Before First Command
      Begins running commands for the current phase until next possible pause point
    
      ✖ On Command Failure
      Skips the failed command and continues deployment
    
      ✔ After Last Command
      Moves to the next phase (from build to runtime prepare) or completes deployment
    
#### Marking Success
To force a successful deployment status, use:
```bash
zsc debug success
```
  
      Pause Point
      Behavior
    
      ↪ Before First Command
      Ends current phase without running any commands
    
      ✖ On Command Failure
      Ignores the failure and ends current phase with success
    
      ✔ After Last Command
      Concludes current phase with a successful status
    
:::note
Requires valid `deployFiles` to work properly (fails otherwise).
:::
#### Forcing Failure
To terminate the deployment with a failure status, use:
```bash
zsc debug fail
```
  
      Pause Point
      Behavior
    
      ↪ Before First Command
      Marks current phase as failed without running commands
    
      ✖ On Command Failure
      Ends deployment with original error
    
      ✔ After Last Command
      Overwrites successful execution with failed status and ends deployment
    
Each phase can be configured independently to pause at any of the points described above, giving you precise control over your debugging workflow. The 60-minute timeout ensures deployments don't remain blocked indefinitely.
## Usage Examples
### Example 1: Debugging Build Failures
  
      Build phase
      ✖ On Command Failure
    
      Prepare runtime phase
      ➠ Disable
    
This configuration allows you to:
1. Inspect the container state after a failure
2. Make necessary adjustments
3. Use `zsc debug continue` to resume or `zsc debug fail` to abort
### Example 2: Validating Runtime Setup
  
      Build phase
      ➠ Disable
    
      Prepare runtime phase
      ✔ After Last Command
    
## Best Practices
#### Targeted Debugging
- Enable debug mode only for the specific phase you need to investigate
- This minimizes disruption to the deployment process
- Helps maintain clear debugging sessions
#### Clean Up
- Always remember to disable debug mode after completing your debugging session
- Set both phases to **Disable**
- Prevents unexpected pauses in future deployments
#### Production Consideration
- Be cautious when using debug mode in production environments
- Paused executions can block deployments
- Consider using separate development services for extended debugging sessions
#### Timeout Awareness
- Be mindful of the 60-minute maximum debug pause time (plan debugging sessions accordingly)
## Technical Considerations
- Debug mode settings persist until explicitly changed
- Build phase and runtime prepare phase operate independently
- Debug commands are only available when execution is paused
- Success signals require valid `deployFiles` to proceed

----------------------------------------

# Features > Env Variables

Zerops manages environment variables at two scopes: service level and project level. These variables are handled automatically without requiring `.env` files.
**On this page:** [Service Variables](#service-variables) · [Project Variables](#project-variables) · [Referencing Variables](#referencing-variables) · [Variable Isolation](#environment-variable-isolation) · [Restrictions](#variable-restrictions) · [Examples](#environment-variable-examples)
## Service Variables
Variables that are specific to individual [services](/features/infrastructure#services).
### User-Defined Variables
You can define service-level variables in two ways:
#### 1. Build & Runtime Variables
These variables are defined with `envVariables` attribute in the [build](/zerops-yaml/specification#envvariables-) or [run](/zerops-yaml/specification#envvariables--1) section of your `zerops.yaml` file and are accessible within their respective containers.
```yaml title="zerops.yaml"
...
  build:
    envVariables:
      DB_NAME: db
      DB_HOST: 127.0.0.1
      DB_USER: db
      DB_PASS: password
    ...
  run:
    envVariables:
      DB_NAME: db
      DB_HOST: 127.0.0.1
      DB_USER: db
      DB_PASS: password
```
See how to [reference variables](#referencing-variables) between services and between build and runtime environments. All variables must follow the [naming restrictions](#variable-restrictions).
:::note
Your application must be redeployed when updating environmental variables in `zerops.yaml`.
:::
#### 2. Secret Variables
For storing sensitive data you don't want in your source repository. They can be updated without redeployment (though services need to be reloaded).
Secret variables can be managed through:
##### GUI Interface
Navigate to service details and find **Environment variables** in the menu. You can:
- Add individual variables using the "Add secret variable" button
- Edit individual variables through the menu that appears on hover
- Use the bulk editor for managing multiple variables in .env format
    
##### Import Configuration
Create secret variables for a service with `envSecrets` attribute. See the complete [import.yaml structure](/references/import).
```yaml title="import.yaml"
services:
  ...
  envSecrets:
    S3_ACCESS_KEY_ID: 'your-secret-s3-key'
    S3_ACCESS_SECRET: 'your-s3-access-secret'
```
### System-Generated Variables
Zerops automatically generates variables based on service type.
These variables cannot be deleted and are always listed at the bottom of the environment variables page. Some are read-only (like `hostname`), while others can be edited (like `PATH`).
These variables can also be [referenced](#referencing-variables).
## Project Variables
Variables that apply across all services within a [project](/features/infrastructure#projects). These provide a way to share common configuration across services.
They work similarly to service secret variables but at project scope - they're managed through the GUI and can be updated without redeployment (though services need to be reloaded).
:::important
Project variables are **automatically inherited** by all services in the project — both in build and runtime environments. You do not need to [reference](#referencing-variables) them in your `zerops.yaml`.
:::
### User-Defined Variables
You can set project-wide variables through:
#### GUI Interface
Access **Project environment variables** in your project detail to:
- Add individual variables one by one
- Edit individual variables
- Use the bulk editor with .env format
#### Import Configuration
Create project variables with `envVariables` attribute. See the complete [import.yaml structure](/references/import).
```yaml title="import.yaml"
project:
  ...
  envVariables:
    LOG_LEVEL: info
    API_VERSION: v1
```
These variables will be automatically available in all services without any additional configuration.
### System-Generated Variables
Zerops automatically generates project-level variables that are also automatically available in all services.
### Overriding Project Variables
If you need a different value for a specific service, you can override a project variable by defining a service-level variable with the same key. See [Variable Precedence](#variable-precedence) for details on how conflicts are resolved.
```yaml title="zerops.yaml"
run:
  envVariables:
    LOG_LEVEL: debug  # Overrides the project-level LOG_LEVEL for this service only
```
## Environment Variable Isolation
A security feature that controls the **visibility** of environment variables across services within a project. This affects how [referencing variables](#referencing-variables) across services works.
By default, Zerops isolates environment variables between services to enhance security and prevent unintended access to sensitive information. This isolation can be configured at both project and service levels.
### Isolation Modes
Zerops supports two isolation modes:
  
      Mode
      Description
    
      service
      Default mode. Variables are isolated to their respective services. Services can only access their own variables and must explicitly reference variables from other services.
    
      none
      Legacy mode. All variables from all services are automatically shared and accessible via prefixing.
    
### Configuring Isolation
#### Project-Level Isolation
Zerops automatically creates the `envIsolation` project variable with the default value `service`. You only need to modify this if you want to disable isolation:
```yaml title="import.yaml"
project:
  envIsolation: none  # Disables isolation, sharing all variables
```
This can also be set through the Project Environment Variables section in the GUI.
#### Service-Level Override
Individual services can override the project-level isolation setting:
```yaml title="import.yaml"
services:
  - hostname: db
    envIsolation: none  # This service's variables will be visible to all services
```
:::tip
You might set a database service to `envIsolation: none` to expose its connection details to other services, without having to manually reference them, while keeping the rest of your services isolated.
:::
:::note
In import YAML, `envIsolation` can also be nested under `envVariables`/`envSecrets`. (If both are present, the nested version takes precedence).
:::
### Accessing Variables Across Services
#### With Isolation Enabled (`service` mode)
When isolation is enabled, you must explicitly create reference variables to access variables from other services:
```yaml title="zerops.yaml"
# In the 'app' service:
run:
  envVariables:
    # Create a local reference to the 'password' variable from the 'db' service
    DB_PASSWORD: ${db_password}
```
This approach gives you complete control over which variables are shared between services.
#### With Isolation Disabled (`none` mode)
When isolation is disabled, variables are automatically available across all services with the service name prefix:
```yaml
# In any service, you can directly access:
${db_password}  # Accesses the 'password' variable from the 'db' service
```
### Best Practices for Variable Isolation
1. **Use Default Isolation**: Keep the default `service` isolation for enhanced security.
2. **Explicit References**: Create explicit references only for variables that need to be shared.
3. **Naming Conventions**: Use clear naming patterns for reference variables (e.g. `DB_PASSWORD` for a reference to `db_password`).
4. **Service-Level Exceptions**: Use service-level isolation overrides sparingly and only for services that need to expose their variables widely.
## Referencing Variables
You can reference other variables using the `${variable_name}` syntax. This is used to reference **service-level variables**, not project variables (which are already automatically inherited).
### Within Same Service
```yaml
envVariables:
  id: 42069
  hostname: app
  name: ${id}-${hostname}  # Results in: 42069-app
```
### Across Services
How this works depends on your [environment variable isolation](#environment-variable-isolation) setting:
**With Isolation Enabled** (`service` mode - default)
Create an explicit reference in the destination service:
```yaml
# In the 'app' service
envVariables:
  # Creating a reference to the 'connectionString' from 'dbtest' service
  dbConnection: ${dbtest_connectionString}
```
**With Isolation Disabled** (`none` mode)
Variables from other services are automatically injected into the container and available using the service prefix format `servicename_variablename`:
```yaml
# In any container, you can directly access variables from other services:
# ${dbtest_connectionString}
```
### Between Build and Runtime Environments
Build and runtime are two distinct environments in Zerops. Each environment can have its own set of variables, and you can use the same variable names in both environments since they are separate. Due to this separation, variables defined in one are not automatically accessible in the other.
To share variables between environments, you need to use specific prefixes:
- Use `RUNTIME_` prefix to access runtime variables during build
- Use `BUILD_` prefix to access build variables during runtime
```yaml title="zerops.yaml"
build:
  envVariables:
    API_KEY: ${RUNTIME_API_KEY}  # Using runtime variable during build
run:
  envVariables:
    API_KEY: "12345-abcde"       # Referenced in build with RUNTIME_ prefix
```
### Project Variables — No Reference Needed
[Project variables](#project-variables) are **automatically available** in all services. Do not use the `${...}` syntax to reference them:
```yaml
# ❌ Wrong - this shadows the project variable
envVariables:
  PROJECT_NAME: ${PROJECT_NAME}
# ✅ Correct - just use the project variable directly in your app
# It's already available without any configuration
```
If a project variable is named `LOG_LEVEL`, your application can read it directly — you don't need to add anything to your `zerops.yaml`.
## Variable Restrictions
All environment variables must follow these restrictions:
### Key
- Alphanumeric characters only (use `_` to separate words)
- Must be unique within their scope
- Case-sensitive
### Value
- ASCII characters only
- No EOL characters
## Variable Management
### Variable Precedence
When the same environment variable key exists in multiple places, Zerops follows these precedence rules:
1. Service-level variables take precedence over project variables
2. Within service-level:
   - Build/runtime variables override secret variables
   - Build and runtime containers are separate environments
## Environment Variable Examples
### Variable Isolation Example
Consider a project with three services: `api`, `db`, and `cache`:
```yaml title="Project structure"
project:
  name: my-project
services:
  - hostname: api
    envSecrets:
      # Creating explicit references to needed variables
      DB_CONNECTION: ${db_user}:${db_password}@${db_hostname}:${db_port}
      CACHE_URL: ${cache_hostname}:${cache_port}
  - hostname: db
    envSecrets:
      password: secureDbPassword
      user: dbuser
      port: 5432
  - hostname: cache
    envSecrets:
      password: cacheServerPass
      port: 6379
```
With this setup:
- The `api` service can only access the specific `db` and `cache` variables it explicitly references
- The `db` service cannot see any variables from `api` or `cache`
- The `cache` service cannot see any variables from `api` or `db`
If we changed the project's `envIsolation` to `none`, all services would be able to see all variables from all other services (prefixed with the service name).
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Features > Infrastructure

Zerops organizes your infrastructure into three hierarchical levels: **projects**, **services**, and **containers**. This structure provides secure networking, resource isolation, and scalable application deployment.
## Projects
A project is the top-level entity in Zerops, functioning as a private network where services can communicate internally and share environment variables. Each project provides essential infrastructure including load balancing, routing, and container orchestration.
### Key Project Features
- **Private Networking**: All services within a project share a secure network
- **Environment Variables**: Services can access shared environment variables
- **IPv6/IPv4 Addressing**: Each project receives an IPv6 address, with optional IPv4 addressing
- **Integrated Security**: Built-in firewall and SSL certificate management
:::tip Project Organization
Consider your project strategy carefully. Create separate projects for different environments (dev/staging/prod) or consolidate related applications in a single project to optimize resources and simplify networking.
:::
### Project Core Options
When you create a project, it requires a functioning **core** that includes logger and statistics services, HTTP routing with automatic SSL certificate management, and IP routing with integrated firewall.
Zerops offers two core types to match different needs and budgets:
#### Lightweight Core
Single-container solution perfect for development projects and smaller production workloads. Includes project controller, L3 balancer, firewall, logger, statistics, and HTTP handling in one efficient package.
:::tip Ideal For
Development environments, low-traffic applications, personal projects, budget-conscious teams.
:::
#### Serious Core
Enterprise-grade infrastructure with separated core services across multiple containers for true redundancy and high availability.
:::tip Ideal For
Production applications, high-traffic websites, mission-critical business applications, teams requiring maximum uptime.
:::
#### Features Comparison
  
      Lightweight Core
      Serious Core
    
      Infrastructure
      Single container (limited redundancy)
      Multi-container (highly available)
    
      SSL Termination
      
      Automatic Certificate Generation
      
      Proxy / Load Balancer
      
      IPv6 Address
      
      Build Time
      15 hours
      150 hours
    
      Backup Space
      5 GB
      25 GB
    
      Egress
      100 GB
      3 TB
    
      Failover Protection
      Limited
      Comprehensive
    
For detailed pricing information on both core types, visit our [pricing page](/company/pricing#project-core-plans).
#### Project Core Upgrade
You can upgrade from Lightweight Core to Serious Core for enhanced reliability and increased resources.
:::warning Important
The core upgrade is a **partially destructive process** that will temporarily disrupt your project's operations. Plan upgrades during maintenance windows.
:::
**What happens during upgrade:**
- All project logs and statistics will be lost (forwarded logs/statistics are not affected)
- Services will be network-unavailable during the process (avg. 35 seconds but can take longer)
- $10 project core fee will be charged upon upgrade
- Free project resources will reset to Serious Core limits
- Project IP addresses remain unchanged
:::important
If you encounter issues, **contact support immediately** and try running the process again.
:::
## Services
Services encapsulate your containers and provide specific functionality within a project. A project can contain unlimited services, each with its own purpose.
**Service types include:**
- Runtimes, Linux Containers & Docker
- Databases, Search Engines & Messages Brokers
- Storages
- *System services (needed for fully functioning project core)*
**Management options:**
- **Fully managed**: Zerops handles scaling, routing, and repairs automatically (Databases and Storages)
- **Partially managed**: You maintain control over certain management aspects (Runtimes)
Services within a project communicate via internal hostnames and can share environment variables for seamless integration.
## Containers
Containers are the most granular level of the Zerops architecture. Each service consists of one or more containers that work together to deliver functionality.
**Container deployment:**
- Single containers for simple applications
- Multiple containers for High Availability (HA) mode (e.g. fully managed MariaDB service in HA mode uses 3 containers for the database cluster and 2 for proxies)
**Container capabilities:**
- Use predefined images or custom configurations
- Can be exposed publicly via Zerops subdomains, custom domains, or public ports
- Operate within service resource constraints with automatic scaling

----------------------------------------

# Features > Pipeline

export const languages = [
    { name: "Node.js", link: "/nodejs/how-to/build-pipeline" },
    { name: "PHP", link: "/php/how-to/build-pipeline" },
    { name: "Python", link: "/python/how-to/build-pipeline" },
    { name: "Go", link: "/go/how-to/build-pipeline" },
    { name: ".NET", link: "/dotnet/how-to/build-pipeline" },
    { name: "Rust", link: "/rust/how-to/build-pipeline" },
    { name: "Java", link: "/java/how-to/build-pipeline" },
    { name: "Elixir", link: "/elixir/how-to/build-pipeline" },
    { name: "Deno", link: "/deno/how-to/build-pipeline" },
    { name: "Bun", link: "/bun/how-to/build-pipeline" },
    { name: "Gleam", link: "/gleam/how-to/build-pipeline" },
    { name: "Nginx", link: "/nginx/how-to/build-pipeline" }
]
export const customizeBuild = [
    { name: "Node.js", link: "/nodejs/how-to/build-process#build-environment" },
    { name: "PHP", link: "/php/how-to/build-process#build-environment" },
    { name: "Python", link: "/python/how-to/build-process#build-environment" },
    { name: "Go", link: "/go/how-to/build-process#build-environment" },
    { name: ".NET", link: "/dotnet/how-to/build-process#build-environment" },
    { name: "Rust", link: "/rust/how-to/build-process#build-environment" },
    { name: "Java", link: "/java/how-to/build-process#build-environment" },
    { name: "Elixir", link: "/elixir/how-to/build-process#build-environment" },
    { name: "Deno", link: "/deno/how-to/build-process#build-environment" },
    { name: "Bun", link: "/bun/how-to/build-process#build-environment" },
    { name: "Gleam", link: "/gleam/how-to/build-process#build-environment" },
    { name: "Nginx", link: "/nginx/how-to/build-process#build-environment" }
]
export const customizeRuntime = [
    { name: "Node.js", link: "/nodejs/how-to/customize-runtime" },
    { name: "PHP", link: "/php/how-to/customize-runtime" },
    { name: "Python", link: "/python/how-to/customize-runtime" },
    { name: "Go", link: "/go/how-to/customize-runtime" },
    { name: ".NET", link: "/dotnet/how-to/customize-runtime" },
    { name: "Rust", link: "/rust/how-to/customize-runtime" },
    { name: "Java", link: "/java/how-to/customize-runtime" },
    { name: "Elixir", link: "/elixir/how-to/customize-runtime" },
    { name: "Deno", link: "/deno/how-to/customize-runtime" },
    { name: "Bun", link: "/bun/how-to/customize-runtime" },
    { name: "Gleam", link: "/gleam/how-to/customize-runtime" },
    { name: "Nginx", link: "/nginx/how-to/customize-runtime" }
]
## Configure the pipeline
Zerops provides a customizable build and runtime environment for your application. Start by adding a [zerops.yaml](/zerops-yaml/specification) file to the **root of your repository** and modify it to fit your application.
Here is a basic example for a Node.js application:
```yaml
zerops:
  - setup: api
    build:
      base: nodejs@20
      buildCommands:
        - npm i
        - npm run build
      deployFiles: ./dist
      cache: node_modules
    run:
      base: nodejs@20
      start: npm start
```
The zerops.yaml in your repository tells Zerops how to build and deploy your application. When the build & deploy pipeline triggers for the Node.js service named `api`, Zerops will:
1. Create a build environment with Node.js v.20 preinstalled
2. Run build commands: `npm i`, `npm run build`
3. Create a runtime environment with Node.js v.20 preinstalled
4. Deploy the built artifact from the `./dist` folder to runtime containers
5. Cache the `./node_modules` folder for faster subsequent builds
6. Start your application using `npm start`
Learn more about `zerops.yaml` parameters for your runtime:
## Trigger the pipeline
  
### Continuous deployment
Set up automatic builds triggered by Git events. You can establish continuous deployment in two ways:
* **New Service:** Create a new runtime service and connect it to your GitHub or GitLab repository during the service creation process.
* **Existing Services:** Go to the service detail and choose **Pipelines & CI/CD settings** from the left menu. Click **Connect with a GitHub repository** or **Connect with a GitLab repository** to link your repository.
Once connected, Zerops will automatically build and deploy your application with each push to the selected branch or when you create a new tag.
  
### On-demand deployment
Trigger builds and deployments manually when needed using either the CLI or GUI.
#### Using Zerops CLI
- **Build and deploy:** `zcli service push` - Uploads code and triggers the full pipeline
- **Deploy only:** `zcli service deploy` - Skips build, deploys pre-built artifacts
See [CLI commands documentation](/references/cli/commands#service-operations) for all parameters.
#### Using Zerops GUI
In **Pipelines & CI/CD settings** section of your service detail:
- **Re-deploy last pipeline** - With optional secret env variable updates
- **Trigger new pipeline** - From git repo or with custom configuration
#### Using import YAML
Add `buildFromGit: ` to your service configuration for one-time build during import. See [import documentation](/references/import#service-basic-configuration).
## Build phase
  
Zerops starts a temporary build container and executes these steps:
1. **Install build environment** - Sets up the runtime and tools
2. **Download source code** - From [GitHub ↗](https://www.github.com), [GitLab ↗](https://www.gitlab.com) or via [Zerops CLI](/references/cli)
3. **Customize environment** - Runs optional preparation commands
4. **Execute build commands** - Compiles and packages your application
5. **Upload artifacts** - Stores build output in internal Zerops storage
6. **Cache files** - Optionally [caches](/features/build-cache) selected files for faster future builds
Zerops automatically deletes the build container after the build finishes or fails.
### Build hardware resources
All runtime services use the same hardware resources for build containers:
  
      HW resource
      Minimum
      Maximum
    
      CPU cores
      1
      5
    
      RAM
      8 GB
      8 GB
    
      Disk
      1 GB
      100 GB
    
Build containers start with minimum resources and scale vertically up to maximum capacity as needed.
:::info
Build container resources are not charged. Build costs are covered by the standard Zerops [project fee](https://zerops.io/#pricing).
:::
### Build time limit
The entire build pipeline has a **1 hour** time limit. After 1 hour, Zerops terminates the build pipeline and deletes the build container.
### Customize the build environment
All runtime services start with a default build environment based on the [build.base](/zerops-yaml/specification#base-) attribute in `zerops.yaml`. Install additional packages or tools by adding [build.prepareCommands](/zerops-yaml/specification#preparecommands-) to your configuration.
Learn more about customizing build environments:
## Runtime prepare phase (optional)
  
When your application requires additional system packages, libraries, or tools in the runtime environment, Zerops allows you to build a custom runtime image. This optional phase occurs after the build phase and before deployment.
### When to use custom runtime images
Build custom runtime images when you need:
- System packages or libraries for runtime operations (e.g., `apk add imagemagick` for image processing)
- Library dependencies for interpreted languages or dynamically linked binaries
- System-level tools or utilities your application requires
- Customized base operating system or additional software layers
### Configuration
Configure custom runtime images in your `zerops.yml` file using these fields:
#### `run.os` + `run.base`
Specify the operating system and base packages for your custom runtime image:
```yaml
run:
  os: alpine # or ubuntu
  base: nodejs@20 # specify your runtime and version
```
#### `run.prepareCommands`
Define commands that customize your runtime image. These commands run inside a fresh base container:
```yaml
run:
  prepareCommands:
    - sudo apk add --no-cache imagemagick
    - sudo apt-get update && apt-get install -y some-package  # for Ubuntu
```
Zerops creates the custom runtime image from this container after all commands complete successfully.
#### `build.addToRunPrepare`
Copy specific files from the build phase to the runtime prepare phase. This is useful when you need source files during runtime preparation:
```yaml
build:
  addToRunPrepare:
    - package.json
    - requirements.txt
    - config/runtime-setup.sh
```
These files are packed immediately after `build.buildCommands` finish and become available during the runtime prepare phase.
### How it works
When you trigger the first deploy with defined [run.prepareCommands](/zerops-yaml/specification#preparecommands--1), Zerops:
1. **Creates prepare container** - Based on `run.os` and `run.base`
2. **Copies build files** - Files specified in [build.addToRunPrepare](/zerops-yaml/specification#addtorunprepare-) (if any)
3. **Runs prepare commands** - Executes [run.prepareCommands](/zerops-yaml/specification#preparecommands--1) in order
4. **Creates runtime image** - Builds custom runtime image from the prepared container
5. **Uses for deployment** - Deploys your application using this custom runtime image
### Custom runtime image caching
Zerops caches custom runtime images to optimize deployment times. The runtime prepare phase is skipped and cached images are reused when:
- It is not the first deployment of your service
- None of these `zerops.yaml` fields changed since the last deployment:
  - `run.os` or `run.base`
  - `run.prepareCommands`
  - `build.addToRunPrepare`
- File contents specified in `build.addToRunPrepare` remain unchanged
- The custom runtime image cache hasn't been manually invalidated
#### Manual cache invalidation
To invalidate the custom runtime image cache, go to your service detail in the Zerops GUI, choose **Pipelines & CI/CD settings** section from the left menu, and click on the button under **Pipeline #**. Then click on the **Clear runtime prepare image** button.
Learn more about building custom runtime images:
:::warning
Do not include your application code in the custom runtime image, as your built application code is deployed automatically into fresh containers.
Shared storage mounts are also not available during the runtime prepare phase.
:::
## Deploy phase
  
### Application artifacts
After the [build phase](#build-phase) completes, Zerops stores the application artifact in internal storage and deletes the build container.
For [manual deployments](#manual-deploy-using-zerops-cli) using Zerops CLI, the application artifact is also uploaded to internal storage.
Zerops uses the stored artifact to deploy identical versions of your application whenever a new container starts:
- During new application version deployments
- When applications [scale horizontally](/features/scaling-ha#horizontal-scaling-runtime-services-linux-containers-and-docker)
- When runtime containers fail and new containers start automatically
### First deploy
For initial deployments, Zerops starts one or more runtime containers based on your service [auto scaling settings](/features/scaling-ha).
Zerops executes these steps for each new container:
1. **Install runtime environment** - Sets up the runtime (or uses a custom runtime image if configured)
2. **Download application artifact** - Retrieves build output from internal storage
3. **Run initialization** - Executes optional [init commands](/zerops-yaml/specification#initcommands-)
4. **Start application** - Launches your app using the [start command](/zerops-yaml/specification#startcommands-)
5. **Check readiness** - Waits for [readiness check](/zerops-yaml/specification#readinesscheck-) to succeed (if configured)
6. **Activate container** - Container becomes active and receives incoming requests
Services with multiple containers deploy in parallel.
:::info
If your application needs initialization in each runtime container, add [init commands](/zerops-yaml/specification#initcommands-) to `zerops.yaml`.
:::
:::caution
Do not use `initCommands` for runtime environment customization. See [how to build custom runtime images](#runtime-prepare-phase-optional).
:::
### Subsequent deploys
For applications with existing running versions, Zerops starts new containers matching the count of existing containers.
Zerops executes the same steps as the first deployment for each new container. Your service briefly contains both new and old versions during this process.
Old containers are then removed from the project balancer to stop receiving new requests. The processes inside old containers terminate and Zerops gradually deletes all old containers.
### Readiness checks
If your application is not ready to handle requests immediately after starting via the [start command](/zerops-yaml/specification#startcommands-), configure a [readiness check](/zerops-yaml/specification#readinesscheck-) in your `zerops.yaml`.
When readiness checks are defined, Zerops:
1. **Starts your application**
2. **Performs readiness check**
3. **Waits and retries** - If check fails, waits 5 seconds and repeats step 2
4. **Activates container** - If check succeeds, marks container as active
Runtime containers with pending readiness checks do not receive incoming requests - only active containers handle traffic.
If readiness checks fail for 5 minutes, Zerops marks the container as failed, deletes it, creates a new container, and repeats the deployment process.
**Readiness check types:**
- `httpGet` - Succeeds when URL returns HTTP `2xx` status (5-second timeout, follows `3xx` redirects)
- `exec.command` - Succeeds when command returns status code 0 (5-second timeout)
Read the [runtime log](/nodejs/how-to/logs#runtime-log) to troubleshoot failed readiness checks.
## Manual deploy using Zerops CLI
  
Start deploy-only pipelines using the [Zerops CLI](/references/cli). The `zcli service deploy` command uploads and deploys your application in Zerops. Use this when you have your own build process. For building applications in Zerops, use [continuous](#continuous-deployment) or [on-demand](#on-demand-deployment) deployment instead.
```sh
Usage:
  zcli service deploy pathToFileOrDir [flags]
Flags:
      --archive-file-path string   If set, zCLI creates a tar.gz archive with the application code in the required path relative
                                 to the working directory. By default, no archive is created.
      --deploy-git-folder          Sets a custom path to the zerops.yaml file relative to the working directory. By default zCLI
                                 looks for zerops.yaml in the working directory.
  -h, --help                     the service deploy command.
      --project-id string         If you have access to more than one project, you must specify the project ID for which the
                                 command is to be executed.
      --service-id string         If you have access to more than one service, you must specify the service ID for which the
                                 command is to be executed.
      --version-name string       Adds a custom version name. Automatically filled if the VERSIONNAME environment variable exists.
      --working-dir string        Sets a custom working directory. Default working directory is the current directory. (default "./")
      --zerops-yaml-path string    Sets a custom path to the zerops.yaml file relative to the working directory. By default zCLI
                                 looks for zerops.yaml in the working directory.
```
`pathToFileOrDir` defines paths to directories and/or files relative to the working directory. The working directory defaults to the current directory and can be changed using the `--working-dir` flag.
Place `zerops.yaml` in the working directory.
:::info
You can modify the deploy pipeline anytime by updating the `zerops.yaml` in your working directory.
:::
## Manage builds and deployments
### Cancel running build
When you need to cancel an incorrect running build, use the Zerops GUI. Go to the service detail, open the running processes list, and click **Open pipeline detail**. Then click **Cancel build**.
  
:::caution
Build cancellation is only available before the build pipeline finishes. Once the build completes, deployment cannot be cancelled.
:::
### Application versions
Zerops keeps the 10 most recent versions of your application in internal storage.
Access the application versions list in Zerops GUI by going to service detail and choosing the **Pipelines & CI/CD settings** section from the left menu. The active version is highlighted - click the button below to show all archived versions.
  
Access pipeline details from the additional menu. Pipeline details contain:
- Pipeline configuration (`zerops.yaml`) used for the selected version
- Build log (if available)
- Prepare runtime log (if available)
You can download the build artifact for selected versions or manually delete inactive versions.
### Restore an archived version
Restore archived versions by choosing **Activate** from the additional menu. Zerops will deploy the selected version and archive the currently active version.
Environment variables restore to their state from the last moment when the selected version was active.

----------------------------------------

# Features > Scaling Ha

Zerops delivers enterprise-grade infrastructure with built-in automatic scaling and high availability. This means applications and databases dynamically adjust to traffic demands—scaling up during peak loads to maintain performance and scaling down during quiet periods to reduce costs.
Unlike traditional hosting where resources must be predicted and pre-provisioned, Zerops continuously monitors workloads and automatically allocates exactly what is needed, when it is needed. This intelligent resource management ensures optimal performance without wasted spend.
## Key Benefits
- **Cost Optimization**: Only pay for resources actually used
- **Performance Reliability**: Maintain responsiveness during traffic spikes
- **Automatic Management**: Built-in best practices with customizable settings
- **High Availability**: Redundancy options for production environments
## Understanding Zerops Scaling Architecture
Zerops uses two fundamentally different approaches for optimizing infrastructure:
#### **Resource Management (Vertical Scaling)**
- **Applies to:** Runtime services, databases, shared storage, and Linux containers (Alpine and Ubuntu)
- **What it does:** Adjusts CPU, RAM, and disk resources within individual containers
- **Management:** Automated by Zerops, but customizable by users
:::note
Docker services do not support automatic vertical scaling. Resource values can be manually changed, but this triggers a VM restart.
:::
#### **Container Architecture**
- **For Runtime Services, Linux Containers, and Docker:** Horizontal Scaling (dynamic container count)
  - Adds or removes containers/VMs based on load
  - Requires applications to be designed for HA operation
  - Container/VM creation limits can be controlled
  - Docker containers run in VMs rather than native containers
- **For Databases & Shared Storage:** High Availability Mode (fixed container count)
  - Single Container OR Multi-Container HA configuration
  - Must be chosen at service creation (cannot be changed later)
  - Managed by Zerops (no application changes needed)
### At-a-Glance Comparison
* ✓ = Available *(configurable, defaults vary according to service type)*
  
      Feature
      Runtime Services & Linux Containers
      Databases
      Shared Storage
      Docker
    
      Automatic Resource Scaling
      ✓
      ✓
      ✓
      Manual (triggers VM restart)
    
      Automatic Horizontal Scaling
      ✓
      Fixed # of containers
      Fixed # of containers
      ✓
    
      High Availability
      User-implemented
      Zerops-managed HA mode
      Zerops-managed HA mode
      User-implemented
    
## When to Configure Scaling
You can configure scaling settings at three different stages:
- **During service creation** - Configure initial scaling parameters when creating services in the Zerops GUI. Set resource limits, CPU mode, and container counts from the start.
- **During import** - Use YAML configuration files to define comprehensive scaling settings including `verticalAutoscaling` parameters and horizontal scaling limits. See [Import & Export YAML Configuration](/references/import) for complete syntax.
- **After service creation** - Modify most scaling settings anytime through your service's **Automatic scaling configuration** page. Note that some parameters like deployment mode for databases and shared storage cannot be changed after creation.
This flexibility lets you plan scaling strategies upfront or adapt them as requirements evolve.
## Part 1: Resource Management
Resource management in Zerops focuses on efficiently allocating and adjusting CPU, RAM, and disk resources within individual containers based on actual usage patterns.
### CPU Options
Two CPU allocation modes are available for any service:
#### Shared CPU
Shared CPU provides a physical CPU core shared with up to 10 other applications. Performance varies depending on neighbors, ranging from 1/10 to 10/10 power. This option is cost-effective for non-critical workloads, development, and testing environments.
#### Dedicated CPU
Dedicated CPU gives exclusive access to a full physical CPU core(s), ensuring consistent and predictable performance. This option is ideal for production environments and CPU-intensive applications.
:::tip
CPU mode can be changed (once per hour) as needed.
:::
See the [pricing](/company/pricing#resource-pricing) for the difference between CPU modes.
### Vertical Scaling
Vertical scaling adjusts individual resources (CPU, RAM, Disk) within existing containers. When a container needs more/less power, allocated resources are increased/decreased instead of creating a new/removing container.
This is the preferred scaling method and is attempted first before horizontal scaling.
These resource management capabilities apply to **runtime** services, **databases**, **shared storage**, and **Linux containers** (Alpine and Ubuntu).
:::note
Docker services do not support vertical scaling. Resources for Docker services are fixed at the values set manually and do not automatically adjust based on usage.
:::
### Fine-Tuning Resource Allocation
Resource allocation can be configured through basic and advanced settings:
#### Minimum and Maximum Resources (Basic)
Boundaries for CPU cores, RAM, and disk space can be established.
:::tip Resource Scaling Control
To prevent scaling of specific resources, simply set identical minimum and maximum values for CPU, RAM, or Disk.
:::
#### Start CPU Core Count (Advanced)
How many CPU cores should be allocated when containers start to ensure reliable and fast startup:
- Default: 2 cores
- Applies to both dedicated and shared CPU modes
- Higher values provide more processing power during application initialization
- After startup, resources are automatically adjusted based on actual usage and limits
#### RAM Scaling Thresholds (Advanced)
RAM usage is monitored every 10 seconds to ensure optimal performance. The minimum free RAM settings serve multiple important purposes: they prevent Out of Memory (OOM) errors, provide space for kernel disk caching (which improves application performance), and maintain a buffer for sudden memory demands.
Swap is enabled for all containers to help prevent OOM errors, but proper minimum free RAM configuration is still essential—especially for services that use large amounts of RAM or benefit from kernel disk caching. Without sufficient free memory, performance may degrade due to increased disk access.
Two threshold types determine RAM scaling:
1. **Minimum Free RAM (absolute value in GB)**
   - Specifies an absolute threshold for free RAM
   - Additional memory is triggered when available RAM falls below this fixed amount
   - Default: 0.0625 GB (64 MB) for most services
   - Ideal for maintaining system stability and responsiveness
2. **Minimum Free RAM (% of Granted)**
   - Establishes a dynamic threshold based on a percentage of total granted memory
   - Default: 0% (disabled)
   - The buffer scales proportionally as total memory increases
   - Particularly useful for handling varying loads
:::note
Whichever setting provides more free memory is used.
:::
#### CPU Scaling Thresholds (Advanced)
For services using [dedicated CPU](#dedicated-cpu) cores only, CPU scaling is controlled by:
1. **Min. Free CPU Cores (%)**
   - Scale-up is triggered when free capacity drops below a fixed fraction of a single CPU core
   - Default: 10%
   - Set as a percentage of a single core's capacity
   - Example: Setting to 20% means that with one core, at least 20% of that core should remain free
2. **Dynamic Min. Free Total Core Percent**
   - Scale-up is triggered when total free capacity across all cores falls below a percentage of total capacity
   - Default: 0% (disabled)
   - Dynamically adjusts as the number of cores changes
   - Ideal for accommodating varying load distributions
   - Example: 20% setting ensures at least 20% of the combined capacity of all cores remains free
### Resource Scaling Behavior
Zerops implements an exponential growth pattern ensuring that **resources grow gradually** for minor load increases but can scale rapidly when significant additional capacity is needed. When resource usage triggers scaling, Zerops initially adds smaller increments, but as demand continues to increase, it can add larger increments to quickly meet the needs of your application.
Below are the parameters that control this behavior across all services that support vertical scaling:
- **Data Collection Interval:** How frequently resource usage metrics are collected
- **Scale-Up Window Interval:** The timeframe in which high usage must persist before adding resources
- **Scale-Down Window Interval:** The timeframe in which low usage must persist before reducing resources
- **Scale-Up Threshold Percentile:** The usage percentile that triggers resource scaling up
- **Scale-Down Threshold Percentile:** The usage percentile that triggers resource scaling down
- **Minimum Step:** The smallest increment by which resources can increase during scaling
- **Maximum Step:** The largest possible increment for resources when scaling rapidly under high load
  
      Parameter
      CPU
      RAM
      Disk
    
      Data Collection Interval
      10 seconds
      10 seconds
      10 seconds
    
      Scale-Up Window Interval
      20 seconds
      10 seconds
      10 seconds
    
      Scale-Down Window Interval
      60 seconds
      120 seconds
      300 seconds
    
      Scale-Up Threshold Percentile
      60
      50
      50
    
      Scale-Down Threshold Percentile
      40
      50
      50
    
      Minimum Step
      1 (0.1 cores)
      0.125 GB
      0.5 GB
    
      Maximum Step
      40
      32 GB
      128 GB
    
## Part 2: Container Architecture — Service-Specific Approaches
Container architecture in Zerops defines how services are distributed across containers. Different service types use fundamentally different approaches:
1. **Horizontal Scaling** (Runtime Services, Linux Containers, and Docker)
2. **Deployment Modes** (Databases and Shared Storage)
### Horizontal Scaling (Runtime Services, Linux Containers, and Docker)
Horizontal scaling adds or removes entire containers (or VMs for Docker) as demand fluctuates.
* When vertical scaling reaches its defined maximum, new containers/VMs are automatically added to handle additional load.
* As demand decreases, containers/VMs are gradually removed to optimize resource usage.
:::important HA-ready Applications
For applications to work properly across multiple containers, they must be designed to be HA-ready.
:::
#### Setting Horizontal Scaling Parameters
To configure horizontal scaling, users need to set the minimum and maximum number of containers:
- **Minimum Containers**: The baseline number of containers that should always be running (system limit: 1)
- **Maximum Containers**: The upper limit of containers that can be created during high demand (system limit: 10)
:::tip Disable Horizontal Scaling
Setting identical minimum and maximum values creates a fixed number of containers (disables automatic horizontal scaling).
:::
### Deployment Modes (Databases and Shared Storage)
For databases and shared storage services, Zerops offers two deployment modes focused on reliability and data integrity.
:::warning
Deployment mode cannot be changed after creation.
:::
#### Single Container Mode
Single Container Mode provides one container with vertical scaling only. This is suitable for development environments or non-critical data storage.
**Characteristics:**
- Limited redundancy
- No automatic recovery if the container fails
- Data since last backup (if available) may be lost if failure occurs
- Cost-effective for non-production environments
#### Highly Available (HA) Mode
Highly Available (HA) Mode creates multiple containers with built-in redundancy. This mode is strongly recommended for production environments and mission-critical data.
**Characteristics:**
- Multiple containers distributed across different physical machines
- Automatic failover and recovery mechanisms
- Data redundancy and integrity protection
- Higher reliability and availability
- Recommended for production use
:::important
Database and shared storage services in HA mode have a **fixed number of containers** that cannot be increased or decreased.
:::
**Recovery process:**
In HA mode, when a container or physical machine fails, recovery is handled automatically:
1. The failed container is disconnected from the cluster
2. A new container is created on a different physical machine
3. Data is synchronized from remaining healthy copies
4. The failed container is removed
5. Service continues with minimal disruption
### Fixed Resource Allocation (Docker Services)
Docker services in Zerops operate differently from other service types:
#### Docker Service Characteristics
- **VM-Based Deployment**: Docker services run in virtual machines rather than containers
- **Fixed Resources**: Unlike other services, Docker services do not support automatic vertical scaling
- **User-Defined Resources**: Resources are set at creation and remain fixed until manually changed
- **VM Count Changes**: The number of VMs can be changed, but this requires a VM restart
- **No Automatic Scaling**: Resource levels do not automatically adjust based on usage
**Important Considerations for Docker Services:**
- Initial resource values should be chosen carefully, as they cannot automatically scale
- Planning for expected peak loads is important when setting resource values
- Runtime services or Linux containers should be considered instead if dynamic scaling is essential
- VM restarts cause temporary service disruption when changing VM count or resources
:::warning
Docker services use fixed resources that do not automatically scale. Sufficient resources should be allocated at creation to handle expected workload. Additionally, disk space for Docker services can only be increased, not decreased without recreation of the service.
:::
## Monitoring Your Infrastructure
Zerops provides comprehensive monitoring tools in the user interface to track both resource usage and container scaling activities:
### Resource History Graphs
Resource and container scaling can be visualized over time:
- CPU utilization per container
- RAM usage patterns
- Disk space consumption
- Container count changes
These graphs help understand application resource needs, identify usage patterns, and fine-tune scaling settings for optimal performance and cost efficiency.
## Troubleshooting
#### Resource-Related Issues (All Service Types Except Docker)
**Out of Memory Errors**
* **Issue:** Application crashes with OOM errors despite resource scaling.
* **Possible Cause:** Insufficient minimum free RAM setting.
* **Solution:**
    - Increase the "Minimum free RAM" setting
    - Check for memory leaks in the application
    - Consider setting a higher minimum RAM value
**Excessive Resource Costs**
* **Issue:** Resources scaling up but not scaling down efficiently.
* **Possible Cause:** Scale-down thresholds not optimized.
* **Solution:**
    - Review usage patterns in monitoring graphs
    - Adjust scale-down thresholds to be more aggressive
    - Set appropriate resource minimums based on base requirements
#### Runtime Service and Linux Container Issues (Horizontal Scaling)
**Application Not Working Properly Across Multiple Containers**
* **Issue:** Application errors or inconsistent behavior when horizontally scaled.
* **Possible Cause:** Application not designed for distributed operation.
* **Solution:**
    - Ensure the application properly handles stateless operation
    - Implement proper session management across containers
    - Review and modify application code to support multiple instances
#### Docker Service Issues
**Insufficient Resources for Workload**
* **Issue:** Docker service experiencing performance issues or crashes.
* **Possible Cause:** Fixed resources inadequate for actual workload.
* **Solution:**
    - Since Docker services don't support automatic vertical scaling, a new service with higher resource allocations may be needed
    - Consider migrating to a runtime service or Linux container if dynamic resource scaling is needed
*Need help implementing scaling in your project? Join our [Discord community](https://discord.gg/zerops) where our team and other Zerops users can assist you!*

----------------------------------------

# Frameworks > Laravel

# Laravel in Zerops
> Modern Laravel development demands infrastructure that doesn't get in your way. Zerops provides the foundation that lets you focus on building great apps, not wrestling with environment configuration or resource management.
## Why Zerops for Laravel?
Zerops implements what we call "transparent infrastructure" - you get enterprise-grade capabilities with development-friendly ergonomics. This means:
- **Full system access** across all environments
- **Granular resource control** starting at 0.125GB RAM
- **True environment parity** from local to production
- **Zero-downtime deployments** by default
*No artificial limitations, no framework-specific compromises - just solid infrastructure that lets Laravel do what it does best.*
:::tip
New Zerops accounts receive $15 in free credits for testing. After verifying your account with a $10 initial payment, you'll get an additional $50 in credits.
:::
## Quick Start
Choose a recipe that matches your needs and deploy with a single click. Each recipe sets up a complete environment with all necessary services preconfigured.
All recipes include:
- **PHP 8.3 + Nginx**
- **PostgreSQL 16**
- **L3/L7 balancers**
- **Logging & metrics**
  
      The most bare-bones examples of Laravel app including core services + PostgreSQL.
      
      A full-stack setup including Redis, Object Storage, and Mailpit.
            
        Admin panel optimized setup including Redis, Object Storage, and Mailpit.
              
        Content management focused setup including Redis, Object Storage, and Mailpit.
              
## Core Features
### Infrastructure and Security
Each project runs in its own isolated network with enterprise-level security features automatically configured.
What makes this special is how it combines security with simplicity - this infrastructure requires zero configuration from you – it's all handled automatically when you create your project.
### Native Service Discovery
Services within your project communicate seamlessly using internal hostnames:
```php title=".env"
DB_HOST=${db_hostname}
REDIS_HOST=${cache_hostname}
```
*Environment variables are automatically injected and synchronized across all containers.*
### Intelligent Scaling
One of Zerops' most powerful features is its intelligent autoscaling system, which:
* Scales resources (CPU, RAM, Disk) up and down based on actual usage
* Maintains minimum required resources to optimize costs
* Handles both vertical and horizontal scaling automatically
* Manages disk space dynamically (a unique feature in the industry)
Through a simple configuration, you define resource boundaries while Zerops automatically handles the complex scaling decisions:
```yaml
# Example scaling configuration
services:
  - hostname: app
    minContainers: 2
    maxContainers: 6
    cpu:
      min: 1
      max: 4
    ram:
      min: 0.25
      max: 4
```
### Zero-Downtime Deployments
Deploy with confidence using our battle-tested pipeline:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      base: php@8.3
      buildCommands:
        - composer install --no-dev --optimize-autoloader
      deployFiles: ./
      cache: vendor
    run:
      base: php-nginx@8.3
      initCommands:
        - php artisan config:cache
        - php artisan route:cache
        - php artisan migrate --force --isolated
```
### High Availability
Every service can run in HA mode with automatic failover.
```yaml
services:
  - hostname: db
    type: postgresql@16
    mode: HA  # Automatic primary-replica setup
  - hostname: cache
    type: valkey@7.2
    mode: HA  # Redis cluster configuration
```
Setting up a production-grade HA database cluster typically requires deep DevOps expertise. Zerops automates this complexity, giving you an enterprise-grade setup with a single configuration flag:
* **Database Cluster** distributed across multiple physical servers
* **Automatic failover** and data replication
* **Enhanced performance** through load distribution
* **Production-grade reliability** out of the box
## Development Workflow
### Team Collaboration
Zerops enables seamless team development through:
* **Declarative Infrastructure** - version control your entire setup
* **Identical Environments** - every team member gets production-parity
* **Automated Setup** - new team members are productive in minutes
* **Transparent Configuration** - easily review and audit changes
### Local Development
Connect to your production-grade databases without any local setup through Zerops' VPN.
Start with
```
zcli vpn up
```
and select your project. Get your database credentials from the service's **Access details** in your project dashboard and update your local `.env`. See PostgreSQL example below:
```yaml
DB_CONNECTION=pgsql
DB_HOST=db.zerops  # References the service's hostname
DB_PORT=5432
DB_DATABASE=db
DB_USERNAME=db
DB_PASSWORD=[password from Access details]
```
With this configuration, you can use any database tool - no local installation needed.
### Deployment Options
Choose the workflow that fits your team:
1. **GitHub/GitLab Integration**
   - Automatic deployments on push/merge
   - Branch-specific environments
   - Build caching and artifacts
2. **CLI-Driven Pipeline**
   ```bash
   # Deploy from your terminal
   zcli push
   ```
3. **Manual Triggers**
   - Deploy specific versions
   - Roll back to previous states
   - Test deployment configurations
## Next Steps
- [Environment Variables](/frameworks/laravel/env-variables)
- [Database Migrations](/frameworks/laravel/migrations)
- [Cache & Queue with Redis](/frameworks/laravel/redis)
- [Schedule Jobs & CRON](//frameworks/laravel/cron)
- [SMTP Configuration](/frameworks/laravel/smtp)
- [Logs](/frameworks/laravel/logs)
## Resources
- [Laravel Documentation](https://laravel.com/docs)
- [Laravel Recipe Repository](https://github.com/zeropsio/recipe-laravel-minimal)
- [zCLI Documentation](/references/cli)
*Need help? Join our [Discord community](https://discord.gg/zeropsio) or check out our [quickstart guide](/frameworks/laravel/introduction).*

----------------------------------------

# Frameworks > Laravel > Cron

Zerops provides a convenient way for managing scheduled tasks through CRON jobs, configured directly in your `zerops.yaml` file. These tasks can be scheduled to run on single or multiple containers with granular timing control.
## Basic Configuration
Cron jobs are defined in the `run.crontab` section of your `zerops.yaml`. Each job requires two essential parameters:
- **command**: The command to execute
- **timing**: The CRON schedule expression
```yaml
run: 
  crontab:
    - command: "date >> /var/log/cron.log"
      timing: "0 * * * *"
```
This example logs the current timestamp every hour.
:::tip Detailed Configuration
For comprehensive configuration options and examples, refer to our [CRON configuration guide](/zerops-yaml/cron).
:::
## Common Implementation Patterns
### Laravel Scheduler
To run Laravel's scheduler, configure it to execute every minute:
```yaml
run: 
  crontab:
    - command: "php artisan schedule:run"
      timing: "* * * * *"
      workingDir: /var/www/html
```
### Cleanup Tasks
Execute maintenance tasks on all containers:
```yaml
run: 
  crontab:
    - command: "rm -rf /tmp/*"
      timing: "0 0 * * *"
      allContainers: true
```
### Multiple Jobs
Configure multiple scheduled tasks within a single service:
```yaml
run:
  crontab:
    - command: "php artisan schedule:run"
      timing: "* * * * *"
      workingDir: /var/www/html
    
    - command: "php artisan cache:clear"
      timing: "0 0 * * *"
      workingDir: /var/www/html
      
    - command: "php artisan queue:restart"
      timing: "0 */6 * * *"
      workingDir: /var/www/html
```
## Best Practices
1. **Log Output**: Implement comprehensive logging for debugging and monitoring:
   ```yaml
   command: "php artisan schedule:run >> /var/log/scheduler.log 2>&1"
   ```
2. **Working Directory**: Always specify `workingDir` for Laravel commands to ensure they are executed from the correct location.
3. **Container Selection**: Use `allContainers: true` carefully to avoid duplicate operations in a multi-container setup.
4. **Timing Considerations**: Schedule intensive tasks during off-peak hours.
## Monitoring
Enable detailed scheduler [logging](/frameworks/laravel/logs) in your `.env`:
```
LOG_CHANNEL=daily
```

----------------------------------------

# Frameworks > Laravel > Env Variables

Zerops manages environment variables without requiring manual `.env` files, enabling application deployment across different environments (development, staging, production) while keeping environment-specific configurations isolated from your code.
Read more about how [environment variables](/features/env-variables) work in Zerops.
## Laravel Environment Variables in Zerops
### Secret Variables
Some Laravel variables contain sensitive information that should never be exposed as plain text. Manage these using Zerops Secret Variables by:
* Creating and managing them through the Zerops GUI
* Defining them in a configuration file when importing a project or service (allows [automatic generation](#automatic-generation-during-import))
When importing a project or service, you can define secret variables directly in your import configuration:
```yaml
services:
  - hostname: app
    type: php-nginx@8.4
    envSecrets:
      APP_KEY: your-secret-key
```
:::tip
Secret variables can be updated at any time without requiring application redeployment.
:::
#### Automatic Generation During Import
If you prefer to have certain secrets **generated automatically**, you can use the [yaml preprocessor](/references/import-yaml/pre-processor). This is optional and only available during import:
```yaml
#yamlPreprocessor=on
services:
  - hostname: app
    type: php-nginx@8.4
    envSecrets:
      APP_KEY: )>
```
### Runtime Variables
These variables, defined in `zerops.yaml`, are typically environment-specific but not sensitive.
:::note
Changes to runtime variables require application redeployment to take effect.
:::
Below is a complete working example of `envVariables` in `zerops.yaml` (sourced from [Laravel Jetstream recipe](https://github.com/zeropsio/recipe-laravel-jetstream/blob/main/zerops.yaml)):
```yaml title="zerops.yaml"
run:
  envVariables:
    APP_LOCALE: en
    APP_FAKER_LOCALE: en_US
    APP_FALLBACK_LOCALE: en
    APP_MAINTENANCE_DRIVER: file
    APP_MAINTENANCE_STORE: database
    APP_TIMEZONE: UTC
    APP_URL: ${zeropsSubdomain}          # References generated variable
    ASSET_URL: ${APP_URL}
    VITE_APP_NAME: ${APP_NAME}
    # PostgreSQL connection settings
    DB_CONNECTION: pgsql
    DB_DATABASE: db
    DB_HOST: db                          # References database service hostname
    DB_PASSWORD: ${db_password}          # References database password
    DB_PORT: 5432
    DB_USERNAME: ${db_user}              # References database user
    # S3-compatible object storage settings
    AWS_ACCESS_KEY_ID: ${storage_accessKeyId}
    AWS_REGION: us-east-1
    AWS_BUCKET: ${storage_bucketName}    # References bucket name of service 'storage'
    AWS_ENDPOINT: ${storage_apiUrl}
    AWS_SECRET_ACCESS_KEY: ${storage_secretAccessKey} # Safely references secret
    AWS_URL: ${storage_apiUrl}/${storage_bucketName}
    AWS_USE_PATH_STYLE_ENDPOINT: true
    FILESYSTEM_DISK: s3
    # Logging Configuration
    LOG_CHANNEL: syslog
    LOG_LEVEL: debug
    LOG_STACK: single
    # SMTP settings for email delivery
    MAIL_FROM_ADDRESS: hello@example.com
    MAIL_FROM_NAME: ZeropsLaravel
    MAIL_HOST: mailpit                   # References mail service hostname
    MAIL_MAILER: smtp
    MAIL_PORT: 1025
    # Redis-based caching and session management
    BROADCAST_CONNECTION: redis
    CACHE_PREFIX: cache
    CACHE_STORE: redis
    QUEUE_CONNECTION: redis
    REDIS_CLIENT: phpredis
    REDIS_HOST: valkey                    # References Redis service hostname
    REDIS_PORT: 6379
    SESSION_DRIVER: redis
    SESSION_ENCRYPT: false
    SESSION_LIFETIME: 120
    SESSION_PATH: /
    # Security Configuration
    BCRYPT_ROUNDS: 12
    TRUSTED_PROXIES: "*"
```
Let's look at variable configurations that may need additional context and where to find detailed implementation guides:
#### Application Configuration
Core application settings that define your Laravel app's identity, URL structure, and environment parameters. Reference environment variables from the same service.
```yaml
APP_URL: ${zeropsSubdomain} # zeropsSubdomain variable is system generated
ASSET_URL: ${APP_URL}
VITE_APP_NAME: ${APP_NAME} # APP_NAME variable was created during import (envSecrets)
```
#### Database Configuration
Essential database connection parameters that securely reference your PostgreSQL service `db` by hostname and its variables - `password` and `user`.
It is safe to store `DB_PASSWORD` in `envVariables` by reference as it does not contain the sensitive value itself.
```yaml
DB_HOST: db
DB_PASSWORD: ${db_password}
DB_USERNAME: ${db_user}
```
Read more about [database management](/frameworks/laravel/migrations) for Laravel in Zerops.
#### Storage Configuration
S3-compatible object storage settings that enable efficient file handling and asset management in your Laravel application. Reference variables of Object storage service called `storage`.
```yaml
AWS_ACCESS_KEY_ID: ${storage_accessKeyId}
AWS_REGION: us-east-1
AWS_BUCKET: ${storage_bucketName}
AWS_ENDPOINT: ${storage_apiUrl}
AWS_SECRET_ACCESS_KEY: ${storage_secretAccessKey}
AWS_URL: ${storage_apiUrl}/${storage_bucketName}
AWS_USE_PATH_STYLE_ENDPOINT: true
FILESYSTEM_DISK: s3
```
Read more about [object storage](/object-storage/overview) in Zerops.
#### Logging Configuration
System monitoring and debugging configuration that determines how your application tracks events and errors. Use `syslog` channel to access logs from Zerops Dashboard.
```
LOG_CHANNEL: syslog
```
Learn how to properly [configure logging](/frameworks/laravel/logs) for Laravel in Zerops.
#### Mail Configuration
SMTP server settings that enable your application to send emails through a dedicated mail service. Reference service `mailpit` by hostname.
```
MAIL_HOST: mailpit
```
Learn how to properly [configure SMTP](/frameworks/laravel/smtp) for Laravel in Zerops.
#### Cache and Session
Redis-based configuration for handling application caching, queues, and session management to optimize performance. Reference service `valkey` by hostname.
```
REDIS_HOST: valkey
```
Learn how to properly [configure cache, queue & session management](/frameworks/laravel/redis) for Laravel in Zerops.
:::tip
For automatic execution with each deploy, add these commands to the `initCommands` section of your `zerops.yaml` file.
```yaml title="zerops.yaml"
initCommands:
  - php artisan view:cache
  - php artisan config:cache
  - php artisan route:cache
```
:::

----------------------------------------

# Frameworks > Laravel > Faq

  Question: How do I configure environment variables?
Answer: 
    You can set environment variables through the Zerops dashboard or in your `zerops.yaml` file under the `run.envVariables` section:
    ```yaml
    zerops:
      - setup: app
        run:
          envVariables:
            APP_KEY: "base64:your-key-here"
            DB_CONNECTION: "pgsql"
            DB_HOST: ${db_host}
    ```
  
  Question: How do I run database migrations?
Answer: 
    You can run migrations during initialization by adding the command to your `zerops.yaml`:
    ```yaml
    zerops:
      - setup: app
        run:
          initCommands:
            - php artisan migrate --isolated --force
    ```
  
  Question: Can I use Laravel queue with Zerops?
Answer: 
    Yes, Laravel Queue is fully supported. Configure Redis as your queue driver:
    ```yaml
    zerops:
      - setup: app
        run:
          envVariables:
            QUEUE_CONNECTION: redis
            REDIS_HOST: redis
            REDIS_PORT: 6379
    ```
  
  Question: How do I handle file storage?
Answer: 
    Zerops supports S3-compatible storage. Configure it using these environment variables:
    ```yaml
    zerops:
      - setup: app
        run:
          envVariables:
            FILESYSTEM_DISK: s3
            AWS_ACCESS_KEY_ID: ${storage_accessKeyId}
            AWS_SECRET_ACCESS_KEY: ${storage_secretAccessKey}
            AWS_BUCKET: ${storage_bucketName}
            AWS_ENDPOINT: ${storage_apiUrl}
            AWS_URL: ${storage_apiUrl}/${storage_bucketName}
            AWS_USE_PATH_STYLE_ENDPOINT: true
    ```
  
  Question: How do I enable HTTPS?
Answer: 
    HTTPS is automatically enabled when you use either a Zerops subdomain or configure your custom domain. No additional configuration is required.
  
  Question: Can I run scheduled tasks?
Answer: 
    Yes, you can configure cron jobs in your `zerops.yaml`:
    ```yaml
    zerops:
      - setup: app
        run:
          crontab:
            - command: "php artisan schedule:run"
              timing: "* * * * *"
              workingDir: /var/www/html
    ```
  
  Question: How do I configure Redis for caching?
Answer: 
    Configure Redis for caching, sessions, and queues:
    ```yaml
    zerops:
      - setup: app
        run:
          envVariables:
            CACHE_STORE: redis
            SESSION_DRIVER: redis
            REDIS_HOST: redis
            REDIS_PORT: 6379
            REDIS_CLIENT: phpredis
    ```
  
  Question: How do I optimize my Laravel application?
Answer: 
    Add these optimization commands to your initialization:
    ```yaml
    zerops:
      - setup: app
        run:
          initCommands:
            - php artisan view:cache
            - php artisan config:cache
            - php artisan route:cache
            - php artisan optimize
    ```
  
  Question: How do I handle asset compilation?
Answer: 
    Configure asset compilation in your build phase:
    ```yaml
    zerops:
      - setup: app
        build:
          base:
            - php@8.4
            - nodejs@18
          buildCommands:
            - composer install --optimize-autoloader --no-dev
            - npm install
            - npm run build
          cache:
            - vendor
            - node_modules
    ```
  
  Question: How do I implement health checks?
Answer: 
    Add health checks to ensure your application is running properly:
    ```yaml
    zerops:
      - setup: app
        deploy:
          readinessCheck:
            httpGet:
              port: 80
              path: /up
        run:
          healthCheck:
            httpGet:
              port: 80
              path: /up
    ```
  

----------------------------------------

# Frameworks > Laravel > Introduction

 Deploy the same Laravel setup as in this tutorial with a single click. All you need is a Zerops account.
  
## Introduction
In this tutorial, you'll learn how to deploy a Laravel application in Zerops. We'll configure a complete environment using Apache as the web server and PostgreSQL as the database.
By the end of this tutorial, you will:
- Have a fresh Laravel installation running locally
- Set up a Zerops project with Apache and PostgreSQL
- Configure zero-downtime deployment with environment variables
- Deploy a production-ready Laravel application with Zerops subdomain access
- Set up secure VPN access to your PostgreSQL database
## Prerequisites
This tutorial assumes you have:
* PHP, Composer, git installed locally
* [Zerops account](https://app.zerops.io/signup)
* [zcli](/references/cli) tool installed
:::note
You don't need to install PostgreSQL locally - Zerops VPN lets you connect directly to the remote database for development.
:::
## Step 1 — Creating a New Laravel Project
Let's start by creating a fresh Laravel project:
```bash
composer create-project laravel/laravel zerops-laravel
cd zerops-laravel
```
Let's verify everything works locally. Start Laravel's development server:
```bash
php artisan serve
```
Visit http://localhost:8000 in your browser. You should see Laravel's welcome page.
:::tip
While we're using Laravel's built-in server for simplicity, you can use any local development setup you prefer (Valet, Sail, XAMPP, etc.).
:::
If you see the welcome page, great! Your local setup is working correctly.
## Step 2 — Setting Up Your Zerops Project
### Log in to zcli
[Log in](/references/cli#personal-access-tokens) to zcli with your **Personal access token**.
### Create Project Configuration
When you create a project in Zerops, you get a production-grade infrastructure with automated security, load balancing, and SSL management. Each project runs in its own isolated network where services communicate securely using simple hostnames, all accessible through VPN for seamless local development.
Learn more about infrastructure features in documentation section [Project & Services Structure](/features/infrastructure).
#### Project Configuration File
The project configuration defines your infrastructure using YAML. This approach provides clear, reproducible configuration that can be version controlled. Later in this tutorial, we'll also show how to achieve the same using the GUI.
Create a new file in your project root called `zerops-project-import.yaml` with the following content:
```yaml title="zerops-project-import.yaml"
#yamlPreprocessor=on
project:
  name: laravel-zerops
  tags:
    - zerops-tutorial # tag for easy filtering (optional)
services:
  - hostname: app
    type: php-apache@8.4
    envSecrets:
      # yamlPreprocessor feat: generates a random 32 char and stores it
      APP_KEY: )>
  - hostname: db
    type: postgresql@16
    mode: HA  # High Availability mode for robust production setup
```
:::tip Generate secrets
The `#yamlPreprocessor=on` directive enables Zerops' [YAML preprocessing](/references/import-yaml/pre-processor) for this import file, allowing us to use dynamic values and built-in functions like `generateRandomString`.
:::
#### Automatic Resource Management
Zerops features intelligent autoscaling that manages all resources (CPU, RAM, Disk) based on actual usage, automatically scaling up and down to optimize costs while maintaining performance.
In this guide, we'll use default scaling ranges and that's why you won't find resource configurations in the import file. See [current ranges](/php/how-to/scaling#basic-settings) for horizontal and vertical scaling of PHP services.
#### High-Availability Database
In this guide, [enabling HA mode](/postgresql/how-to/scale) creates a database cluster across three physical servers, with all the complexity managed automatically by Zerops.
Through Zerops VPN, you can securely access this database setup directly from your local machine, ensuring your development environment matches production exactly.
#### Import the Project
Now create the project by running:
```bash
zcli project project-import zerops-project-import.yaml
```
### Alternative: Creating Project via GUI
You can also create and configure your project through the Zerops dashboard:
1. Log into your [Zerops Dashboard](https://app.zerops.io)
2. Click **Add new project**
3. Set a project name (e.g., "laravel-zerops") and click **Create project**
Then add the required services:
1. **PHP + Apache Service:**
   - Click **Add Service** and select **PHP+Apache**
   - Set hostname to "app"
   - Keep all other settings as default
2. **PostgreSQL Service:**
   - Click **Add Service** and select **PostgreSQL**
   - Set hostname to "db"
   - Keep all other settings as default
## Step 3 — Configuring Your Application
The [deployment configuration](/zerops-yaml/specification) controls how your application builds and runs. Create a `zerops.yaml` file in your project root:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      base:
        - php@8.4
      buildCommands:
        - composer install --ignore-platform-reqs
      deployFiles: ./
      cache:
        - vendor
        - composer.lock
    deploy:
      readinessCheck:
        httpGet:
          port: 80
          path: /up
    run:
      base: php-apache@8.4
      envVariables:
        APP_NAME: "Laravel Zerops Demo"
        APP_DEBUG: false
        APP_ENV: production
        APP_URL: ${zeropsSubdomain}
        DB_CONNECTION: pgsql
        DB_HOST: db
        DB_PORT: 5432
        DB_DATABASE: db
        DB_USERNAME: ${db_user}
        DB_PASSWORD: ${db_password}
        LOG_CHANNEL: stack
        LOG_LEVEL: debug
        SESSION_DRIVER: database
      initCommands:
        - php artisan config:cache
        - php artisan route:cache
        - php artisan migrate --force --isolated
        - php artisan optimize
      healthCheck:
        httpGet:
          port: 80
          path: /up
```
Let's break down some important parts of this configuration:
### Environment Variables
Zerops automatically generates and securely manages various environment variables. For example, `zeropsSubdomain` provides your application's URL, while database credentials `user` and `password` are variables of the `db` service. It is possible to reference any variable or a service by hostname within your project's private network.
```yaml
APP_URL: ${zeropsSubdomain}  # Automatically set to your app's Zerops URL
DB_USERNAME: ${db_user}      # Database credentials auto-injected
DB_PASSWORD: ${db_password}  # Securely managed by Zerops
```
Learn more about [environment variables](/frameworks/laravel/env-variables) for Laravel.
### Safe Database Migrations
```yaml
php artisan migrate --force --isolated
```
The `--isolated` flag prevents multiple servers from running migrations simultaneously by using a cache lock, ensuring safe database updates during deployment.
### Health Checks
The health check configuration ensures your application is running correctly:
```yaml
    readinessCheck:
        httpGet:
          port: 80
          path: /up
    ...
    healthCheck:
        httpGet:
          port: 80
          path: /up
```
By default, latest version of Laravel responds with a 200 OK status on the `/up` endpoint, so no additional configuration is needed.
## Step 4 — Deploying Your Application
Now comes the exciting part - deploying your application to Zerops!
### Deploying Your Code
Initialize git in your project directory:
```bash
git init
```
:::note
Git is required to track changes for deployment. You don't need to commit, but initializing git helps Zerops manage the deployment files.
:::
Push your code to Zerops, select your project and service when prompted:
```bash
zcli push
```
### Monitoring the Deployment
1. Go to the [Zerops Dashboard](https://app.zerops.io)
2. In the top-left corner, you'll see a circle with **running process** text
3. Click it to see the build progress overview
4. Click **Open pipeline detail** button to view the detailed build process
You'll see the deployment progress with timing for each step:
- Initializing build container
- Running build commands from zerops.yaml
- Creating app version and upgrading PHP+Apache service
The entire process usually takes less than a minute to complete.
## Step 5 — Verifying Your Deployment
Once the deployment completes, let's verify everything works:
1. Go to your project's app service
2. Click on **Public access & internal ports**
3. Find the **Public Access through zerops.app Subdomain** section
4. Toggle **Enable Zerops Subdomain Access**
5. Click the generated URL (e.g., `https://app-xxx.prg1.zerops.app`) to view your application
:::note
The Zerops subdomain is perfect for testing and development, but for production, you should [set up your own domain](/references/networking/public-access#custom-domain-access) under **Public Access through Your Domains**.
:::
### Testing Database Connectivity
Let's create a quick route to test database connectivity. Add this to your `routes/web.php`:
```php
Route::get('/db-test', function () {
    session()->save();
    return 'Current number of active sessions in database: ' . Illuminate\Support\Facades\DB::table('sessions')->count();
});
```
Deploy this change:
```bash
zcli push
```
Visit `{your-app-url}/db-test` to verify database connectivity.
## Accessing Your Database Locally
Once your application is deployed, you might want to access the database directly from your local machine. Zerops makes this easy with VPN access.
### Setting up VPN Access
1. Start the VPN connection:
```bash
zcli vpn up
```
2. Select your project when prompted
3. Try http://app.zerops/ to verify connectivity.
That's it! You now have direct access to all services in your project.
### Connecting to Database
To get your database credentials:
1. Go to the PostgreSQL service in your project
2. Click **Access details** button
3. Here you'll find all connection details including hostname, port, user, and password
Update your local `.env` file with these credentials:
```ini
DB_CONNECTION=pgsql
DB_HOST=db.zerops
DB_PORT=5432
DB_DATABASE=db
DB_USERNAME=db
DB_PASSWORD=[password from Access details]
```
Now you can use your favorite database management tool or run artisan commands while working with the database in Zerops - no local PostgreSQL installation needed!
## Next Steps
Now that your Laravel application is running in Zerops, consider:
1. Setting up a [custom domain](/references/networking/public-access#custom-domain-access)
2. Implementing basic CI/CD pipelines with [GitHub](/references/github-integration) or [GitLab](/references/gitlab-integration) integration
3. Setting up [object storage](/object-storage/overview)
## Conclusion
Congratulations! 🎉 You've successfully deployed a Laravel application in Zerops with Apache and PostgreSQL. Your application is now running in a production-ready environment with automated builds and deployments.
### Additional Resources
- [Laravel Documentation](https://laravel.com/docs)
- [Laravel Recipe Repository](https://github.com/zeropsio/recipe-laravel-minimal)
- [zCLI Documentation](/references/cli)
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Logs

Zerops provides comprehensive logging capabilities for Laravel applications using its distributed logging architecture. This guide shows you how to set up and optimize Laravel logging in Zerops, ensuring your application logs are properly captured and accessible.
## Accessing Logs
Learn how to [access and view your logs](/php/how-to/logs) in Zerops.
## Configuration
### Zerops Environment Variables
Laravel logging in Zerops is configured through environment variables, such as:
- `LOG_CHANNEL`: Specifies which logging channel to use (e.g., 'syslog', 'stack')
- `LOG_STACK`: When using the stack channel, defines which channels to include
- `LOG_LEVEL`: Sets the minimum log level to capture (e.g., 'debug', 'info', 'error')
```yaml title="zerops.yaml"
zerops:
  - setup: app
    run:
      envVariables:
        LOG_CHANNEL: syslog
        LOG_LEVEL: debug
        LOG_STACK: single
```
:::tip Available Log Channels
Laravel supports several logging channels out of the box:
- **stack**: Aggregates multiple logging channels into a single channel
- **single**: Writes logs to a single file (storage/logs/laravel.log)
- **daily**: Creates daily rotating log files
- **syslog**: Writes to system log (recommended for Zerops)
- **stderr**: Writes to PHP's standard error output stream
- **errorlog**: Uses PHP's error_log function
- **slack**: Sends log messages to Slack
- **papertrail**: Sends logs to Papertrail
- **mongodb**: Stores logs in MongoDB (requires additional package)
:::
To use multiple logging channels, [configure](#laravel-configuration) the stack channel:
```yaml
LOG_CHANNEL: stack
LOG_STACK: syslog,daily
```
This configuration logs to both syslog (for Zerops) and daily files (for local access).
:::tip
Using appropriate log levels makes it easier to filter and find relevant messages in the Zerops GUI.
:::
### Laravel Configuration
While Zerops is configured through environment variables, these variables are interpreted by Laravel's logging system. By default, Laravel includes a logging configuration that works out of the box - you don't need to modify anything.
If you're curious about the underlying configuration or need to customize it beyond environment variables, here's what Laravel's logging configuration typically looks like:
    
```php title="config/logging.php"
 env('LOG_CHANNEL', 'stack'),
    'deprecations' => [
        'channel' => env('LOG_DEPRECATIONS_CHANNEL', 'null'),
        'trace' => env('LOG_DEPRECATIONS_TRACE', false),
    ],
    'channels' => [
        'stack' => [
            'driver' => 'stack',
            'channels' => explode(',', env('LOG_STACK', 'single')),
            'ignore_exceptions' => false,
        ],
        'single' => [
            'driver' => 'single',
            'path' => storage_path('logs/laravel.log'),
            'level' => env('LOG_LEVEL', 'debug'),
            'replace_placeholders' => true,
        ],
        'daily' => [
            'driver' => 'daily',
            'path' => storage_path('logs/laravel.log'),
            'level' => env('LOG_LEVEL', 'debug'),
            'days' => env('LOG_DAILY_DAYS', 14),
            'replace_placeholders' => true,
        ],
        'stderr' => [
            'driver' => 'monolog',
            'handler' => StreamHandler::class,
            'with' => [
                'stream' => 'php://stderr',
            ],
            'level' => env('LOG_LEVEL', 'debug'),
        ],
        'syslog' => [
            'driver' => 'syslog',
            'level' => env('LOG_LEVEL', 'debug'),
        ],
        'errorlog' => [
            'driver' => 'errorlog',
            'level' => env('LOG_LEVEL', 'debug'),
        ],
    ],
];
```
### Using Logs
Laravel provides several ways to write log messages:
```php
// Using facade
use Illuminate\Support\Facades\Log;
Log::emergency($message);
Log::alert($message);
Log::critical($message);
Log::error($message);
Log::warning($message);
Log::notice($message);
Log::info($message);
Log::debug($message);
// Using helper function
logger()->info($message);
logger($message); // defaults to info level
// With context data
Log::info('User failed to login.', ['id' => $user->id]);
```

----------------------------------------

# Frameworks > Laravel > Migrations

Database migrations are **version control** for your database schema, allowing you to evolve your database structure alongside your application versions. Each migration represents a specific version change in your application's database schema, ensuring your database structure stays synchronized with your codebase as your application evolves.
This guide covers how to implement and manage these version-based database changes in Zerops, focusing on PostgreSQL as the recommended database system.
## Environment Configuration
Configure your database connection in your environment variables:
```yaml
zerops:
  - setup: app
    run:
      envVariables:
        DB_CONNECTION: pgsql
        DB_HOST: ${db_hostname}
        DB_PORT: 5432
        DB_DATABASE: myapp
        DB_USERNAME: ${db_user}
        DB_PASSWORD: ${db_password}
```
:::warning Backup your data
Before running migrations in production, it's strongly recommended to back up your database. Zerops provides automated daily backups - see our [backup documentation](/features/backup) for details.
:::
## Running Migrations
### Automatic Migrations
The most reliable way to manage migrations in your deployment pipeline is through automatic execution. Configure this in your `zerops.yaml`:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    run:
      initCommands:
        - php artisan migrate --force --isolated
```
:::caution
When running automatic migrations in production, the `--force` flag is necessary to bypass Laravel's safety prompt. Without this flag, Laravel asks for confirmation to help prevent accidental data loss.
:::
:::note Migrations in HA mode
The `--isolated` flag prevents multiple servers from running migrations simultaneously by using a cache lock.
:::
### Manual Migrations
For development and troubleshooting purposes, you can execute migrations manually through SSH:
```bash
# Connect to your zerops project
zcli vpn up
# SSH into your service using it's hostname (app)
ssh app
# For MacOS users
ssh app.zerops
```
## Migration Commands
Essential migration commands for your workflow:
```bash
# Create a new migration file with timestamp
php artisan make:migration create_users_table
# Execute all pending migrations
php artisan migrate
# Revert the most recent migration operation
php artisan migrate:rollback
# Reset and rerun all migrations (warning: destroys existing data)
php artisan migrate:fresh
# Display current migration status
php artisan migrate:status
```
## Best Practices
### Migration Structure
```php {title="database/migrations/create_users_table.php"}
id();                    // Auto-incrementing primary key
            $table->string('name');          // User's full name
            $table->string('email')->unique(); // Unique email address
            $table->timestamp('email_verified_at')->nullable(); // Email verification timestamp
            $table->string('password');      // Hashed password
            $table->rememberToken();         // Remember me token
            $table->timestamps();            // Created_at and updated_at timestamps
        });
    }
    /**
     * Reverse the migrations.
     * Removes the users table completely.
     */
    public function down()
    {
        Schema::dropIfExists('users');
    }
};
```
### Safe Migration Practices
1. **Implement Reversible Changes**
```php
public function down()
{
    // Always provide a way to undo migration changes
    Schema::table('users', function (Blueprint $table) {
        $table->dropColumn('new_column');
    });
}
```
2. **Use Foreign Key Contraints**
```php
public function up()
{
    Schema::table('posts', function (Blueprint $table) {
        // Create relationship with cascading delete
        $table->foreignId('user_id')
              ->constrained()
              ->onDelete('cascade');
    });
}
```
3. **Handle Large Tables Efficiently**
```php
public function up()
{
    // Step 1: Add nullable column to prevent blocking operations
    Schema::table('large_table', function (Blueprint $table) {
        $table->string('new_column')->nullable();
    });
    // Step 2: Update data in manageable chunks
    DB::table('large_table')
        ->orderBy('id')
        ->chunk(1000, function ($records) {
            foreach ($records as $record) {
                DB::table('large_table')
                    ->where('id', $record->id)
                    ->update(['new_column' => 'default_value']);
            }
    });
}
```
## Testing Migrations
### Create a Test Database
Add a testing connection to your `config/database.php`:
```php
'testing' => [
    'driver' => 'pgsql',
    'host' => env('DB_TEST_HOST', '127.0.0.1'),
    'database' => env('DB_TEST_DATABASE', 'testing'),
    'username' => env('DB_TEST_USERNAME', 'postgres'),
    'password' => env('DB_TEST_PASSWORD', ''),
],
```
### Migration Test Example
Create a test file at `tests/Unit/MigrationTest.php`:
```php
/**
 * Test migration execution and schema verification
 */
public function test_migrations_can_be_run()
{
    // Execute all migrations
    Artisan::call('migrate');
    // Verify table creation
    $this->assertTrue(Schema::hasTable('users'));
    // Verify column structure
    $this->assertTrue(Schema::hasColumns('users', [
        'id', 'name', 'email', 'password'
    ]));
}
```
:::tip Migration Tips
* Always create a backup before running migrations in production
* Use database transactions for complex migrations
* Thoroughly test migrations in development environment
* Implement seeders for initial data population
* Monitor execution time for migrations on large tables
:::
## Troubleshooting
Common migration issues and their solutions:
1. **Migration Timeout** Configure longer timeout in [zerops.yaml](/zerops-yaml/specification):
```yaml
zerops:
  - setup: app
    run:
      initCommands:
        - php artisan migrate --force --isolated --timeout=1000
```
2. **Database Lock Timeout** Adjust PDO settings in `config/database.php`:
```php
'pgsql' => [
    // ...
    'options' => [
        PDO::ATTR_LOCK_TIMEOUT => 1000 // Milliseconds
    ]
],
```
3. **Reset Migration State** Commands:
```bash
# Reset all migrations
php artisan migrate:reset
# Re-run all migrations
php artisan migrate
```
## Additional Resources
* [Laravel Migration Documentation](https://laravel.com/docs/11.x/migrations)

----------------------------------------

# Frameworks > Laravel > Recipes > Filament Devel

[Filament](https://filamentphp.com/) is a collection of tools for rapidly building beautiful TALL stack (Tailwind, Alpine, Laravel, Livewire) applications. It provides a powerful admin panel, form builder, table builder, and other components that help you build feature-rich web applications with minimal effort.
This recipe demonstrates how to effectively integrate Laravel Filament applications with Zerops, providing a fully production-capable setup. While this setup is built for professional deployment, we call it a **development environment** due to its streamlined resource allocation and use of the [Lightweight](/features/infrastructure#project-core-options) core package, optimizing costs without compromising functionality.
  Set up a Laravel environment with Filament's admin panel and TALL stack in a development-optimized configuration.
  
## Environment Overview
Your newly deployed Laravel Filament environment includes:
- A fully configured Laravel application service with Filament installed
- PostgreSQL database integration with migration automation
- Automated build and deployment pipeline
- Health and readiness checks
- Configured Filament admin panel and components
:::note
For production environments with high-availability services and enterprise-grade reliability, consider deploying the [production environment recipe](/frameworks/laravel/recipes/minimal-prod).
:::
## Application Configuration
The app has been set up to utilize PostgreSQL service and includes Filament's admin panel and components. Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
- Filament assets compilation
## Try the build & deploy pipeline in 30 seconds
While Zerops supports various CI/CD workflows (CLI, GitHub Actions, built-in CI/CD), let's start with the simplest path to get you familiar with the core concepts:
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-minimal) and clone it locally
2. Navigate to **Pipelines & CI/CD settings** and connect the service with your new GitHub repository, setting the trigger to **Push to Branch**
### Test Your Pipeline
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in project detail
## Integration with Existing Applications
If you're looking to integrate an existing Laravel Filament application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-minimal/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel Filament tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel Filament project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Filament Local

[Filament](https://filamentphp.com/) is a collection of tools for rapidly building beautiful TALL stack (Tailwind, Alpine, Laravel, Livewire) applications. It provides a powerful admin panel, form builder, table builder, and other components that help you build feature-rich web applications with minimal effort.
This recipe provides a comprehensive Filament setup with PostgreSQL database, Redis-compatible store, object storage, and automated deployment pipeline, designed for **local development** This recipe provides a streamlined Laravel setup with PostgreSQL database and automated deployment pipeline, designed for **local development** with cost-efficient resource allocation and the [Lightweight](/features/infrastructure#project-core-options) core package. This means:
- Resources are optimized for development workloads
- Services can be started/stopped as needed during active development
- Cost-effective configuration suitable for development and testing
  Set up a Laravel environment with Filament's admin panel and TALL stack components for efficient local development.
  
## Environment Overview
Your newly deployed Filament environment includes:
- A fully configured Laravel application service with Filament
- PostgreSQL database integration with migration automation
- Valkey (Redis-compatible KV store) for sessions and cache
- Built-in object storage for filesystem
- Mailpit for development SMTP server
- Automated build and deployment pipeline
- Health and readiness checks
:::note
For production environments with high-availability services and enterprise-grade reliability, consider deploying the [production environment recipe](/frameworks/laravel/recipes/filament-prod).
:::
## What to Expect
The deployment process takes just a few minutes. Once complete, you'll receive:
- A live URL to access your application
- Database credentials
- Access to your project dashboard
- CLI configuration details for VPN access
## Setting Up Local Development
Zerops provides a built-in VPN feature through its CLI tool, enabling seamless local development against remote resources. Here's how to set it up:
### Prerequisites
- Install the [Zerops CLI](/references/cli#get-started) and log in with [personal access token](/references/cli#personal-access-tokens)
- Install [Wireguard](/references/networking/vpn) on your system
### Setup Steps
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-filament) and clone it locally
2. **Configure VPN Access**
   ```bash
   # Initialize VPN connection using project ID
   zcli vpn up 
   # Or use interactive mode to select your project
   zcli vpn up
   ```
3. **Set Up Environment**
   ```bash
   # Create and configure environment file
   cp .env.example .env
   ```
   Fill in database access details - in Zerops GUI go to the detail of `db` service and open **Access details** in the left menu.
   ```bash
   composer install
   php artisan key:generate
   npm install
   npm run dev
   ```
4. **Start Development Server**
   ```bash
   php artisan serve # or use your preferred setup (Valet, Herd, Sail)
   ```
Your local environment is now connected to the Zerops infrastructure, utilizing the database, redis and storage from Zerops while maintaining local development flexibility.
## Application Configuration
The app has been set up to utilize:
- Valkey (Redis-compatible KV store) to handle sessions and cache
- Built-in object storage for Laravel and Filament-specific filesystem operations
- Mailpit as a mock SMTP server for development purposes
Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
## Try the Build & Deploy Pipeline
Now that you're logged into zcli, deploying your application is straightforward. Simply enter `zcli push` in your terminal from the root of your freshly cloned project.
### Test Your Pipeline
The best way to verify your setup is with a quick test:
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in your project dashboard
### Setting Up Automated CI/CD
To enable automatic deployments:
1. Navigate to **Pipelines & CI/CD settings** in your service dashboard
2. Connect the service with your new GitHub repository
3. Set the trigger to **Push to Branch**
## Integration with Existing Applications
If you're looking to integrate an existing Filament application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-filament/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Filament Prod

[Filament](https://filamentphp.com/) is a collection of tools for rapidly building beautiful TALL stack (Tailwind, Alpine, Laravel, Livewire) applications. It provides a powerful admin panel, form builder, table builder, and other components that help you build feature-rich web applications with minimal effort.
This recipe demonstrates how to effectively integrate Laravel Filament applications with Zerops, providing a fully production-grade setup. It's built as a **production environment** with high-availability configuration and uses the [Serious](/features/infrastructure#project-core-options) core package, ensuring enterprise-grade reliability and robust performance.
  Set up a production-ready Laravel environment with Filament's admin panel and TALL stack, backed by enterprise-grade reliability.
  
## Environment Overview
Your newly deployed Laravel Filament environment includes:
- A fully configured Laravel application service with Filament installed and high availability
- PostgreSQL database integration with migration automation
- Automated build and deployment pipeline
- Health and readiness checks
- Configured Filament admin panel and components
:::note
For development environments with cost-efficient resource allocation, consider deploying the [development environment recipe](/frameworks/laravel/recipes/minimal-devel).
:::
## Application Configuration
The app has been set up to utilize PostgreSQL service and includes Filament's admin panel and components. Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
- Filament assets compilation
## Try the build & deploy pipeline in 30 seconds
While Zerops supports various CI/CD workflows (CLI, GitHub Actions, built-in CI/CD), let's start with the simplest path to get you familiar with the core concepts:
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-minimal) and clone it locally
2. Navigate to **Pipelines & CI/CD settings** and connect the service with your new GitHub repository, setting the trigger to **Push to Branch**
### Test Your Pipeline
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in project detail
## Integration with Existing Applications
If you're looking to integrate an existing Laravel Filament application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-minimal/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel Filament tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel Filament project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Jetstream Devel

Laravel Jetstream provides a polished application scaffolding for Laravel, featuring authentication, registration, email verification, two-factor authentication, session management, API support via Laravel Sanctum, and optional team management features. It serves as the perfect starting point for your next Laravel application.
This recipe demonstrates how to effectively integrate Laravel Jetstream applications with Zerops, providing a fully production-capable setup. While this setup is built for professional deployment, we call it a **development environment** due to its streamlined resource allocation and use of the [Lightweight](/features/infrastructure#project-core-options) core package, optimizing costs without compromising functionality.
  Set up a Laravel environment with Jetstream's team features and authentication system in a development-optimized configuration.
  
## Environment Overview
Your newly deployed Laravel Jetstream environment includes:
- A fully configured Laravel application service with Jetstream installed
- PostgreSQL database integration with migration automation
- Automated build and deployment pipeline
- Health and readiness checks
- Configured Jetstream authentication system
:::note
For production environments with high-availability services and enterprise-grade reliability, consider deploying the [production environment recipe](/frameworks/laravel/recipes/minimal-prod).
:::
## Application Configuration
The app has been set up to utilize PostgreSQL service and includes Jetstream's authentication scaffolding. Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
- Jetstream assets compilation
## Try the build & deploy pipeline in 30 seconds
While Zerops supports various CI/CD workflows (CLI, GitHub Actions, built-in CI/CD), let's start with the simplest path to get you familiar with the core concepts:
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-minimal) and clone it locally
2. Navigate to **Pipelines & CI/CD settings** and connect the service with your new GitHub repository, setting the trigger to **Push to Branch**
### Test Your Pipeline
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in project detail
## Integration with Existing Applications
If you're looking to integrate an existing Laravel Jetstream application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-minimal/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel Jetstream tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel Jetstream project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Jetstream Local

Laravel Jetstream provides a polished application scaffolding for Laravel, featuring authentication, registration, email verification, two-factor authentication, session management, API support via Laravel Sanctum, and optional team management features. It serves as the perfect starting point for your next Laravel application.
This recipe provides a comprehensive Laravel Jetstream setup with PostgreSQL database, Redis-compatible store, object storage, and automated deployment pipeline, designed for **local development** with cost-efficient resource allocation and the [Lightweight](/features/infrastructure#project-core-options) core package. This means:
- Resources are optimized for development workloads
- Services can be started/stopped as needed during active development
- Cost-effective configuration suitable for development and testing
  Set up a Laravel environment with Jetstream's team features and authentication system for rapid local development.
  
## Environment Overview
Your newly deployed Laravel Jetstream environment includes:
- A fully configured Laravel application service with Jetstream
- PostgreSQL database integration with migration automation
- Valkey (Redis-compatible KV store) for sessions and cache
- Built-in object storage for filesystem
- Mailpit for development SMTP server
- Automated build and deployment pipeline
- Health and readiness checks
:::note
For production environments with high-availability services and enterprise-grade reliability, consider deploying the [production environment recipe](/frameworks/laravel/recipes/jetstream-prod).
:::
## What to Expect
The deployment process takes just a few minutes. Once complete, you'll receive:
- A live URL to access your application
- Database credentials
- Access to your project dashboard
- CLI configuration details for VPN access
## Setting Up Local Development
Zerops provides a built-in VPN feature through its CLI tool, enabling seamless local development against remote resources. Here's how to set it up:
### Prerequisites
- Install the [Zerops CLI](/references/cli#get-started) and log in with [personal access token](/references/cli#personal-access-tokens)
- Install [Wireguard](/references/networking/vpn) on your system
### Setup Steps
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-jetstream) and clone it locally
2. **Configure VPN Access**
   ```bash
   # Initialize VPN connection using project ID
   zcli vpn up 
   # Or use interactive mode to select your project
   zcli vpn up
   ```
3. **Set Up Environment**
   ```bash
   # Create and configure environment file
   cp .env.example .env
   ```
   Fill in database access details - in Zerops GUI go to the detail of `db` service and open **Access details** in the left menu.
   ```bash
   composer install
   php artisan key:generate
   npm install
   npm run dev
   ```
4. **Start Development Server**
   ```bash
   php artisan serve # or use your preferred setup (Valet, Herd, Sail)
   ```
Your local environment is now connected to the Zerops infrastructure, utilizing the database, redis and storage from Zerops while maintaining local development flexibility.
## Application Configuration
The app has been set up to utilize:
- Valkey (Redis-compatible KV store) to handle sessions and cache
- Built-in S3 object storage for Laravel and Jetstream-specific filesystem operations
- Mailpit as a mock SMTP server for development purposes
Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
## Try the Build & Deploy Pipeline
Now that you're logged into zcli, deploying your application is straightforward. Simply enter `zcli push` in your terminal from the root of your freshly cloned project.
### Test Your Pipeline
The best way to verify your setup is with a quick test:
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in your project dashboard
### Setting Up Automated CI/CD
To enable automatic deployments:
1. Navigate to **Pipelines & CI/CD settings** in your service dashboard
2. Connect the service with your new GitHub repository
3. Set the trigger to **Push to Branch**
## Integration with Existing Applications
If you're looking to integrate an existing Laravel Jetstream application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-jetstream/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Jetstream Prod

Laravel Jetstream provides a polished application scaffolding for Laravel, featuring authentication, registration, email verification, two-factor authentication, session management, API support via Laravel Sanctum, and optional team management features. It serves as the perfect starting point for your next Laravel application.
This recipe demonstrates how to effectively integrate Laravel Jetstream applications with Zerops, providing a fully production-grade setup. It's built as a **production environment** with high-availability configuration and uses the [Serious](/features/infrastructure#project-core-options) core package, ensuring enterprise-grade reliability and robust performance.
  Set up a production-ready Laravel environment with Jetstream's team features and authentication system, backed by high-availability services.
  
## Environment Overview
Your newly deployed Laravel Jetstream environment includes:
- A fully configured Laravel application service with Jetstream installed and high availability
- PostgreSQL database integration with migration automation
- Automated build and deployment pipeline
- Health and readiness checks
- Configured Jetstream authentication system
:::note
For development environments with cost-efficient resource allocation, consider deploying the [development environment recipe](/frameworks/laravel/recipes/minimal-devel).
:::
## Application Configuration
The app has been set up to utilize PostgreSQL service and includes Jetstream's authentication scaffolding. Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
- Jetstream assets compilation
## Try the build & deploy pipeline in 30 seconds
While Zerops supports various CI/CD workflows (CLI, GitHub Actions, built-in CI/CD), let's start with the simplest path to get you familiar with the core concepts:
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-minimal) and clone it locally
2. Navigate to **Pipelines & CI/CD settings** and connect the service with your new GitHub repository, setting the trigger to **Push to Branch**
### Test Your Pipeline
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in project detail
## Integration with Existing Applications
If you're looking to integrate an existing Laravel Jetstream application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-minimal/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel Jetstream tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel Jetstream project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Minimal Devel

This recipe demonstrates how to effectively integrate Laravel applications with Zerops, providing a fully production-capable setup. While it's built for professional deployment, we call it a **development environment** due to its streamlined resource allocation and use of the [Lightweight](/features/infrastructure#project-core-options) core package, optimizing costs without compromising functionality.
  Set up a streamlined Laravel environment with development-optimized resources and configurations.
  
## Environment Overview
Your newly deployed Laravel environment includes:
- A fully configured Laravel application service
- PostgreSQL database integration with migration automation
- Automated build and deployment pipeline
- Health and readiness checks
:::note
For production environments with high-availability services and enterprise-grade reliability, consider deploying the [production environment recipe](/frameworks/laravel/recipes/minimal-prod).
:::
## Application Configuration
The app has been set up to utilize PostgreSQL service. Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
## Try the build & deploy pipeline in 30 seconds
While Zerops supports various CI/CD workflows (CLI, GitHub Actions, built-in CI/CD), let's start with the simplest path to get you familiar with the core concepts:
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-minimal) and clone it locally
2. Navigate to **Pipelines & CI/CD settings** and connect the service with your new GitHub repository, setting the trigger to **Push to Branch**
### Test Your Pipeline
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in project detail
## Integration with Existing Applications
If you're looking to integrate an existing Laravel application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-minimal/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Minimal Local

This recipe provides a streamlined Laravel setup with PostgreSQL database and automated deployment pipeline, designed for **local development** with cost-efficient resource allocation and the [Lightweight](/features/infrastructure#project-core-options) core package. This means:
- Resources are optimized for development workloads
- Services can be started/stopped as needed during active development
- Cost-effective configuration suitable for development and testing
  Set up a streamlined Laravel environment optimized for local development with this lightweight, cost-efficient configuration.
  
## Environment Overview
Your newly deployed Laravel environment includes:
- A fully configured Laravel application service
- PostgreSQL database integration with migration automation
- Automated build and deployment pipeline
- Health and readiness checks
:::note
For production environments with high-availability services and enterprise-grade reliability, consider deploying the [production environment recipe](/frameworks/laravel/recipes/minimal-prod).
:::
## What to Expect
The deployment process takes just a few minutes. Once complete, you'll receive:
- A live URL to access your application
- Database credentials
- Access to your project dashboard
- CLI configuration details for VPN access
## Setting Up Local Development
Zerops provides a built-in VPN feature through its CLI tool, enabling seamless local development against remote resources. Here's how to set it up:
### Prerequisites
- Install the [Zerops CLI](/references/cli#get-started) and log in with [personal access token](/references/cli#personal-access-tokens)
- Install [Wireguard](/references/networking/vpn) on your system
### Setup Steps
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-minimal) and clone it locally
2. **Configure VPN Access**
   ```bash
   # Initialize VPN connection using project ID
   zcli vpn up 
   # Or use interactive mode to select your project
   zcli vpn up
   ```
3. **Set Up Environment**
   ```bash
   # Create and configure environment file
   cp .env.example .env
   ```
   Fill in database access details - in Zerops GUI go to the detail of `db` service and open **Access details** in the left menu.
   ```bash
   composer install
   php artisan key:generate
   ```
4. **Start Development Server**
   ```bash
   php artisan serve # or use your preferred setup (Valet, Herd, Sail)
   ```
Your local environment is now connected to the Zerops infrastructure, utilizing the remote PostgreSQL database while maintaining local development flexibility.
## Application Configuration
Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
## Try the Build & Deploy Pipeline
Now that you're logged into zcli, deploying your application is straightforward. Simply enter `zcli push` in your terminal from the root of your freshly cloned project.
### Test Your Pipeline
The best way to verify your setup is with a quick test:
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in your project detail
### Setting Up Automated CI/CD
To enable automatic deployments:
1. Navigate to **Pipelines & CI/CD settings** in your service dashboard
2. Connect the service with your new GitHub repository
3. Set the trigger to **Push to Branch**
## Integration with Existing Applications
If you're looking to integrate an existing Laravel application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-minimal/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Minimal Prod

This recipe demonstrates how to effectively integrate Laravel applications with Zerops, providing a fully production-grade setup. It's built as a **production environment** with high-availability configuration and uses the [Serious](/features/infrastructure#project-core-options) core package, ensuring enterprise-grade reliability and robust performance.
  Set up a production-ready Laravel environment with high-availability services and enterprise-grade reliability.
  
## Environment Overview
Your newly deployed Laravel environment includes:
- A fully configured Laravel application service with high availability
- PostgreSQL database integration with migration automation
- Automated build and deployment pipeline
- Health and readiness checks
:::note
For development environments with cost-efficient resource allocation, consider deploying the [development environment recipe](/frameworks/laravel/recipes/minimal-devel).
:::
## Application Configuration
The app has been set up to utilize PostgreSQL service. Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
## Try the build & deploy pipeline in 30 seconds
While Zerops supports various CI/CD workflows (CLI, GitHub Actions, built-in CI/CD), let's start with the simplest path to get you familiar with the core concepts:
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-minimal) and clone it locally
2. Navigate to **Pipelines & CI/CD settings** and connect the service with your new GitHub repository, setting the trigger to **Push to Branch**
### Test Your Pipeline
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in project detail
## Integration with Existing Applications
If you're looking to integrate an existing Laravel application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-minimal/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Twill Devel

[Twill](https://twillcms.com/) is a flexible CMS toolkit for Laravel that helps you rapidly create a custom administration interface for your application. It provides a robust set of features including content management, media library, block editor, and a powerful publishing workflow system.
This recipe demonstrates how to effectively integrate Laravel Twill applications with Zerops, providing a fully production-capable setup. While this setup is built for professional deployment, we call it a **development environment** due to its streamlined resource allocation and use of the [Lightweight](/features/infrastructure#project-core-options) core package, optimizing costs without compromising functionality.
  Set up a Laravel environment with Twill's CMS framework in a development-optimized configuration.
  
## Environment Overview
Your newly deployed Laravel Twill environment includes:
- A fully configured Laravel application service with Twill CMS installed
- PostgreSQL database integration with migration automation
- Automated build and deployment pipeline
- Health and readiness checks
- Configured Twill admin interface and media library
:::note
For production environments with high-availability services and enterprise-grade reliability, consider deploying the [production environment recipe](/frameworks/laravel/recipes/minimal-prod).
:::
## Application Configuration
The app has been set up to utilize PostgreSQL service and includes Twill's CMS functionality. Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
- Twill assets compilation
- Media storage configuration
## Try the build & deploy pipeline in 30 seconds
While Zerops supports various CI/CD workflows (CLI, GitHub Actions, built-in CI/CD), let's start with the simplest path to get you familiar with the core concepts:
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-minimal) and clone it locally
2. Navigate to **Pipelines & CI/CD settings** and connect the service with your new GitHub repository, setting the trigger to **Push to Branch**
### Test Your Pipeline
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in project detail
## Integration with Existing Applications
If you're looking to integrate an existing Laravel Twill application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-minimal/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel Twill tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel Twill project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Twill Local

[Twill](https://twillcms.com/) is a flexible CMS toolkit for Laravel that helps you rapidly create a custom administration interface for your application. It provides a robust set of features including content management, media library, block editor, and a powerful publishing workflow system.
This recipe provides a comprehensive Twill CMS setup with PostgreSQL database, Redis-compatible store, object storage, and automated deployment pipeline, designed for **local development** with cost-efficient resource allocation and the [Lightweight](/features/infrastructure#project-core-options) core package. This means:
- Resources are optimized for development workloads
- Services can be started/stopped as needed during active development
- Cost-effective configuration suitable for development and testing
  Set up a Laravel environment with Twill's publishing workflow and media management features for local development.
  
## Environment Overview
Your newly deployed Twill CMS environment includes:
- A fully configured Laravel application service with Twill CMS
- PostgreSQL database integration with migration automation
- Valkey (Redis-compatible KV store) for sessions and cache
- Built-in object storage for filesystem
- Mailpit for development SMTP server
- Automated build and deployment pipeline
- Health and readiness checks
:::note
For production environments with high-availability services and enterprise-grade reliability, consider deploying the [production environment recipe](/frameworks/laravel/recipes/filament-prod).
:::
## What to Expect
The deployment process takes just a few minutes. Once complete, you'll receive:
- A live URL to access your application
- Database credentials
- Access to your project dashboard
- CLI configuration details for VPN access
## Setting Up Local Development
Zerops provides a built-in VPN feature through its CLI tool, enabling seamless local development against remote resources. Here's how to set it up:
### Prerequisites
- Install the [Zerops CLI](/references/cli#get-started) and log in with [personal access token](/references/cli#personal-access-tokens)
- Install [Wireguard](/references/networking/vpn) on your system
### Setup Steps
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-filament) and clone it locally
2. **Configure VPN Access**
   ```bash
   # Initialize VPN connection using project ID
   zcli vpn up 
   # Or use interactive mode to select your project
   zcli vpn up
   ```
3. **Set Up Environment**
   ```bash
   # Create and configure environment file
   cp .env.example .env
   ```
   Fill in database access details - in Zerops GUI go to the detail of `db` service and open **Access details** in the left menu.
   ```bash
   composer install
   php artisan key:generate
   npm install
   npm run dev
   ```
4. **Start Development Server**
   ```bash
   php artisan serve # or use your preferred setup (Valet, Herd, Sail)
   ```
Your local environment is now connected to the Zerops infrastructure, utilizing the database, redis and storage from Zerops while maintaining local development flexibility.
## Application Configuration
The app has been set up to utilize:
- Valkey (Redis-compatible KV store) to handle sessions and cache
- Built-in object storage for Laravel and Twill-specific filesystem operations
- Mailpit as a mock SMTP server for development purposes
Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
## Try the Build & Deploy Pipeline
Now that you're logged into zcli, deploying your application is straightforward. Simply enter `zcli push` in your terminal from the root of your freshly cloned project.
### Test Your Pipeline
The best way to verify your setup is with a quick test:
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in your project dashboard
### Setting Up Automated CI/CD
To enable automatic deployments:
1. Navigate to **Pipelines & CI/CD settings** in your service dashboard
2. Connect the service with your new GitHub repository
3. Set the trigger to **Push to Branch**
## Integration with Existing Applications
If you're looking to integrate an existing Twill application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-twill/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Recipes > Twill Prod

[Twill](https://twillcms.com/) is a flexible CMS toolkit for Laravel that helps you rapidly create a custom administration interface for your application. It provides a robust set of features including content management, media library, block editor, and a powerful publishing workflow system.
This recipe demonstrates how to effectively integrate Laravel Twill applications with Zerops, providing a fully production-grade setup. It's built as a **production environment** with high-availability configuration and uses the [Serious](/features/infrastructure#project-core-options) core package, ensuring enterprise-grade reliability and robust performance.
  Set up a production-ready Laravel environment with Twill's CMS framework, backed by high-availability services and enterprise-grade reliability.
  
## Environment Overview
Your newly deployed Laravel Twill environment includes:
- A fully configured Laravel application service with Twill CMS installed and high availability
- PostgreSQL database integration with migration automation
- Automated build and deployment pipeline
- Health and readiness checks
- Configured Twill admin interface and media library
:::note
For development environments with cost-efficient resource allocation, consider deploying the [development environment recipe](/frameworks/laravel/recipes/minimal-devel).
:::
## Application Configuration
The app has been set up to utilize PostgreSQL service and includes Twill's CMS functionality. Your application's deployment process is managed through [zerops.yaml](/zerops-yaml/specification), which handles:
- Database migrations
- Cache management
- File cleanup
- Health check implementation
- Service orchestration
- Twill assets compilation
- Media storage configuration
## Try the build & deploy pipeline in 30 seconds
While Zerops supports various CI/CD workflows (CLI, GitHub Actions, built-in CI/CD), let's start with the simplest path to get you familiar with the core concepts:
1. Create your own repository from our [GitHub template](https://github.com/zeropsio/recipe-laravel-minimal) and clone it locally
2. Navigate to **Pipelines & CI/CD settings** and connect the service with your new GitHub repository, setting the trigger to **Push to Branch**
### Test Your Pipeline
- Make a small change directly in the GitHub UI
- Commit the change and watch the magic happen in project detail
## Integration with Existing Applications
If you're looking to integrate an existing Laravel Twill application with Zerops, review the [changes made over the default installation](https://github.com/zeropsio/recipe-laravel-minimal/blob/main/README.md#changes-made-over-the-default-installation) to understand the necessary modifications.
## Get to know Zerops core concepts in depth
Ready to build from scratch? Our [step-by-step Laravel Twill tutorial](/frameworks/laravel/introduction) takes you through the entire process of integrating Zerops with a new Laravel Twill project.
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Frameworks > Laravel > Redis

Redis is a powerful in-memory data structure store serving as a database, cache, message broker, and queue. This guide walks you through Redis integration with your Laravel application in Zerops for high-performance caching, session management, and queue processing.
Zerops provides [Valkey](https://valkey.io), an open-source Redis alternative that delivers high-performance key/value storage with full Redis compatibility. Valkey supports all common Redis use cases — from caching and message queues to primary database functionality.
## Adding Redis Service
To use Valkey (Redis) features with Laravel, first either import Valkey as a service to your Zerops project
```yaml
services:
  - hostname: valkey
    type: valkey@7.2
    mode: NON_HA  # use HA in production
```
or add the Valkey service to your project manually from the Zerops GUI.
:::tip High Availability Mode
For production environments, we recommend using `HA` mode. This configuration:
* Ensures automatic failover during node failures
* Provides data replication across multiple nodes
* Improves reliability and uptime
:::
## Environment Configuration
### Basic Redis Settings
Environment variables control how your Laravel application connects to and uses Redis. Below are the core settings grouped by functionality:
```yaml
zerops:
  - setup: app
    build:
      base:
        - php@8.4
      os: alpine
    run:
      base: php-nginx@8.4
      os: alpine
      siteConfigPath: site.conf.tmpl
      envVariables:
        # Redis Connection Settings
        REDIS_CLIENT: phpredis    # PHP Redis client for better performance
        REDIS_HOST: valkey        # Internal hostname of Valkey service
        REDIS_PORT: 6379         # Standard Redis port number
        # Cache Configuration
        CACHE_PREFIX: cache      # Namespace for cache keys
        CACHE_STORE: redis       # Use Redis as primary cache
        # Session Configuration
        SESSION_DRIVER: redis    # Store sessions in Redis
        SESSION_ENCRYPT: false   # Disable session encryption
        SESSION_LIFETIME: 120    # Session timeout in minutes
        SESSION_PATH: /          # Cookie path setting
        # Queue Configuration
        QUEUE_CONNECTION: redis  # Use Redis for job queues
        BROADCAST_CONNECTION: redis  # Redis for event broadcasting
```
## Feature-Specific Configuration
### Redis Caching
Laravel's cache system offers a unified API across different cache backends. The following configuration establishes Redis as your primary cache store for fast, reliable data caching:
```php title="config/cache.php"
'default' => env('CACHE_STORE', 'database'),
'stores' => [
    'redis' => [
        'driver' => 'redis',
        'connection' => env('REDIS_CACHE_CONNECTION', 'cache'),
        'lock_connection' => env('REDIS_CACHE_LOCK_CONNECTION', 'default'),
    ],
],
'prefix' => env('CACHE_PREFIX', Str::slug(env('APP_NAME', 'laravel'), '_').'_cache_'),
```
### Session Management with Redis
Using Redis for session storage provides better performance than file-based sessions and enables seamless session sharing across multiple application servers. You can also set up a custom session connection in the `config/session.php` file.
```php title="config/session.php"
'driver' => env('SESSION_DRIVER', 'redis'),
'lifetime' => env('SESSION_LIFETIME', 120),
'encrypt' => env('SESSION_ENCRYPT', false),
```
### Queue System Configuration
Redis queues offer a robust solution for handling background jobs in Laravel. This configuration sets up Redis as your queue backend with retry policies and connection settings. You can also set up a custom queue connection in the `config/queue.php` file.
```php title="config/queue.php"
'default' => env('QUEUE_CONNECTION', 'redis'),
'connections' => [
    'redis' => [
        'driver' => 'redis',
        'connection' => 'default',
        'queue' => 'default',
        'retry_after' => 90,     // Retry failed jobs after 90 seconds
        'block_for' => null,     // Don't block when no jobs available
    ],
],
```
Consider using [Supervisor](https://laravel.com/docs/5.1/queues#supervisor-configuration) for managing Laravel queues in production.
### Performance Optimization
Configure your Redis connection pool for optimal performance:
```php
'redis' => [
    'client' => env('REDIS_CLIENT', 'phpredis'),
    'options' => [
        'cluster' => env('REDIS_CLUSTER', 'redis'),
        'prefix' => env('REDIS_PREFIX', ''),
        'pool' => [
            'max_connections' => 50,
            'timeout' => 30,
        ],
    ],
],
```
## Working with Redis Features
### Cache Operations Examples
```php
// Store items in cache with expiration time
Cache::put('key', 'value', $seconds);
// Retrieve cached items with optional default value
$value = Cache::get('key');
// Store items indefinitely until manually removed
Cache::forever('key', 'value');
```
### Queue Processing Examples
```php
// Dispatch a job to the Redis queue with specific connection
ProcessPodcast::dispatch($podcast)->onConnection('redis');
// Start the queue worker process for Redis
php artisan queue:work redis
```
### Session Handling Examples
```php
// Store data in the Redis session
session(['key' => 'value']);
// Retrieve data from the session with optional default
$value = session('key');
```

----------------------------------------

# Frameworks > Laravel > Smtp

# SMTP Configuration for Laravel in Zerops
:::warning Important Security Note
By default, SMTP ports are blocked by Zerops firewall for security reasons. To use external SMTP services, please [contact Zerops support](mailto:support@zerops.io) to have the necessary ports opened for your project.
Include in your request:
* Detailed explanation of your use case
* Specific ports and protocols needed
* Project ID and Organization ID from your Zerops Dashboard
:::
## Production Configuration
### Laravel Mail Configuration
Laravel comes with a default mail configuration in `config/mail.php`. You typically don't need to modify this file as all settings can be controlled through environment variables.
The default configuration supports multiple mailer types and reads all sensitive information from your environment. In this example
    
```php title="config/mail.php"
return [
    'default' => env('MAIL_MAILER', 'smtp'),
    'mailers' => [
        'smtp' => [
            'transport' => 'smtp',
            'url' => env('MAIL_URL'),
            'host' => env('MAIL_HOST', '127.0.0.1'),
            'port' => env('MAIL_PORT', 587),
            'encryption' => env('MAIL_ENCRYPTION', 'tls'),
            'username' => env('MAIL_USERNAME'),
            'password' => env('MAIL_PASSWORD'),
            'timeout' => null,
            'local_domain' => env('MAIL_EHLO_DOMAIN'),
        ],
        'ses' => [
            'transport' => 'ses',
        ],
        'postmark' => [
            'transport' => 'postmark',
        ],
        'failover' => [
            'transport' => 'failover',
            'mailers' => [
                'smtp',
                'log',
            ],
        ],
    ],
    'from' => [
        'address' => env('MAIL_FROM_ADDRESS', 'hello@example.com'),
        'name' => env('MAIL_FROM_NAME', 'Example'),
    ],
];
```
:::tip Available Mail Transports
Laravel supports multiple mail transport options:
- 'smtp' - Standard SMTP server
- 'sendmail' - Server's sendmail
- 'mailgun' - Mailgun API
- 'ses' - Amazon SES
- 'postmark' - Postmark
- 'log' - Log messages for testing
- 'array' - Store in array for testing
- 'failover' - Fallback to next mailer if one fails
- 'roundrobin' - Rotate between multiple mailers
:::
### Environment Configuration
Configure your Laravel service with the required mail variables. The following example shows SMTP configuration, but most settings are common across different mail transports:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    run:
      envVariables:
        MAIL_MAILER: smtp
        MAIL_FROM_ADDRESS: noreply@yourdomain.com
        MAIL_FROM_NAME: YourApp
        MAIL_HOST: your-smtp-host
        MAIL_PORT: 587
        MAIL_USERNAME: your-username
        MAIL_PASSWORD: your-password
        MAIL_ENCRYPTION: tls
```
If using other mail transports, you might need additional environment variables. Refer to Laravel's Mail documentation for transport-specific configuration.
## Implementing Email Functionality
### Creating Mail Classes
Generate a new mail class using Artisan:
```bash
php artisan make:mail WelcomeEmail
```
```php title="app/Mail/WelcomeEmail.php"
view('emails.welcome')
                    ->subject('Welcome to ' . config('app.name'));
    }
}
```
### Email Template
Create a blade template for your email content:
```php title="resources/views/emails/welcome.blade.php"
# Welcome {{ $user->name }}
Thanks for joining our application!
Visit Dashboard
Thanks,
{{ config('app.name') }}
```
### Sending Emails
You can send emails either immediately or using a queue:
```php
use Illuminate\Support\Facades\Mail;
use App\Mail\WelcomeEmail;
// Send immediately
Mail::to($user->email)->send(new WelcomeEmail($user));
// Send using queue
Mail::to($user->email)->queue(new WelcomeEmail($user));
```
## Queue Configuration
For production environments, it's recommended to use a queue system for sending emails to prevent request timeouts and improve application performance. Zerops provides Valkey, an open-source Redis-compatible service that's perfect for handling email queues.
First, add the Valkey service to your project:
```yaml
services:
  - hostname: redis
    type: valkey@7.2
    mode: NON_HA  # use HA for high availability in production
```
Configure your Laravel service to use Redis for queues:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    run:
      envVariables:
        # Queue Configuration
        QUEUE_CONNECTION: redis
        REDIS_HOST: redis
        REDIS_PORT: 6379
        REDIS_CLIENT: phpredis # PHP Redis client for better performance
        # Mail Configuration
        MAIL_MAILER: smtp
        MAIL_HOST: your-smtp-host.com
        MAIL_PORT: 587
        MAIL_USERNAME: your-username
        MAIL_PASSWORD: your-password
        MAIL_ENCRYPTION: tls
        MAIL_FROM_ADDRESS: noreply@yourdomain.com
        MAIL_FROM_NAME: YourApp
```
You can customize the queue behavior in your `config/queue.php`:
```php title="config/queue.php"
phpCopy'default' => env('QUEUE_CONNECTION', 'redis'),
'connections' => [
    'redis' => [
        'driver' => 'redis',
        'connection' => 'default',
        'queue' => 'default',
        'retry_after' => 90,     // Retry failed jobs after 90 seconds
        'block_for' => null,     // Don't block when no jobs available
    ],
],
```
## Development Environment
For local development and testing, Zerops provides a Mailpit service that allows you to catch and inspect all outgoing emails.
### Setting up Mailpit
Add this to your project import configuration or import the service separately:
```yaml
services:
  - hostname: mailpit
    type: go@1
    buildFromGit: https://github.com/zeropsio/recipe-mailpit
    enableSubdomainAccess: true
```
See [Mailpit recipe repo](https://github.com/zeropsio/recipe-mailpit) for reference.
Configure your Laravel service to use Mailpit for development:
```yaml
zerops:
  - setup: app
    run:
      envVariables:
        MAIL_MAILER: smtp
        MAIL_HOST: mailpit
        MAIL_PORT: 1025
        MAIL_FROM_ADDRESS: hello@example.com
        MAIL_FROM_NAME: ZeropsLaravel
```
:::tip
Enable `enableSubdomainAccess` to access the Mailpit web interface where you can view all emails during development.
:::
## Best Practices
- Use queue for sending emails in production to prevent request timeouts
- Configure proper timeouts for SMTP connections
- Use environment variables for all mail settings
- Implement proper error handling for failed email deliveries
- Test email templates across different email clients
- Monitor email delivery rates and bounce rates
- Use Mailpit in development to catch and debug emails

----------------------------------------

# Gleam > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Gleam application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: gleam@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customise the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - npm i
        - npm run build
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - dist
        - package.json
        - node_modules
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      cache: node_modules
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: gleam@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 3000
      # OPTIONAL. Customise the runtime Gleam environment by installing additional
      # dependencies to the base Gleam runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Gleam application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your Gleam application start command
      start: npm start
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Gleam builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: gleam@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  major version of Gleam, Zerops command line tool, `npm`, `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - gleam@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customise your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customises the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of Gleam defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `npm`, `yarn`, `git` and `npx` tools
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: gleam@latest
      # OPTIONAL. Customise the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/gleam/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: gleam@latest
      # OPTIONAL. Build your application
      buildCommands:
        - npm i
        - npm run build
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
buildCommands:
  - |
    npm i
    npm run build
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
buildCommands:
  - npm i
  - npm run build
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/gleam/how-to/logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the --verbose option.
```yaml
buildCommands:
  - npm i --verbose
  - npm run build
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - dist
  - package.json
  - node_modules
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - dist
  - package.json
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: gleam@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/gleam/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Gleam version for your runtime.
Following options are available for Gleam runtimes:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: gleam@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: gleam@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of Gleam, Zerops command line tool, `npm`, `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: gleam@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - gleam@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customise your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Gleam service with hostname = "app" and port = 3000 from another service of the same project, simply use `app:3000`. Read more about [how to access a Gleam service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
| parameter   | description                                                                                                                                                                                                                                                                                                            |
| ----------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| port        | Defines the port number. You can set any port number between _10_ and _65435_. Ports outside this interval are reserved for internal Zerops systems.                                                                                                                                                                   |
| protocol    | **Optional.** Defines the protocol. Allowed values are `TCP` or `UDP`. Default value is `TCP`.                                                                                                                                                                                                                         |
| httpSupport | **Optional.** `httpSupport = true` is the default setting for TCP protocol. Set `httpSupport = false` if a web server isn't running on the port. Zerops uses this information for the configuration of [public access](/features/access). `httpSupport = true` is available only in combination with the TCP protocol. |
| httpSupport | **Optional.** `httpSupport = true` is the default setting for TCP protocol. Set `httpSupport = false` if a web server isn't running on the port. Zerops uses this information for the configuration of [public access](/features/access). `httpSupport = true` is available only in combination with the TCP protocol. |
### prepareCommands
_OPTIONAL._ Customises the Gleam runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Gleam environment contains {data.alpine.default} the selected
  major version of Gleam, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools. To install
  additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Gleam runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/gleam/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the custom runtime cache go to `yyy`
When the custom runtime cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the
  selected major version of Gleam, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Gleam runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Gleam application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Gleam application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/gleam/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/gleam/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/gleam/how-to/env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your Gleam application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Gleam application start command
      start: npm start
```
We recommend starting your Gleam application using `npm start`.
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Gleam application start command
      start: npm start
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
| Parameter   | Description                                                                                                                                                                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **command** | Defines a local command to be run.
The command has access to the same [environment variables](/gleam/how-to/create#set-secret-environment-variables) as your Gleam application.
A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below. |
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Gleam application start command
      start: npm start
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/gleam/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
<table className="w-full my-1.5">
  <thead>
    <tr>
      <th className="w-fit whitespace-nowrap">Parameter</th>
      <th className="w-fit whitespace-nowrap">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">port</td>
      <td>Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on <code>{'http://127.0.0.1:{port}/{path}'}</code></td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">path</td>
      <td>Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on <code>{'http://127.0.0.1:{port}/{path}'}</code></td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">host</td>
      <td><strong>Optional.</strong> The readiness check is triggered from inside of your runtime container so it always uses the localhost <code>127.0.0.1</code>. If you need to add a <code>host</code> to the request header, specify it in the <code>host</code> attribute.</td>
    </tr>
    <tr>
      <td className="w-fit whitespace-nowrap font-semibold">scheme</td>
      <td><strong>Optional.</strong> The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set <code>scheme: https</code></td>
    </tr>
  </tbody>
</table>
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/gleam/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
| Parameter   | Description                                                                                                                                                                                                                                                                                                                     |
| ----------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **command** | Defines a local command to be run.
The command has access to the same [environment variables](/gleam/how-to/create#set-secret-environment-variables) as your Gleam application.
A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below. |
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/gleam/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Gleam > How To > Build Process



----------------------------------------

# Gleam > How To > Controls



----------------------------------------

# Gleam > How To > Create

Zerops provides a powerful Gleam runtime service with extensive build support. The Gleam runtime is highly scalable and customizable to suit your development and production needs. With just a few clicks or commands, you can have a production-ready Gleam environment up and running in no time.
## Create a Gleam service using Zerops GUI
First, set up a project in the Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu under the **Services** section. From there, you can add a new Gleam service:
### Choose a Gleam version
Zerops supports the following Gleam versions:
:::info
You can easily [upgrade](/gleam/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app", "cache", "gui", etc. Duplicate services with the same name within the same project are not allowed.
#### Limitations:
- Maximum 25 characters
- Must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created and cannot be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as passwords, tokens, salts, certificates, etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting secret environment variables is optional. You can always set them later in the Zerops GUI.
Read more about the [different types of environment variables](/gleam/how-to/env-variables#service-env-variables) in Zerops.
## Create a Gleam service using zCLI
zCLI is the Zerops command-line tool. To create a new Gleam service via the command line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/gleam/how-to/create#create-a-project-description-file)
3. [Create a project with a Gleam and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a YAML format to describe the project infrastructure.
#### Basic example:
Create a directory called `my-project`. Inside the `my-project` directory, create a `description.yaml` file with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in gleam@{version} format
    type: gleam@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Gleam version 20 service with default [auto scaling](/gleam/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/gleam/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Gleam and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in gleam@{version} format
    type: gleam@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Gleam service and a [PostgreSQL](/postgresql/overview) service.
Gleam service with "app" hostname, the internal port(s) the service listens on will be defined later in the [zerops.yaml](/gleam/how-to/build-pipeline#ports). Gleam service will run on version 20 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
| Parameter       | Description                                                                                                                     | Limitations             |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------- | ----------------------- |
| **name**        | The name of the new project. Duplicates are allowed.                                                                            |                         |
| **description** | **Optional.** Description of the new project.                                                                                   | Maximum 255 characters. |
| **tags**        | **Optional.** One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects. |
| **tags**        | **Optional.** One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects. |
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains Gleam and PostgreSQL services but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
        hostname
      
        The unique service identifier.
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
        type
      
        Specifies the service type and version.
        
        See what [Gleam service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
        verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        All verticalAutoscaling attributes are optional. Not specified
        attributes will be set to their default values.
      
         - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
         - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
         - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
         - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
        minContainers
      
        Optional. Default = 1. Defines the minimum number of containers
        for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        envSecrets
      
        Optional. Defines one or more secret env variables as a key value
        map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Gleam service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in gleam@{version} format
    type: gleam@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Gleam service version 20 with default [auto scaling](/gleam/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Gleam > How To > Customize Runtime

System packages for processing: When your app processes images, videos, or files (requiring packages like sudo apk add imagemagick)',
  'Erlang libraries: When you need additional Erlang libraries for your Gleam application',
  'Native dependencies: When your Gleam dependencies require system libraries that aren\'t in the default environment',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />

----------------------------------------

# Gleam > How To > Delete



----------------------------------------

# Gleam > How To > Deploy Process



----------------------------------------

# Gleam > How To > Env Variables



----------------------------------------

# Gleam > How To > Filebrowser



----------------------------------------

# Gleam > How To > Logs



----------------------------------------

# Gleam > How To > Scaling



----------------------------------------

# Gleam > How To > Shared Storage



----------------------------------------

# Gleam > How To > Trigger Pipeline



----------------------------------------

# Gleam > How To > Upgrade



----------------------------------------

# Gleam > Overview

[Gleam ↗](https://gleam.org/en) is an asynchronous event-driven JavaScript runtime, which is designed to build scalable network applications.
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-gleam), a **_recipe_**, containing the most simple Gleam web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of Gleam app running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-gleam/blob/main/zerops-project-import.yaml)):
```yaml
project:
  name: recipe-gleam
  tags:
    - zerops-recipe
services:
  - hostname: api
    type: gleam@1.5
    enableSubdomainAccess: true
    buildFromGit: https://github.com/zeropsio/recipe-gleam
  - hostname: db
    type: postgresql@16
    mode: NON_HA
    priority: 1
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://api-808-3000.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
{"message":"This is a simple Gleam application running in Zerops.io, each request adds an entry to the PostgreSQL database and returns a count. See the source repository (https://github.com/zeropsio/recipe-gleam) for more information.","newEntry":"e64be640-d6c2-4be8-93ac-d1e40e56fa06","count":1}
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
It doesn't matter whether it's your first curious introduction to Zerops, you have already mastered the basics and are looking for a tiny detail or inspiration. Below, choose a section that fits your needs:
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Go > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Go application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: go@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - go build -o app main.go
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles: app
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      # cache: some_file
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: go@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 8080
      # OPTIONAL. Customize the runtime Go environment by installing additional
      # dependencies to the base Go runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Go application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your Go application start command
      start: ./app
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Go builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: go@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  version of Go, Zerops command line tool, `git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - go@latest
      prepareCommands:
        - zsc add nodejs@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customize your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customized.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customizes the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of Go defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `git` and `wget`
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: go@latest
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/go/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: go@latest
      # OPTIONAL. Build your application
      buildCommands:
        - go build -o app main.go
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it. Suppose your `main.go` file is in a `src` directory.
```yaml
buildCommands:
  - |
    cd src
    go build -o app main.go
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command. Suppose your `main.go` file is in a `src` directory.
```yaml
buildCommands:
  - cd src
  - go build -o app src/main.go
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/go/how-to/logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the --verbose option.
```yaml
buildCommands:
  - go build -v -o app main.go
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - app
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - app
  - file.txt
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: go@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        GO_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/go/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Go version for your runtime.
Following options are available for Go builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: go@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: go@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of Go, Zerops command line tool, `git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: go@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - go@latest
      prepareCommands:
        - zsc add nodejs@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customise your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Go service with hostname = "app" and port = 8080 from another service of the same project, simply use `app:8080`. Read more about [how to access a Go service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customises the Go runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Go environment contains {data.alpine.default}, the selected
  major version of Go, Zerops command line tool and `git` and `wget`. To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Go runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/go/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
When the prepare cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the
  selected major version of Go, Zerops command line tool and `git` and `wget`.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Go runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Go application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Go application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/go/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/go/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        GO_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/go/how-to/env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your Go application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Go application start command
      start: ./app
```
We recommend starting your Go application using `./app`.
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Go application start command
      start: ./app
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Go application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Go application start command
      start: ./app
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/go/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/go/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Go application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/go/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Go > How To > Build Process



----------------------------------------

# Go > How To > Controls



----------------------------------------

# Go > How To > Create

Zerops provides a Go runtime service with extensive build support. Go runtime is highly scalable and customisable to suit both development and production.
## Create Go service using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new Go service:
### Choose Go version
Following Go versions are currently supported:
:::info
You can [change](/go/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app","cache", "gui" etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
- maximum 25 characters
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created. It can't be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as password, tokens, salts, certificates etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting the secret environment variables is optional. You can set them later in Zerops GUI.
Read more about [different types of env variables](/go/how-to/env-variables#service-env-variables) in Zerops.
## Create Go service using zCLI
zCLI is the Zerops command-line tool. To create a new Go service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/go/how-to/create#create-a-project-description-file)
3. [Create a project with a Go and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a yaml format to describe the project infrastructure.
#### Basic example:
Create a directory `my-project`. Create an `description.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in go@{version} format
    type: go@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Go version 1 service with default [auto scaling](/go/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/go/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Go and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in go@{version} format
    type: go@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create secret env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Go service and a [PostgreSQL](/postgresql/overview) service.
Go service with "app" hostname, the internal port(s) the service listens on will be defined later in the zerops.yaml. Go service will run on version 1 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
         
        The hostname of the new database will be set to the `hostname` value.
         
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the service type and version.
        
        See what [Go service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
      verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
      - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
      - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
      - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
      - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
      minContainers
      
        Optional. Default = 1. Defines the minimum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      envSecrets
      
        Optional. Defines one or more secret env variables as a key value map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Go service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in go@{version} format
    type: go@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Go service version 1 with default [auto scaling](/go/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Go > How To > Customize Runtime

System packages for processing: When your app processes images, videos, or files (requiring packages like sudo apk add imagemagick)',
  'CGO dependencies: When you use CGO and need C libraries not included in the default environment',
  'Development tools: When you need debugging tools, profilers, or other development utilities',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />

----------------------------------------

# Go > How To > Delete



----------------------------------------

# Go > How To > Deploy Process



----------------------------------------

# Go > How To > Env Variables



----------------------------------------

# Go > How To > Filebrowser



----------------------------------------

# Go > How To > Logs



----------------------------------------

# Go > How To > Scaling



----------------------------------------

# Go > How To > Shared Storage



----------------------------------------

# Go > How To > Trigger Pipeline



----------------------------------------

# Go > How To > Upgrade



----------------------------------------

# Go > Overview

[Go ↗](https://go.dev/) is a statically typed, compiled high-level programming language designed at Google.
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-go-hello-world), a **_recipe_**, containing the most simple Go web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of Go running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-go-hello-world/blob/main/import-project/description.yaml)):
```yaml
project:
  name: my-first-project
services:
  - hostname: helloworld
    type: go@latest
    minContainers: 1
    maxContainers: 3
    buildFromGit: https://github.com/zeropsio/recipe-go-hello-world@main
    enableSubdomainAccess: true
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://helloworld-24-8080.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
Hello, World!
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Homepage

export const runtimes = [
    { name: "Node.js", link: "/nodejs/overview", icon:  },
    { name: "PHP", link: "/php/overview", icon:  },
    { name: "Python", link: "/python/overview", icon:  },
    { name: "Go", link: "/go/overview", icon:  },
    { name: ".NET", link: "/dotnet/overview", icon:  },
    { name: "Rust", link: "/rust/overview", icon:  },
    { name: "Java", link: "/java/overview", icon:  },
    { name: "Deno", link: "/deno/overview", icon:  },
    { name: "Bun", link: "/bun/overview", icon:  },
    { name: "Elixir", link: "/elixir/overview", icon:  },
    { name: "Gleam", link: "/gleam/overview", icon:  },
    { name: "Nginx", link: "/nginx/overview", icon:  },
    { name: "Static", link: "/static/overview", icon:  },
]
export const containers = [
    { name: "Ubuntu", link: "/ubuntu/overview", icon:  },
    { name: "Alpine", link: "/alpine/overview", icon:  },
    { name: "Docker", link: "/docker/overview", icon:  },
]
export const databases = [
    { name: "PostgreSQL", link: "/postgresql/overview", icon:  },
    { name: "MariaDB", link: "/mariadb/overview", icon:  },
    { name: "Valkey", link: "/valkey/overview", icon:  },
    { name: "Elasticsearch", link: "/elasticsearch/overview", icon:  },
    { name: "Typesense", link: "/typesense/overview", icon:  },
    { name: "Meilisearch", link: "/meilisearch/overview", icon:  },
    { name: "Qdrant", link: "/qdrant/overview", icon:  },
    { name: "NATS", link: "/nats/overview", icon:  },
    { name: "Kafka", link: "/kafka/overview", icon:  },
    { name: "ClickHouse", link: "/clickhouse/overview", icon:  },
    { name: "KeyDB", link: "/keydb/overview", icon:  },
]
export const storages = [
    { name: "Object storage", link: "/object-storage/overview", icon:  },
    { name: "Shared storage", link: "/shared-storage/overview", icon:  },
]
Zerops is a **developer-first Platform-as-a-Service**, running on bare metal, with every part built from scratch. Zerops aims to be the perfect mix of **developer experience**, **flexibility**, **scalability** and **affordability**, making it a great fit for applications of any size, complexity and traffic.
## Natively supported services
### Runtimes & web servers
For these services Zerops provides pre-prepared build and runtime images and flexible pipeline that allows you to modify them and build your applications.
### Linux containers & VMs
These services can be deployed either as plain Linux containers or using Docker images, giving you flexibility to run any application or service.
### Databases, search engines & message brokers
These services are fully managed by Zerops and offered in highly available and single container modes.
### Storages
Fully managed S3 compatible storage running on a separate infrastructure and persistent disk that can be mounted to multiple services.
## Quicklinks
## Feature highlights
Four concepts that play together to make Zerops developer-first and live up to the claim "no matter the size or environment".
### ➡️ Custom dedicated infrastructure deployed with each project
Zerops is made of three levels: **project** -> **service** -> **container**. For each project Zerops deploys dedicated **core services**, these consist of:
- **L3 balancer** with a firewall and unique IP addresses assigned to it, this serves as the main entry point from the internet,
- **Logger** and **Statistics** containers that gather logs and resource metrics from all services inside the project and allow for log forwarding
- **L7 load balancer** that handles and routes http traffic, SSL termination and SSL certificates
User services (which consist of one or more containers) inside the project share a private network created with VXLAN, have resources isolated with cgroups and can securely communicate with each other simply by using the hostname and ports and read and reference each other's environment variables.
:::tip[**What does this mean for you?**]
You get a fully managed, professional infrastructure setup that will scale no matter how much traffic you get and deals with all the networking, balancing and security stuff, so you can just focus on your actual applications.
Read more about the project infrastructure
:::
### ➡️ Granular resource configuration, autoscaling and high availability of services
Zerops has fully automatic horizontal and vertical scaling with configuration steps as small as 0.125 GB RAM and 1 CPU core. Your runtime services can go from a single container with 0.25 RAM and 1 CPU core to 10 containers each with 32 GB RAM and 10 CPU cores and then back in a matter of minutes. At the same time, all database and storage services are offered in well-crafted setups that go through performance optimizations while scaling and are available in both non-HA (single container) and high availability (multiple containers and balancers) modes.
:::tip[**What does this mean for you?**]
You won't ever overprovision or underprovision your resources and your services will always have the exact resources they need. There won't be any cutting corners like sharing too few CPU cores between too many services. You will be able to rely on professional, reliable and highly available database setups with auto-repairing abilities that will scale along with your applications.
Read more about autoscaling and high availability
:::
### ➡️ Full Linux OS containers with a powerful, flexible build and deploy pipeline
Zerops uses Incus to create containers, which means that you get a full Linux OS, either Ubuntu or Alpine, depending on your choices. This provides the perfect middle ground between a containerized process (Docker) and a full-fledged VM (Proxmox). Zerops provides build and runtime bases for all the popular runtime technologies and a powerful and flexible pipeline that allows you to modify and cache both the build and runtime images. This circumvents the need for Docker registries. The pipeline can be triggered either automatically, by connecting the service with GitHub or GitLab repositories, or manually using our CLI - either for triggering from your machine, or from any existing CI/CD process.
:::tip[**What does this mean for you?**]
You get a built-in powerful and flexible pipeline to modify build and runtime images and deploy your code, without any downtime. It can be used standalone or easily plugged into any existing CI/CD process.
Read more about the build and deploy pipeline
:::
### ➡️ Pricing model that doesn't get in the way of good development practices
"Simple and predictable pricing"... is what others say and what we actually do. In Zerops, cost per hardware resource (CPU, RAM, Disk) is 3-5x cheaper than with popular alternatives. And there are no plans, no feature tiers, no fees for seats. PaaS is just hardware with a cherry and bow on top, so why would we charge you for anything else but hardware resources?
:::tip[**What does this mean for you?**]
You get a powerful managed platform with all the best features unlocked for a price that's nearly on par with VPS. You can create as many environments as you need, even one for each developer working on a project, all with the same infrastructure as production, so they can utilize Zerops for their local development. No more "but it works on my machine".
:::

----------------------------------------

# Java > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Java application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: java@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - ./mvnw clean install
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles: target/app.jar
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      # cache: some_file
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: java@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 8080
      # OPTIONAL. Customize the runtime Java environment by installing additional
      # dependencies to the base Java runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Java application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your Java application start command
      start: java -jar target/app.jar
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Java builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: java@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected version
  of Java, Zerops command line tool, `git` and
  `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - java@latest
      prepareCommands:
        - zsc add nodejs@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customize your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customized.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customizes the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of Java defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `git` and `wget`
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: java@latest
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/java/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: java@latest
      # OPTIONAL. Build your application
      buildCommands:
        - ./mvnw clean install
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it. Suppose your `mvnw` executable file is in a `cmd` directory.
```yaml
buildCommands:
  - |
    cd cmd
    ./mvnw clean install
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command. Suppose your `mvnw` executable file is in a `cmd` directory.
```yaml
buildCommands:
  - cd cmd
  - ./cmd/mvnw clean install
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/java/how-to/logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the `-X` debug option.
```yaml
buildCommands:
  - ./mvnw -X clean install
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - app.jar
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - api
  - app.jar
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: java@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/java/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Java version for your runtime.
Following options are available for Java builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: java@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: java@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the selected major
  version of Java, Zerops command line tool, git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: java@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - java@latest
      prepareCommands:
        - zsc add nodejs@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customize your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customized.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Java service with hostname = "app" and port = 8080 from another service of the same project, simply use `app:8080`. Read more about [how to access a Java service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customizes the Java runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Java environment contains {data.alpine.default}, the selected major
  version of Java, Zerops command line tool and
  `git` and `wget`. To install additional packages or tools add one or more
  prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Java runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/java/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
When the prepare cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the selected
  major version of Java, Zerops command line tool and `git` and `wget`.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Java runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Java application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Java application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/java/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/java/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/java/how-to/env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your Java application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Java application start command
      start: java -jar target/app.jar
```
We recommend starting your Java application using `java -jar target/app.jar`.
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Java application start command
      start: java -jar target/app.jar
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Java application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Java application start command
      start: java -jar target/app.jar
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/java/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/java/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Java application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/java/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Java > How To > Build Process



----------------------------------------

# Java > How To > Controls



----------------------------------------

# Java > How To > Create

Zerops provides a Java runtime service with extensive build support. Java runtime is highly scalable and customisable to suit both development and production.
## Create Java service using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new Java service:
### Choose Java version
Following Java versions are currently supported:
:::info
You can [change](/java/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app","cache", "gui" etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
- maximum 25 characters
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created. It can't be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as password, tokens, salts, certificates etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting the secret environment variables is optional. You can set them later in Zerops GUI.
Read more about [different types of env variables](/java/how-to/env-variables#service-env-variables) in Zerops.
## Create Java service using zCLI
zCLI is the Zerops command-line tool. To create a new Java service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/java/how-to/create#create-a-project-description-file)
3. [Create a project with a Java and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a yaml format to describe the project infrastructure.
#### Basic example:
Create a directory `my-project`. Create an `description.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in java@{version} format
    type: java@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Java version 1 service with default [auto scaling](/java/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/java/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Java and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in java@{version} format
    type: java@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create secret env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Java service and a [PostgreSQL](/postgresql/overview) service.
Java service with "app" hostname, the internal port(s) the service listens on will be defined later in the zerops.yaml. Java service will run on version 1 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
         
        The hostname of the new database will be set to the `hostname` value.
         
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the service type and version.
        
        See what [Java service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
      verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
      - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
      - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
      - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
      - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
      minContainers
      
        Optional. Default = 1. Defines the minimum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      envSecrets
      
        Optional. Defines one or more secret env variables as a key value map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Java service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in java@{version} format
    type: java@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Java service version 1 with default [auto scaling](/java/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Java > How To > Customize Runtime

Build tools: When you need Maven, Gradle, or other build tools not included by default',
  'Native libraries: When your Java dependencies require system libraries that aren\'t in the default environment',
  'Application servers: When you need Tomcat, Jetty, or other application servers',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />

----------------------------------------

# Java > How To > Delete



----------------------------------------

# Java > How To > Deploy Process



----------------------------------------

# Java > How To > Env Variables



----------------------------------------

# Java > How To > Filebrowser



----------------------------------------

# Java > How To > Logs



----------------------------------------

# Java > How To > Scaling



----------------------------------------

# Java > How To > Shared Storage



----------------------------------------

# Java > How To > Trigger Pipeline



----------------------------------------

# Java > How To > Upgrade



----------------------------------------

# Java > Overview

# Java overview
[Java ↗](https://www.java.com/en/) is a high-level, class-based, object-oriented programming language that is designed to have as few implementation dependencies as possible.
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-java-hello-world), a **_recipe_**, containing the most simple Java web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of Java running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-java-hello-world/blob/main/import-project/description.yaml)):
```yaml
project:
  name: my-first-project
services:
  - hostname: helloworld
    type: java@latest
    minContainers: 1
    maxContainers: 3
    buildFromGit: https://github.com/zeropsio/recipe-java-hello-world@main
    enableSubdomainAccess: true
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://helloworld-24-8080.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
Hello, World!
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Kafka > Overview

Zerops provides a fully managed [Apache Kafka](https://kafka.apache.org/) messaging platform with automated scaling and zero infrastructure overhead, letting developers focus entirely on development.
## Supported Versions
Currently supported Kafka version:
Import configuration version:
## Service Configuration
Our Kafka implementation features optimized default settings designed for common use cases.
### Key Configuration
* **Client Connections:** Data brokers available on port `9092`
* **Authentication:** Secure SASL PLAIN with automatically generated credentials
* **Data Persistence:** Topic data stored indefinitely (no time or size limit)
* **Performance:** Optimized settings for reliability and throughput
### Resource Allocation
Zerops automatically allocates resources to your Kafka service based on demand:
* **Memory:** Up to 40GB RAM for high-performance message processing
* **Storage:** Up to 250GB for persistent storage of messages and logs
* **Auto-scaling:** Resources scale up and down automatically based on workload
## Deployment Modes
:::important
Deployment mode is selected during service creation and cannot be changed later.
:::
### High-Availability (HA) Setup
The recommended solution for production workloads and mission-critical data:
* Creates a multi-node Kafka cluster with 3 broker nodes
* Configures 6 partitions across the cluster
* Implements replication factor of 3 (each broker node has a copy of each partition)
* Default topic replication is also 3 (overridable by user application)
* Zerops automatically attempts to repair the cluster and data replication in case of a node failure
### Single Node Instance
Suitable for development and testing environments:
* Consists of 1 broker node
* Configures 3 partitions
* No data replication
* Lower resource requirements
:::note
Use for development or non-critical data only, as data loss may occur due to container volatility.
:::
## Authentication Management
Authentication credentials are automatically generated and managed by the platform using SASL PLAIN authentication.
**Access your credentials through:**
* The service access details in the Zerops GUI
* Environment variables in your service configuration:
  * `user` - Username for authentication
  * `password` - Generated secure password
  * `port` - Kafka port (value: `9092`)
## Client Access
Client implementations differ, please refer to your chosen client's configuration manual for specific details.
### Access Methods
#### Seed Broker Connection
Connect to the Kafka cluster using the "seed" (or "bootstrap") broker server:
```
:9092
```
#### Specific Broker Access
To access a single specific broker or a list of all/some brokers:
```
node-stable-1.db..zerops:9092,node-stable-2.db..zerops:9092,...
```
## Best Practices
### Production Workloads
* Use HA mode for all production deployments
* Configure proper retention policies for your topics based on your data requirements
* Monitor consumer lag to ensure messages are being processed efficiently
* Use consumer groups to distribute processing load
### Development Environments
* Single node instances are suitable for development and testing
* Be aware of potential data loss in non-HA deployments
* Consider using smaller message sizes during development to reduce resource usage
## Support
For advanced configurations or custom requirements:
* Join our [Discord community](https://discord.gg/zerops)
* Contact support via [email](mailto:support@zerops.io)

----------------------------------------

# Keydb > How To > Connect

## Copy access details from Zerops GUI
You will find the KeyDB access details under the **Access details** button in the project dashboard page.
The same information is available in the service detail page in the left menu under the **Peek access details** button.
### KeyDB access parameters:
| Parameter             | Description                                                                      |
| --------------------- | -------------------------------------------------------------------------------- |
| **Hostname**          | The service hostname specified when the KeyDB service was created.               |
| **Hostname**          | The service hostname specified when the KeyDB service was created.               |
| **Port**              | **6379**
This port is fixed for all KeyDB services and cannot be customized. |
| **Connection string** | The connection string for KeyDB service is:
`redis://{hostname}:6379`        |
## Connect to KeyDB from runtime services of the same project
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
#### Example
To connect to KeyDB `database1` service, set
```
host = database1
```
You will find the password under the [**Access details**](#copy-access-details-from-zerops-gui) button in Zerops GUI.
:::caution
Do not use SSL/TLS protocols when connecting to KeyDB from other runtime services in the same project. Zerops KeyDB is not configured to support these protocols. The security is assured by the project private network. Due to security reasons Zerops doesn't allow exposing KeyDB service to the internet.
:::
## Use KeyDB environment variables
Zerops creates default environment variables for each KeyDB service to help you with connection from runtime services in the same project. To avoid the need to copy database access parameters manually, use environment variables in your [runtime service].
### Prefix the environment variable key
All services of the same project can reference environment variables from other services. To use an environment variable from one service in another service in the same project, you must prefix the environment variable key with the service hostname and underscore.
#### Example
To access the `connectionString` env variable of the `keydb1` service, use `keudb1_connectionString` as the env variable key.
### KeyDB environment variables
List of service environment variables is available in Zerops GUI. Go to a KeyDB service detail and choose **Environment variables** in the left menu.
Zerops creates following environment variables when the KeyDB service is created:
| Variable              | Description                                                                      |
| --------------------- | -------------------------------------------------------------------------------- |
| **Hostname**          | The service hostname specified when the KeyDB service was created.               |
| **Hostname**          | The service hostname specified when the KeyDB service was created.               |
| **Port**              | **5432**
This port is fixed for all KeyDB services and cannot be customized. |
| **projectId**         | ID of the project. Generated by Zerops.                                          |
| **serviceId**         | ID of the KeyDB service. Generated by Zerops.                                    |
| **Connection string** | The connection string for KeyDB service is:
`redis://{hostname}:6379`        |
You can create own custom [environment variables](/features/env-variables) for the KeyDB service in Zerops GUI and use them in the same way as the default variables.
## Connect to KeyDB in Zerops remotely
:::caution
Due to security reasons Zerops doesn't allow exposing KeyDB service directly to the internet.
:::
### Start VPN connection
You can securely connect to KeyDB from your local workspace via Zerops VPN. Zerops VPN client is included into zCLI, the Zerops command-line tool. To start a VPN connection to the selected Zerops project, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Start the Zerops VPN](/references/networking/vpn#start-vpn)
### Access KeyDB through VPN
Once the VPN session is established, you have the secured connection to the project's private network in Zerops. You can access all project services locally by using their hostname. The only difference is that no [environment variables](#use-keydb-environment-variables) are available when connected through VPN. To connect to KeyDB in Zerops you have to copy the [access details](#copy-access-details-from-zerops-gui) manually from Zerops GUI.
:::caution
Do not use SSL/TLS protocols when connecting to KeyDB over VPN. Zerops KeyDB is not configured to support these protocols. The security is assured by the VPN.
:::
### Stop VPN connection
[Stop the Zerops VPN](/references/networking/vpn#stop-vpn) in zCLI.
### Connect to KeyDB from another Zerops project
All services of the same project share a **dedicated private network**. You can use the service hostname to connect from one service to another within the same project.
Different Zerops projects have no special connection. They can communicate with each other only via the internet. If you need to connect to a KeyDB service in a Zerops project from a runtime service in another project, you need to use the [Zerops VPN](#access-keydb-through-vpn). Due to security reasons Zerops doesn't allow exposing KeyDB service directly to the internet.

----------------------------------------

# Keydb > How To > Control

Zerops allows you to stop any service. Stopped services only consume disk.
## Stop, start and restart KeyDB service in Zerops GUI
To stop the KeyDB service in Zerops GUI go to the project dashboard and select the **Stop** menu item in the top right corner.
To start the stopped KeyDB service choose the **Start** item from the same menu.
To restart the KeyDB service choose the **Restart** item from the same menu.
## Stop and start KeyDB using zCLI
zCLI is the Zerops command-line tool. To stop and start the KeyDB service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. Run the `zcli service stop` command
```sh
Usage:
  zcli service stop [service-id-or-name] [flags]
Flags:
  -h, --help               the enable Zerops subdomain command.
      --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
      --service-id string   If you have access to more than one service, you must specify the service ID for which the
                           command is to be executed.
```
:::info
zCLI commands are interactive, when you press enter after `zcli service stop`, you will be given a list of your projects and services to choose from.
:::
3. Run the `zcli service start` command
```sh
Usage:
  zcli service start [{serviceName | serviceId}] [flags]
Flags:
  -h, --help               the service start command.
      --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
      --service-id string   If you have access to more than one service, you must specify the service ID for which the
                           command is to be executed.
```
:::info
zCLI commands are interactive, when you press enter after `zcli service start`, you will be given a list of your projects and its services to choose from.
:::

----------------------------------------

# Keydb > How To > Create

[KeyDB ↗](https://docs.keydb.dev/) is a fully open source database, backed by Snap, and a faster drop in alternative to Redis.
## Create KeyDB using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new KeyDB service:
### Choose KeyDB version
Following KeyDB versions are currently supported:
### Set a hostname
Enter a unique service identifier like `keydb`, `db` etc.
#### Limitations:
- Duplicate services with the same name within the same project are not allowed
- Maximum 25 characters
- Must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created and cannot be changed later.
:::
### Configure auto scaling
Zerops automatically scales KeyDB services based on actual database usage. Configure the scaling parameters to match your database needs and control costs.
**CPU Mode**: Choose between shared (cost-effective) or dedicated (consistent performance).
**Resource Limits**: Set minimum and maximum resources for CPU, RAM, and disk to control costs and ensure performance.
**Deployment Mode**: Choose the reliability configuration for your KeyDB service:
- **Highly Available**: Multiple containers with redundancy across different physical machines. Recommended for production environments.
- **Single Container**: One container suitable for development and non-critical environments.
:::warning
Deployment mode cannot be changed after service creation.
:::
:::tip Learn More
For detailed scaling configuration, deployment mode details, and troubleshooting, see:
- [How Zerops scales KeyDB](/keydb/how-to/scale) - Database-specific scaling guide
- [Automatic Scaling and High Availability](/features/scaling-ha) - Complete technical details
:::
## Create KeyDB using zCLI
zCLI is the Zerops command-line tool. To create a new KeyDB service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](#create-a-project-description-file)
3. Create a project and a KeyDB service
### Create a project description file
Zerops uses a yaml format file to describe the project infrastructure.
#### Basic example
Create a directory `my-project`. Create a `description.yaml` file inside the directory with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: keydb1
    # service type and version number in keydb@6 format
    type: keydb@6
    # mode of operation "HA"/"NON_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain one KeyDB service in single container mode with default [auto scaling](/keydb/how-to/scale) configuration. Hostname will be set to `keydb1`.
#### Full example
Create a directory `my-project`. Create a `description.yaml` file inside the directory with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a KeyDB database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # first service hostname
    hostname: keydb1
    # service type and version number in keydb@6 format
    type: keydb@6
    # mode of operation "HA"/"NON_HA"
    mode: HA
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
  - # second service hostname
    hostname: keydb2
    # service type and version number in keydb@6 format
    type: keydb@6
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain two KeyDB services.
The hostname of the first service will be set to `keydb1`. The highly available mode will be chosen and the custom [auto scaling configuration](/keydb/how-to/scale) will be set.
The hostname of the second service will be set to `keydb2`. The single container mode will be chosen and the default [auto scaling configuration](/keydb/how-to/scale) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      
      description
      Optional. Description of the new project.
      Maximum 255 characters.
    
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains only KeyDB services but you can create a `description.yaml` with [different types] of services.
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
        The hostname of the new database will be set to the `hostname` value.
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the service type and version.
        
        See what [KeyDB service types](/references/import-yaml/type-list#database-services) are currently supported.
      
      mode
      
        Defines the operation mode of KeyDB service.
        HA
        
        Creates a KeyDB cluster with 2 database containers. This mode is suited for production.
        Zerops always keeps the 2 database containers on different physical machines. All your data is stored redundantly in 2 identical copies. In case of a failure of a container or the underlying physical machine, Zerops automatically disconnects the failed container from the cluster, creates a new container and syncs all data from the remaining copy. Finally the broken container is automatically deleted.
        NON_HA
        
        Zerops will create a KeyDB database installed in a single container. Useful for non-essential data or dev environments.
        Your data is stored only in a single container. If the container or the underlying physical machine fails, your data since the last backup are lost. Zerops doesn't provide any automatic repairs of single node KeyDB services.
      
      verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
      - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
      - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
      - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
      - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
:::caution
The KeyDB service **hostname** and **mode** are fixed after the service is created. They can't be changed later.
:::
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add KeyDB service to an existing project
#### Example
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```bash
# array of project services
services:
  -
    # service name
    hostname: keydb1
    # service type and version number in keydb@6 format
    type: keydb@6
    # mode of operation "HA"/"NON_HA"
    mode: NON_HA
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one KeyDB service in single container mode with default [auto scaling](/keydb/how-to/scale) configuration will be added to your project. Hostname of the new service will be set to `keydb1`.
The content of the `services:` section of `import.yaml` is identical to the [project description file](#create-a-project-description-file). The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the `import.yaml` file is 100 kB.

----------------------------------------

# Keydb > How To > Delete



----------------------------------------

# Keydb > How To > Manage

## How to use a database management tool on your workstation
Do you already use a database management tool that supports KeyDB on your workstation? Connect it securely to KeyDB from your local workspace via Zerops VPN.
Zerops VPN client is included into zCLI, the Zerops command-line tool. To start the VPN connection, read [how to connect to KeyDB remotely](/keydb/how-to/connect#connect-to-keydb-in-zerops-remotely).
:::caution
Do not use SSL/TLS protocols when connecting to KeyDB over VPN. Zerops KeyDB is not configured to support these protocols. The security is assured by the VPN.
:::
## How to use KeyDB Client CLI on your workstation
If you use the [keydb-cli ↗](https://docs.keydb.dev/docs/keydbcli/) command-line client to manage your KeyDB on your local workspace, you can connect it securely to KeyDB via Zerops VPN.
Zerops VPN client is included into zCLI, the Zerops command-line tool. To start the VPN connection, read [how to connect to KeyDB remotely](/keydb/how-to/connect#connect-to-keydb-in-zerops-remotely).
Once the VPN session is established, you have the secured connection to the project's private network in Zerops. You can access all project services locally by using their hostname. The only difference is that no [environment variables](/keydb/how-to/connect#connect-to-keydb-in-zerops-remotely) are available when connected through VPN. To connect to KeyDB in Zerops you have to copy the [access details](/keydb/how-to/connect#connect-to-keydb-in-zerops-remotely) manually from Zerops GUI.
Use `keydb-cli` command to connect to KeyDB in Zerops:
```sh
keydb-cli -h [hostname]
```
:::caution
Do not use SSL/TLS protocols when connecting to KeyDB over VPN. Zerops KeyDB is not configured to support these protocols. The security is assured by the VPN.
:::

----------------------------------------

# Keydb > How To > Scale

Zerops automatically scales your KeyDB service based on actual database usage. When your database needs more power, resources increase. When demand drops, resources scale down to reduce costs.
:::tip Read More
For complete scaling details across all services, see [Automatic Scaling and High Availability](/features/scaling-ha).
:::
## How KeyDB scaling works
KeyDB services use **vertical scaling** to adjust CPU, RAM, and disk resources within containers based on usage patterns. Unlike runtime services, KeyDB does not use horizontal scaling (adding/removing containers). Instead, KeyDB services use deployment modes for high availability.
## Configure scaling
You can configure scaling settings:
- **During service creation** - Set initial scaling parameters when [creating](/keydb/how-to/create) your KeyDB service
- **During import** - Define scaling configuration in your YAML import file using `verticalAutoscaling` parameters
- **After service creation** - Navigate to your KeyDB service and select **Automatic scaling configuration** to modify settings
### Basic settings
  
**CPU Mode**: Choose between shared (cost-effective, variable performance) or dedicated (consistent performance, higher cost). You can change CPU mode once per hour. See [pricing](https://zerops.io/#pricing) for costs.
**Resource limits**: Configure minimum and maximum resources for your KeyDB service:
- **Lower the maximum** to control costs and prevent over-scaling
- **Raise the minimum** when you need guaranteed baseline performance
- **Set minimum = maximum** to disable automatic scaling for that specific resource
**Deployment mode**: Choose the reliability configuration for your KeyDB service:
- **Single Container**: One container with vertical scaling only. Suitable for development environments.
- **Highly Available**: Multiple containers with built-in redundancy. Recommended for production environments.
:::warning
Deployment mode cannot be changed after service creation.
:::
When a container fails in HA mode, Zerops automatically replaces it with a new container on a different physical machine and synchronizes data from healthy copies.
### Advanced settings
**Start CPU cores**: Determines how many CPU cores are allocated during database startup. Increase this value if your KeyDB service starts slowly or requires more processing power during initialization.
**RAM thresholds**: Help prevent out-of-memory crashes by maintaining buffer space:
- **Absolute (GB)**: Maintains this amount of free RAM at all times
- **Percentage**: Keeps this percentage of total RAM free
Consider increasing these values if your database experiences memory-related issues.
  
:::info Read More
For detailed technical parameters and scaling behavior, see [Automatic Scaling and High Availability](/features/scaling-ha#resource-scaling-behavior).
:::
## Monitor usage
Navigate to your KeyDB service and select **Service containers & Overview** to view:
- CPU, RAM, and disk usage over time
- Historical scaling events
- Container health status
## Technical details
Zerops monitors database usage and automatically adjusts resources based on predefined thresholds and timing parameters. The scaling behavior follows the same principles as other services in the platform.
For complete technical specifications including:
- Resource monitoring intervals and thresholds
- Scale-up and scale-down timing parameters
- Scaling increments and steps
- Detailed scaling behavior patterns
See [Resource Scaling Behavior](/features/scaling-ha#resource-scaling-behavior) in the general scaling documentation.
## Common issues
**Out of memory errors**
- Increase minimum free RAM settings in your scaling configuration
- Consider raising the minimum RAM allocation
- Check for memory-intensive operations
**Higher than expected costs**
- Consider lowering your maximum resource limits
- Review scaling patterns in the monitoring dashboard
**Slow database startup**
- Increase the "Start CPU cores" setting
- Consider switching to dedicated CPU mode for consistent performance
*Need help? Join our [Discord community](https://discord.gg/zerops) for assistance!*

----------------------------------------

# Keydb > Overview

[KeyDB ↗](https://docs.keydb.dev/) is a fully open source database, a faster drop-in alternative to Redis. It offers enhanced performance, multithreading capabilities, and maintains full compatibility with Redis clients and APIs.
:::important
While KeyDB is available in Zerops, please note that KeyDB development has not been very active recently. For new Redis-compatible deployments, we recommend considering [Valkey](/valkey/overview) as the preferred alternative due to its active development and ongoing support.
:::
## Feature Highlights
### Connect to KeyDB service
## Popular Guides
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

# Mariadb > How To > Backup

Zerops provides automated data backup for MariaDB services with full encryption and flexible management options.
For general backup information including configuration, scheduling, and management options, see the [Zerops Backups](/features/backup) documentation, which covers:
- Backup scheduling and retention policies
- Tagging system and storage quotas
- Manual backup creation and CLI tools
- Security and encryption details
This page focuses on MariaDB-specific backup details.
## MariaDB Backup Format
MariaDB backups are created using `mariabackup` and stored in `.xb.gz` format:
- **Format**: `.xb.gz` (single archive)
- **Tooling**: `mariabackup`
- **Compression**: Uses `xbstream` format, gzip compressed
- **Storage**: Encrypted and stored in isolated object storage
## Restoring MariaDB Backups
To restore a MariaDB backup:
1. **Download** the backup file (`.xb.gz`) from the Zerops UI
2. **Prepare** your target environment (clean existing data or use a new instance)
3. **Extract** the backup file to access the database contents
4. **Restore** using either:
   - **MariaDB native tools**: Follow the [official MariaDB backup documentation](https://mariadb.com/kb/en/mariabackup/) for detailed restore procedures
   - **Third-party management tools**: Use web-based tools like phpMyAdmin or Adminer as described in [MariaDB Management Tools](/mariadb/how-to/manage)
For assistance with the restoration process, contact Zerops support.
## High Availability
For MariaDB services running in High Availability mode:
- Backups are created on a randomly selected healthy node
- Other nodes remain operational during the backup process
- Manual backups typically run on the primary node
## Best Practices
- Always create a manual backup with a protected tag before database migrations or major schema changes
- Test your restore process periodically in a non-production environment
- Monitor your backup storage usage in the Project Overview
- Use descriptive tags like `pre-migration-v2` for important snapshots
For additional best practices and troubleshooting, refer to the [main backup documentation](/features/backup).

----------------------------------------

# Mariadb > How To > Connect

## Default MariaDB database and user
Zerops creates a default database and a default user automatically when a new MariaDB service is [created](/mariadb/how-to/create).
#### Database
The default database name is identical to the service hostname. The default encoding is set to `utf8mb4`.
#### DB user
Default user name is identical to the service hostname. Default user password is generated randomly. You will find the password in [Zerops GUI](/mariadb/how-to/connect#copy-access-details-from-zerops-gui) or you can use the [environment variable](#use-mariadb-environment-variables).
:::info
Zerops creates a second DB user: `zps` for maintenance reasons with full privileges. Do not delete, change the password or remove privileges from this user, it will disrupt Zerops ability to maintain the database cluster.
:::
## Copy access details from Zerops GUI
You will find the MariaDB access details under the **Access details** button in the project dashboard page.
The same information is available in the service detail page in the left menu under the **Peek access details** button.
### MariaDB access parameters:
| Parameter             | Description                                                                                                                          |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| **Hostname**          | The service hostname specified when the MariaDB service was created.                                                                 |
| **Hostname**          | The service hostname specified when the MariaDB service was created.                                                                 |
| **Port**              | **3306**
This port is fixed for all MariaDB services and cannot be customized.                                                   |
| **User**              | Zerops creates a database user automatically when the service is created. The user name is always identical to the service hostname. |
| **Password**          | Zerops sets a random password when the service is created.                                                                           |
| **Connection string** | The connection string for MariaDB service is:
`mysql://${user}:${password}@{hostname}:3306`                                      |
## Connect to MariaDB from runtime services of the same project
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
#### Example
To connect to MariaDB `database1` service, set
```
host = database1
user = database1
password = **********
```
You will find the password under the [**Access details**](/mariadb/how-to/connect#copy-access-details-from-zerops-gui) button in Zerops GUI.
:::caution
Do not use SSL/TLS protocols when connecting to MariaDB from other runtime services in the same project. Zerops MariaDB is not configured to support these protocols. The security is assured by the project private network. Due to security reasons Zerops doesn't allow exposing MariaDB service to the internet.
:::
## Use MariaDB environment variables
Zerops creates default environment variables for each MariaDB service to help you with connection from runtime services in the same project. To avoid the need to copy database access parameters manually, use environment variables in your [runtime service].
### Prefix the environment variable key
All services of the same project can reference environment variables from other services. To use an environment variable from one service in another service in the same project, you must prefix the environment variable key with the service hostname and underscore.
#### Example
To access the `connectionString` env variable of the `mariadb1` service, use `mariadb1_connectionString` as the env variable key.
To access the `password` env variable of the `mariadb2` service, use `mariadb2_password` as the env variable key.
### MariaDB environment variables
List of service environment variables is available in Zerops GUI. Go to a MariaDB service detail and choose **Environment variables** in the left menu.
Zerops creates following environment variables when the MariaDB service is created:
| Variable              | Description                                                                                                                                                                                                                                                                                                                                                       |
| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Hostname**          | The service hostname specified when the MariaDB service was created.                                                                                                                                                                                                                                                                                              |
| **Hostname**          | The service hostname specified when the MariaDB service was created.                                                                                                                                                                                                                                                                                              |
| **Port**              | **3306**
This port is fixed for all MariaDB services and cannot be customized.                                                                                                                                                                                                                                                                                |
| **projectId**         | ID of the project. Generated by Zerops.                                                                                                                                                                                                                                                                                                                           |
| **serviceId**         | ID of the MariaDB service. Generated by Zerops.                                                                                                                                                                                                                                                                                                                   |
| **Connection string** | The connection string for MariaDB service is:
`mysql://${user}:${password}@{hostname}:3306`
Connection string contains [references](/mariadb/how-to/connect#mariadb-access-parameters) to `user` and `password` variables. Each time the `user` or `password` variable is updated, the `connectionString` variable is automatically updated as well. |
| **User**              | Zerops creates a database user automatically when the service is created. The user name is always identical to the service hostname.                                                                                                                                                                                                                              |
| **Password**          | Zerops sets a random password when the service is created.                                                                                                                                                                                                                                                                                                        |
:::caution
When you change the value of the password env variable, only the env variable is updated, not the actual password of the MariaDB user. You have to update the password of the database user manually.
:::
:::caution
When you change the password of the default MariaDB user in the database, the new password is not synchronised to the password env variable. You have to update the `password` env variable manually.
:::
You can create own custom [environment variables](/features/env-variables) for the MariaDB service in Zerops GUI and use them in the same way as the default variables.
## Connect to MariaDB in Zerops remotely
:::caution
Due to security reasons Zerops doesn't allow exposing MariaDB service directly to the internet.
:::
### Start VPN connection
You can securely connect to MariaDB from your local workspace via Zerops VPN. Zerops VPN client is included into zCLI, the Zerops command-line tool. To start a VPN connection to the selected Zerops project, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Start the Zerops VPN](/references/networking/vpn#start-vpn)
### Access MariaDB through VPN
Once the VPN session is established, you have the secured connection to the project's private network in Zerops. You can access all project services locally by using their hostname. The only difference is that no [environment variables](#use-mariadb-environment-variables) are available when connected through VPN. To connect to MariaDB in Zerops you have to copy the [access details](#copy-access-details-from-zerops-gui) manually from Zerops GUI.
:::caution
Do not use SSL/TLS protocols when connecting to MariaDB over VPN. Zerops MariaDB is not configured to support these protocols. The security is assured by the VPN.
:::
### Stop VPN connection
[Stop the Zerops VPN](/references/networking/vpn#stop-vpn) in zCLI.
### Connect to MariaDB from another Zerops project
All services of the same project share a **dedicated private network**. You can use the service hostname to connect from one service to another within the same project.
Different Zerops projects have no special connection. They can communicate with each other only via the internet. If you need to connect to a MariaDB service in a Zerops project from a runtime service in another project, you need to use the [Zerops VPN](#access-mariadb-through-vpn). Due to security reasons Zerops doesn't allow exposing MariaDB service directly to the internet.

----------------------------------------

# Mariadb > How To > Control



----------------------------------------

# Mariadb > How To > Create

MariaDB is the open source relational database loved by developers all over the world. Created by MySQL's original developers, MariaDB is compatible with MySQL and guaranteed to stay open source forever.
## Create MariaDB using Zerops GUI
:::note
If you're migrating from another database system such as MySQL, please review the [migration information](#migrating-from-other-database-systems) section first, as some critical settings must be configured at creation time.
:::
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new MariaDB service:
### Choose MariaDB version
Following MariaDB versions are currently supported:
### Set a hostname
Enter a unique service identifier like `mariadb`, `sql`, `db` etc.
#### Limitations:
- Duplicate services with the same name within the same project are not allowed
- Maximum 25 characters
- Must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created and cannot be changed later.
:::
### Configure auto scaling
Zerops automatically scales MariaDB services based on actual database usage. Configure the scaling parameters to match your database needs and control costs.
**CPU Mode**: Choose between shared (cost-effective) or dedicated (consistent performance).
**Resource Limits**: Set minimum and maximum resources for CPU, RAM, and disk to control costs and ensure performance.
**Deployment Mode**: Choose the reliability configuration for your MariaDB service:
- **Highly Available**: Multiple containers with redundancy across different physical machines. Recommended for production environments.
- **Single Container**: One container suitable for development and non-critical environments.
:::warning
Deployment mode cannot be changed after service creation.
:::
:::tip Learn More
For detailed scaling configuration, deployment mode details, and troubleshooting, see:
- [How Zerops scales MariaDB](/mariadb/how-to/scale) - Database-specific scaling guide
- [Automatic Scaling and High Availability](/features/scaling-ha) - Complete technical details
:::
## Create MariaDB using zCLI
:::note
If you're migrating from another database system such as MySQL, please review the [migration information](#migrating-from-other-database-systems) section first, as some critical settings must be configured at creation time.
:::
zCLI is the Zerops command-line tool. To create a new MariaDB service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](#create-a-project-description-file)
3. Create a project and a MariaDB service
### Create a project description file
Zerops uses a yaml format file to describe the project infrastructure.
#### Basic example
Create a directory `my-project`. Create a `description.yaml` file inside the directory with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: mariadb1
    # service type and version number in mariadb@{version} format
    type: mariadb@10.4
    # mode of operation "HA"/"NON_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain one MariaDB 10.4 service in single container mode with default [auto scaling](/mariadb/how-to/scale) configuration. Hostname will be set to `mariadb1`.
#### Full example
Create a directory `my-project`. Create a `description.yaml` file inside the directory with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a MariaDB database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # first service hostname
    hostname: mariadb1
    # service type and version number in mariadb@{version} format
    type: mariadb@10.4
    # mode of operation "HA"/"NON_HA"
    mode: HA
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # optional: system variables configuration
    envSecrets:
      lower_case_table_names: "1"
  - # second service hostname
    hostname: mariadb2
    # service type and version number in mariadb@{version} format
    type: mariadb@10.4
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain two MariaDB 10.4 services.
The hostname of the first service will be set to `mariadb1`. The highly available mode will be chosen and the custom [auto scaling configuration](/mariadb/how-to/scale) will be set. The `lower_case_table_names` system variable will be set to "1".
The hostname of the second service will be set to `mariadb2`. The single container mode will be chosen and the default [auto scaling configuration](/mariadb/how-to/scale) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      
      description
      Optional. Description of the new project.
      Maximum 255 characters.
    
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains only MariaDB services but you can create a `description.yaml` with [different types] of services.
  
      Parameter
      Description
      Limitations
    
      hostname
      A unique service identifier like `mariadb`,`sql`, `db` etc.
      
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      Specifies the service type and version.
      
        See what [MariaDB service types](/references/import-yaml/type-list#database-services) are currently supported.
      
      mode
      Defines the operation mode of MariaDB service.
      
        HA
        
        Zerops will create a MariaDB cluster with 3 database containers and 2
        free database proxies. This mode is suited for production.
        
        Zerops always keep the 3 database containers on different physical
        machines. All your data is stored redundantly in 3 copies. In case of a
        failure of a container or the underlying physical machine, Zerops
        automatically disconnects the failed container from the cluster, creates
        a new container and syncs all data from the remaining 2 copies. Finally
        the broken container is automatically deleted.
        
        NON_HA
        
        Zerops will create a MariaDB database installed in a single container.
        Useful for non-essential data or dev environments.
        
        Your data is stored only in a single container. If the container or the
        underlying physical machine fails, your data since the last backup are
        lost. Zerops doesn't provide any automatic repairs of single node
        MariaDB services.
      
      verticalAutoscaling
      Defines custom vertical auto scaling parameters
      
        All verticalAutoscaling attributes are optional. Not specified
        attributes will be set to their default values.
      
       - cpuMode
      Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
       - minCpu/maxCpu
      Set the minCpu or maxCpu in CPU cores (integer).
      
       - minRam/maxRam
      Set the minRam or maxRam in GB (float).
      
       - minDisk/maxDisk
      Set the minDisk or maxDisk in GB (float).
      
      envSecrets
      Defines [secret environment variables](/features/env-variables#2-secret-variables) for the service
      
:::caution
The MariaDB service **hostname** and **mode** are fixed after the service is created. They can't be changed later.
:::
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add MariaDB service to an existing project
#### Example
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```bash
# array of project services
services:
  -
    # service name
    hostname: mariadb1
    # service type and version number in mariadb@{version} format
    type: mariadb@10.4
    # mode of operation "HA"/"NON_HA"
    mode: NON_HA
    # optional: system variables configuration
    envSecrets:
      lower_case_table_names: "1"
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one MariaDB 10.4 service in single container mode with default [auto scaling](/mariadb/how-to/scale) configuration will be added to your project. Hostname of the new service will be set to `mariadb1`. The `lower_case_table_names` system variable will be set to "1".
The content of the `services:` section of `import.yaml` is identical to the [project description file](#create-a-project-description-file). The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the `import.yaml` file is 100 kB.
## Migrating from other database systems
### Configure system variables
When migrating to MariaDB in Zerops from other database systems, you may need to configure specific system variables to maintain compatibility with your existing applications.
#### Setting `lower_case_table_names` for MySQL compatibility
The `lower_case_table_names` system variable determines how MariaDB handles table name case sensitivity:
  
      Value
      Table Name Storage
      Comparison Behavior
    
      0
      Stored as specified (preserves case)
      Case-sensitive
    
      1
      Stored in lowercase
      Case-insensitive
    
      2
      Stored as specified (preserves case)
      Case-insensitive
    
:::caution
This variable must be configured when the MariaDB instance is first created and cannot be changed afterward. This is a limitation of MariaDB itself, not specific to Zerops.
:::
When configuring this in Zerops:
- **Using GUI**: Set the `lower_case_table_names` parameter in the advanced options section when creating a new MariaDB service
- **Using YAML**: Include it in your service configuration under the `envSecrets` section (see examples in the [Create MariaDB using zCLI](#create-mariadb-using-zcli) section)
##### Migration considerations
If you're migrating from MySQL to MariaDB and your application relies on a specific table name case handling:
1. Determine the value used in your source MySQL installation
2. Configure the same value in your Zerops MariaDB configuration before initializing the database
3. For most migrations from MySQL 5.7, setting the value to "1" is recommended for compatibility
After deploying your MariaDB service, you can verify the settings with this SQL command:
```sql
SELECT @@lower_case_file_system, @@lower_case_table_names;
```
:::important
If you need to change this setting after the database has been initialized, you'll need to create a new MariaDB service with the correct configuration and migrate your data.
:::

----------------------------------------

# Mariadb > How To > Delete



----------------------------------------

# Mariadb > How To > Export Import Data

## Use Adminer to export or import data
[Adminer ↗](https://www.adminer.org) is an open source full-featured database management tool written in PHP.
1. [Install Adminer to Zerops](/mariadb/how-to/manage#how-to-install-adminer-to-zerops)
2. Use Adminer standard export or import functions
## Use phpMyAdmin to export or import data
[phpMyAdmin ↗](https://www.phpmyadmin.net) is a free software tool written in PHP, intended to handle the administration of MariaDB over the Web.
1. [Install phpMyAdmin to Zerops](/mariadb/how-to/manage#how-to-install-phpmyadmin-to-zerops)
2. Use phpMyAdmin standard export or import functions
## Use a database management tool on your workstation to export or import data
Do you already use a database management tool that supports MariaDB on your workstation? Connect it securely to MariaDB from your local workspace via Zerops VPN.
Zerops VPN client is included into zCLI, the Zerops command-line tool. To start the VPN connection, read [how to connect to MariaDB remotely](/mariadb/how-to/connect#connect-to-mariadb-in-zerops-remotely).
:::caution
Do not use SSL/TLS protocols when connecting to MariaDB over VPN. Zerops MariaDB is not configured to support these protocols. The security is assured by the VPN.
:::
Once the connection to MariaDB is established, use the standard export or import functions of your favourite management tool.
## Use mysql CLI to export or import data
If you are using the [mysql ↗](https://dev.mysql.com/doc/refman/8.1/en/mysql.html) command-line client to manage your MariaDB on your local workspace, you can connect it securely to MariaDB via Zerops VPN.
Zerops VPN client is included into zCLI, the Zerops command-line tool. To start the VPN connection, read [how to connect to MariaDB remotely](/mariadb/how-to/connect#connect-to-mariadb-in-zerops-remotely).
Once the VPN session is established, you have the secured connection to the project's private network in Zerops. You can access all project services locally by using their hostname. The only difference is that no [environment variables](/mariadb/how-to/connect#use-mariadb-environment-variables) are available when connected through VPN. To connect to MariaDB in Zerops you have to copy the [access details](/mariadb/how-to/connect#connect-to-mariadb-in-zerops-remotely) manually from Zerops GUI.
Use [mysql ↗](https://dev.mysql.com/doc/refman/8.1/en/mysql.html) command to connect to MariaDB in Zerops:
```sh
mysql -h [hostname] -u [user] -p [password] [database_name]
```
:::caution
Do not use SSL/TLS protocols when connecting to MariaDB over VPN. Zerops MariaDB is not configured to support these protocols. The security is assured by the VPN.
:::
To export your database data and structure, use the [mysqldump ↗](https://dev.mysql.com/doc/refman/8.1/en/mysqldump.html) command.
```sh
mysqldump -h [hostname] -u [user] –p [password] [database_name] > dumpfilename.sql
```
To import your database data and structure, use the `mysql` command.
```sh
mysql -h [hostname] -u [user] –p [password] [database_name] < dumpfilename.sql
```

----------------------------------------

# Mariadb > How To > Manage

## Default database and user
Zerops creates a default database and a default user automatically when a new MariaDB service is [created](/mariadb/how-to/create).
#### Database
The default database name is identical to the service hostname. The default encoding is set to `utf8mb4`.
#### DB user
Default user name is identical to the service hostname. Default user password is generated randomly. You will find the password in [Zerops GUI](/mariadb/how-to/connect#copy-access-details-from-zerops-gui) or you can use the [environment variable](/mariadb/how-to/connect#use-mariadb-environment-variables).
:::info
Zerops creates a second DB user: `zps` for maintenance reasons with full privileges. Do not delete, change the password or remove privileges from this user, it will disrupt Zerops ability to maintain the database cluster.
:::
## How to install Adminer to Zerops
[Adminer ↗](https://www.adminer.org) is a open source full-featured database management tool written in PHP.
### Single-click installation
To install Adminer into your project, open your project in Zerops GUI and select **import services** in the left menu.
Copy the following yaml file into the text area and start the import:
```yaml
services:
  - # Service will be accessible through zCLI VPN under: http://adminer
    hostname: adminer
    # Type and version of service used.
    type: php-apache@8.0+2.4
    # Whether the service will be run on one or multiple containers.
    # Since this is a utility service, using a single container is fine.
    minContainers: 1
    maxContainers: 1
    # Folder name used as the root of the publicly accessible web server content.
    documentRoot: public
    # Link to Zerops repository that contains Adminer code with Zerops build and deploy instructions.
    buildFromGit: https://github.com/zeropsio/recipe-adminer@main
```
When the import is finished, Adminer will be running as a PHP service in your project.
## How to access Adminer
### Use Zerops VPN
By default Adminer service is private and is accessible from your local workstation over VPN.
You can securely connect to MariaDB from your local workspace via Zerops VPN. Zerops VPN client is included into zCLI, the Zerops command-line tool. To start a VPN connection to the selected Zerops project, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Start the Zerops VPN](/references/networking/vpn)
3. Type `http://adminer` into your browser
:::caution
Do not use https when connecting to Adminer via VPN.
:::
### Enable public access
You can enable the public access to the Adminer service via the [Zerops subdomain].
Or you can configure the [Public routing] on the Adminer service to make it accessible on your own domain.
## How to install phpMyAdmin to Zerops
[phpMyAdmin ↗](https://www.phpmyadmin.net) is a free software tool written in PHP, intended to handle the administration of MariaDB over the Web.
### Single-click installation
To install phpMyAdmin into your project, open your project in Zerops GUI and select **import services** in the left menu.
Copy the following yaml file into the text area and start the import:
```yaml
services:
  - # Service will be accessible through zCLI VPN under: http://phpmyadmin
    hostname: phpmyadmin
    # Type and version of service used.
    type: php-apache@8.1+2.4
    # Whether the service will be run on one or multiple containers.
    # Since this is a utility service, using a single container is fine.
    minContainers: 1
    maxContainers: 1
    # Folder name used as the root of the publicly accessible web server content.
    documentRoot: public
    # Link to Zerops repository that contains Adminer code with Zerops build and deploy instructions.
    buildFromGit: https://github.com/zeropsio/recipe-phpmyadmin@main
```
When the import is finished, phpMyAdmin will be running as a PHP service in your project.
## How to access phpMyAdmin
### Use Zerops VPN
By default phpMyAdmin service is private and is accessible from your local workstation over VPN.
You can securely connect to MariaDB from your local workspace via Zerops VPN. Zerops VPN client is included into zCLI, the Zerops command-line tool. To start a VPN connection to the selected Zerops project, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Start the Zerops VPN](/references/networking/vpn)
3. Type `http://phpmyadmin` into your browser
:::caution
Do not use https when connecting to phpMyAdmin via VPN.
:::
### Enable public access
You can enable the public access to the phpMyAdmin service via the [Zerops subdomain].
Or you can configure the [Public routing] on the phpMyAdmin service to make it accessible on your own domain.
## How to use a database management tool on your workstation
Do you already use a database management tool that supports MariaDB on your workstation? Connect it securely to MariaDB from your local workspace via Zerops VPN.
Zerops VPN client is included into zCLI, the Zerops command-line tool. To start the VPN connection, read [how to connect to MariaDB remotely](/mariadb/how-to/connect#connect-to-mariadb-in-zerops-remotely).
:::caution
Do not use SSL/TLS protocols when connecting to MariaDB over VPN. Zerops MariaDB is not configured to support these protocols. The security is assured by the VPN.
:::
## How to use mysql CLI on your workstation
If you use the [mysql ↗](https://dev.mysql.com/doc/refman/8.1/en/mysql.html) command-line client to manage your MariaDB on your local workspace, you can connect it securely to MariaDB via Zerops VPN.
Zerops VPN client is included into zCLI, the Zerops command-line tool. To start the VPN connection, read [how to connect to MariaDB remotely](/mariadb/how-to/connect#connect-to-mariadb-in-zerops-remotely).
Once the VPN session is established, you have the secured connection to the project's private network in Zerops. You can access all project services locally by using their hostname. The only difference is that no [environment variables](/mariadb/how-to/connect#connect-to-mariadb-in-zerops-remotely) are available when connected through VPN. To connect to MariaDB in Zerops you have to copy the [access details](/mariadb/how-to/connect#connect-to-mariadb-in-zerops-remotely) manually from Zerops GUI.
Use `mysql` command to connect to MariaDB in Zerops:
```sh
mysql -h [hostname] -u [user] -p [password] [database_name]
```
:::caution
Do not use SSL/TLS protocols when connecting to MariaDB over VPN. Zerops MariaDB is not configured to support these protocols. The security is assured by the VPN.
:::

----------------------------------------

# Mariadb > How To > Scale

Zerops automatically scales your MariaDB service based on actual database usage. When your database needs more power, resources increase. When demand drops, resources scale down to reduce costs.
:::tip Read More
For complete scaling details across all services, see [Automatic Scaling and High Availability](/features/scaling-ha).
:::
## How MariaDB scaling works
MariaDB services use **vertical scaling** to adjust CPU, RAM, and disk resources within containers based on usage patterns. Unlike runtime services, MariaDB does not use horizontal scaling (adding/removing containers). Instead, MariaDB services use deployment modes for high availability.
## Configure scaling
You can configure scaling settings:
- **During service creation** - Set initial scaling parameters when [creating](/mariadb/how-to/create) your MariaDB service
- **During import** - Define scaling configuration in your YAML import file using `verticalAutoscaling` parameters
- **After service creation** - Navigate to your MariaDB service and select **Automatic scaling configuration** to modify settings
### Basic settings
  
**CPU Mode**: Choose between shared (cost-effective, variable performance) or dedicated (consistent performance, higher cost). You can change CPU mode once per hour. See [pricing](https://zerops.io/#pricing) for costs.
**Resource limits**: Configure minimum and maximum resources for your MariaDB service:
- **Lower the maximum** to control costs and prevent over-scaling
- **Raise the minimum** when you need guaranteed baseline performance
- **Set minimum = maximum** to disable automatic scaling for that specific resource
**Deployment mode**: Choose the reliability configuration for your MariaDB service:
- **Single Container**: One container with vertical scaling only. Suitable for development environments.
- **Highly Available**: Multiple containers with built-in redundancy. Recommended for production environments.
:::warning
Deployment mode cannot be changed after service creation.
:::
When a container fails in HA mode, Zerops automatically replaces it with a new container on a different physical machine and synchronizes data from healthy copies.
### Advanced settings
**Start CPU cores**: Determines how many CPU cores are allocated during database startup. Increase this value if your MariaDB service starts slowly or requires more processing power during initialization.
**RAM thresholds**: Help prevent out-of-memory crashes by maintaining buffer space:
- **Absolute (GB)**: Maintains this amount of free RAM at all times
- **Percentage**: Keeps this percentage of total RAM free
Consider increasing these values if your database experiences memory-related issues.
  
:::info Read More
For detailed technical parameters and scaling behavior, see [Automatic Scaling and High Availability](/features/scaling-ha#resource-scaling-behavior).
:::
## Monitor usage
Navigate to your MariaDB service and select **Service containers & Overview** to view:
- CPU, RAM, and disk usage over time
- Historical scaling events
- Container health status
## Technical details
Zerops monitors database usage and automatically adjusts resources based on predefined thresholds and timing parameters. The scaling behavior follows the same principles as other services in the platform.
For complete technical specifications including:
- Resource monitoring intervals and thresholds
- Scale-up and scale-down timing parameters
- Scaling increments and steps
- Detailed scaling behavior patterns
See [Resource Scaling Behavior](/features/scaling-ha#resource-scaling-behavior) in the general scaling documentation.
## Common issues
**Out of memory errors**
- Increase minimum free RAM settings in your scaling configuration
- Consider raising the minimum RAM allocation
- Check for memory-intensive queries or operations
**Higher than expected costs**
- Consider lowering your maximum resource limits
- Review scaling patterns in the monitoring dashboard
**Slow database startup**
- Increase the "Start CPU cores" setting
- Consider switching to dedicated CPU mode for consistent performance
*Need help? Join our [Discord community](https://discord.gg/zerops) for assistance!*

----------------------------------------

# Mariadb > Overview

[MariaDB ↗](https://mariadb.org/) is one of the most popular open source relational databases. It’s made by the original developers of MySQL and guaranteed to stay open source.
## Feature Highlights
### Connect to MariaDB service
### Others
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Mariadb > Tech Details > Cluster

The following description applies only to the [highly available mode](/features/scaling-ha#highly-available-ha-mode) of the MariaDB service.
## Description of MariaDB cluster
MariaDB cluster in highly available mode contains 3 database containers and 2 free database proxies.
#### 1 write node + 2 read nodes
Zerops always keeps the 3 database containers on different physical machines. A MariaDB cluster node is installed in each database container. First a writer node is started followed by 2 read nodes. All your data is stored redundantly in 3 identical copies.
If the container with one of the reader nodes fails, Zerops disconnects it from the MariaDB cluster. Zerops then creates a new container with a MariaDB read node inside, connects it to the cluster and starts the synchronisation of the data to the new node. Finally the broken container is deleted.
If the container with the writer node fails, Zerops disconnects it from the MariaDB cluster and one of the read nodes is automatically promoted to the writer node. Zerops creates a new container with a MariaDB read node inside, connects it to the cluster and starts the synchronisation of the data to the new node. Finally the broken container is deleted.
#### 2 database proxies
Zerops uses [MaxScale 2.5 ↗](https://mariadb.com/kb/en/maxscale/), this database proxy is optimised specifically for MariaDB. MaxScale database proxy understands the mysql protocol. It forwards all **write requests** to the writer node and all **read requests** to read nodes.
Zerops creates 2 containers with MaxScale database proxy and connects them to the database cluster in the highly available infrastructure. Zerops always keep the 2 database proxies on different physical machines.
If a container with the database proxy fails, Zerops starts a new container automatically. Database proxy doesn't contain any data therefore the start of the new database proxy is fast.
## Synchronous vs. Asynchronous replication
#### Synchronous replication
Synchronous replication guarantees that when a change happens on the write node, it is replicated on the read nodes synchronously. Synchronous replication uses a distributed locking which proved to be very slow. The data replication from the write node to the read nodes takes some time and the write transactions must wait until the changed data is successfully replicated to all database nodes. In case one of the database nodes is overloaded, the whole cluster becomes very slow.
#### Asynchronous replication
Asynchronous replication gives no guarantees about the delay between applying changes on the write node and the propagation of changes to all read nodes. The delay is usually very short but when one of the read containers is overloaded the delay can be longer. The main benefit of the asynchronous replication is the performance. Write transaction is completed when the write node successfully commits the transaction locally and writes it to the write-ahead log that prevents the loss of data.
The downside of the asynchronous replication is no guarantee that the read nodes will always return the current data. In some cases a `SELECT` query that quickly follows the previous `COMMIT` may return old data. As mentioned above, the database proxy forwards all read requests to read nodes. When the read node processes the `SELECT` query before the replication of the previous transaction is finished, old data is returned.
Zerops uses the asynchronous replication in MariaDB cluster.
## How to deal with situations when old data is returned
#### Use explicit transactions
MariaDB cluster returns old data most often when you use the `SELECT` query right after the `COMMIT` in the same algorithm. This problem can be solved by moving the `SELECT` query into the transaction. All queries inside a `BEGIN..COMMIT` transaction are always executed against the write node.
#### Enable synchronous checks for SELECT queries
For a critical read that must have the most up-to-date data use the `wsrep_sync_wait` option:
```sh
SET SESSION wsrep_sync_wait=1;
SELECT ...;
SET SESSION wsrep_sync_wait=0;
```
When the `wsrep_sync_wait=1` option is used, the read node will synchronise data from the write node before executing the query. The read node will wait until all updates from the write node that were committed before the `SELECT` query was received and only then executes the query.

----------------------------------------

# Mariadb > Tech Details > Limitations

The following description applies only to the [highly available mode](/features/scaling-ha#highly-available-ha-mode) of the MariaDB service.
#### InnoDB only
Only the InnoDB storage engine is supported.
#### Mandatory table primary key
All database tables should have a primary key. A multi-column primary key can also be used. `DELETE` operations are unsupported on tables without a primary key. Also, rows in tables without a primary key may appear in a different order on different nodes.
#### Limited locks support
No support for explicit locks, including `LOCK TABLES`, `FLUSH TABLES {explicit table list} WITH READ LOCK`, `GET_LOCK`, `RELEASE_LOCK`. These limitations can be overcome using transactions. Global locking operators like `FLUSH TABLES WITH READ LOCK` are supported.
#### Do not use local exports
Do not use `SELECT INTO OUTFILE` or `SELECT INTO DUMPFILE` commands. It will create a file on one of the database containers that will receive the request. Zerops doesn't support direct access into the MariaDB database containers so you won't be able to access the file. Learn more about [how to export and import MariaDB data](/mariadb/how-to/export-import-data).
[Full list of MariaDB cluster limitations ↗](https://mariadb.com/kb/en/mariadb-galera-cluster-known-limitations/)

----------------------------------------

# Meilisearch > Overview

Deploy and manage Meilisearch on a fully managed infrastructure. Get instant access to fast, typo-tolerant search with zero operational overhead.
## Supported Versions
Currently supported Meilisearch versions:
Import configuration version:
## Service Configuration
Our Meilisearch implementation runs as a **single-node** setup, as Meilisearch does not currently support cluster configurations.
### Environment Modes
:::note
Environment mode affects the availability of certain features and can impact your application's security. Choose carefully based on your use case.
:::
#### Production Mode (Default)
- Optimized for performance and security
- Search Preview (Mini-dashboard) disabled
- Recommended for production deployments
#### Development Mode
- Includes Search Preview (Mini-dashboard)
- Enhanced debugging capabilities
- Suitable for development and testing
To switch between modes:
1. Navigate to the **Environment variables** section in the Meilisearch service detail and scroll to the **Generated Variables**
2. Set the `environment` variable to either:
   - `production` - for production mode (default)
   - `development` - for development mode with Mini-dashboard
3. Restart the service to apply changes
### API Key Management
The service provides three pre-configured API keys, each with specific access levels:
#### `masterKey`
- Root access to your Meilisearch instance
- Use only for initial setup and key management
- **Never expose in application code or frontend**
#### `defaultSearchKey`
- Read-only search operations across all indices
- Safe for frontend implementations
- **Can be exposed in client-side code**
#### `defaultAdminKey`
- Full administrative access to all indices
- For backend operations and index management
- **Keep secure in backend services only**
[Custom API keys](https://www.meilisearch.com/docs/reference/api/keys) provide fine-grained access control for specific use cases. For example, you might create:
- Search-only keys for specific indices
- Temporary keys with expiration dates
- Keys with restricted actions for third-party integrations
## Network Architecture & Access
### Access Methods
#### Public HTTPS Access
When enabled, access via [Zerops subdomain](/references/networking/public-access#zerops-subdomain-access).
#### Internal Project Access
Services within the same project can reach Meilisearch directly:
```
http://{hostname}:7700
```
## Backup
Meilisearch backups are created using native dump commands:
- **Format**: `.dump` (standard Meilisearch dump)
- **Tooling**: Native dump command
- **Content**: Contains index data and settings
For backup configuration, scheduling, retention policies, and management options, see the [Zerops Backups](/features/backup) documentation.
### Restoring Backups
To restore a Meilisearch backup:
1. **Download** the backup file (`.dump`) from the Zerops UI
2. **Prepare** your target environment (clean existing indices or use a new instance)
3. **Restore** using the Meilisearch API. Use the dump import endpoint to restore your data. Follow the [official Meilisearch documentation](https://www.meilisearch.com/docs/learn/data_backup/dumps#importing-a-dump-in-self-hosted-instances) for detailed restore procedures.
For assistance with the restoration process, contact Zerops support.
## Quick Start Example
Here's a minimal example of implementing search in a React application:
```javascript
const MEILISEARCH_URL = process.env.zeropsSubdomain;
const SEARCH_KEY = process.env.defaultSearchKey;
function SearchComponent() {
  const [results, setResults] = useState([]);
  const handleSearch = async (query) => {
    const response = await fetch(`${MEILISEARCH_URL}/indexes/products/search`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${SEARCH_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        q: query,
        limit: 10
      })
    });
    const data = await response.json();
    setResults(data.hits);
  };
  return (
    
       handleSearch(e.target.value)}
        placeholder="Search products..."
      />
      
        {results.map(hit => (
          {hit.name}
        ))}
      
  );
}
```
## Best Practices
#### Security
- Store sensitive keys (`masterKey`, `defaultAdminKey`) securely in backend services
- Use `defaultSearchKey` or custom keys with minimal permissions for frontend
- Rotate custom keys periodically
#### Performance
- Implement debouncing for search inputs
- Cache frequently accessed search results
- Monitor response times and adjust index settings
- Use appropriate batch sizes for bulk operations
#### Error Handling
- Implement retry logic for temporary failures
- Set appropriate timeout values for your use case
- Handle rate limiting gracefully
## Troubleshooting
### Common Issues
#### Connection Problems
- Check if your instance is in the correct environment mode
- Ensure your API keys have the necessary permissions
- Confirm your service is running and healthy in the Zerops dashboard
#### Search Performance
- Review your index settings for optimal search performance
- Monitor your instance's resource usage
- Consider implementing client-side caching for frequent searches
#### API Key Issues
- Verify you're using the correct key type for your operation (search vs. admin)
- Check key permissions match your intended operations
- Ensure keys are properly formatted in your Authorization header
- Remember that master and admin keys should never be used in frontend code
## Learn More
- [Official Meilisearch Documentation](https://www.meilisearch.com/docs) - Comprehensive guide to all Meilisearch features and capabilities
- [API Reference](https://www.meilisearch.com/docs/reference/api/overview) - Detailed API specifications and usage examples
## Support
For advanced configurations or custom requirements:
- Join our [Discord community](https://discord.gg/zeropsio)
- Contact support via [email](mailto:support@zerops.io)

----------------------------------------

# Nats > Overview

Zerops provides a fully managed [NATS](https://nats.io/) messaging system with automated scaling and zero infrastructure overhead, letting developers focus entirely on development.
## Supported Versions
Currently supported NATS version:
Import configuration version:
## Service Configuration
Our NATS implementation features optimized default settings designed for common use cases.
**Key configuration aspects** include:
- Standard protocol port `4222` for client connections
- HTTP monitoring interface `8222` for management
- Secure authentication with automatically generated credentials
- Optimized settings for performance and reliability
You can fine-tune your NATS service by adjusting **environment variables**:
### Available Configuration Options
:::note
If certain variables are not visible in your configuration, they may have been introduced after your service was created. Simply add them as [secret variables](/features/env-variables#2-secret-variables) to access the functionality.
:::
  
      Variable
      Description
    
      MAX_PAYLOAD
      Defines the maximum allowed message size for all NATS traffic. Default: 8MB, Maximum: 64MB. See NATS limits documentation for details.
    
      JET_STREAM_ENABLED
      Controls whether JetStream functionality is enabled. Default: 1 (enabled), Set to 0 to disable. See JetStream Configuration section below for more details.
    
:::important
Configuration changes require a service **restart** to take effect. While NATS itself supports configuration hot-reload, this feature will be implemented in a future Zerops update.
:::
After restarting, check your service logs to confirm the changes were applied successfully.
### JetStream Configuration
The service includes [JetStream](https://docs.nats.io/nats-concepts/jetstream) functionality **enabled by default**, providing persistent storage capabilities for your messaging workloads:
- **Memory store**: Up to 40GB for high-performance message caching
- **File store**: Up to 250GB for persistent storage
- **Regular sync intervals**: Ensures data durability and consistency
:::note
In HA deployments, data persistence is further enhanced with 1-minute sync intervals across all nodes, ensuring robust data durability and high availability.
:::
This configuration provides a robust foundation for message persistence while balancing performance and reliability.
:::tip
Disabling JetStream can reduce resource utilization for applications that don't require message persistence.
:::
### Deployment Modes
:::warning
Deployment mode is selected during service creation and cannot be changed later.
:::
#### Non-HA Mode
- Suitable for development and testing
- Data persistence not guaranteed during node failures
- Lower resource requirements
#### HA Mode
- Creates a multi-node NATS cluster
- Configures routes between cluster nodes automatically
- Implements [NATS clustering](https://docs.nats.io/running-a-nats-service/configuration/clustering) for high availability
- Provides improved reliability compared to non-HA deployments
### Authentication Management
Authentication credentials are automatically generated and managed by the platform. The system creates a default user (`zerops`) with a secure 16-character password. You can access these credentials through:
- The service access details in the Zerops GUI
- Environment variables in your service configuration:
  - `user` - Username for authentication (default: "zerops")
  - `password` - Generated secure password
  - `connectionString` - Complete connection string in the format `nats://${dbUser}:${dbPassword}@${hostname}:${port}`
## Health Monitoring
Zerops continuously monitors your NATS service health using built-in health checks:
- **HTTP Health Check**: The system checks the `/healthz` endpoint at port 8222
- **Self-Healing**: The platform automatically recovers unhealthy nodes when issues are detected
### Health Status
You can check the health status of your NATS service:
1. Through the Zerops GUI dashboard
2. By accessing the management interface at port `8222`
## Backup and Recovery
NATS backups are created using filesystem archival:
- **Format**: `.tar.gz` (archive of queue state)
- **Tooling**: Filesystem archival
- **Content**: Captures persistent message state
For backup configuration, scheduling, retention policies, and management options, see the [Zerops Backups](/features/backup) documentation.
### Restoring Backups
To restore a NATS backup:
1. **Download** the backup file (`.tar.gz`) from the Zerops UI
2. **Extract** the archive to access the queue state data
3. **Prepare** your target environment (clear existing data if needed)
4. **Restore** using NATS CLI commands via Zerops VPN or during deployment. Follow the [official NATS documentation](https://docs.nats.io/running-a-nats-service/nats_admin/jetstream_admin/disaster_recovery) for detailed restore procedures.
For assistance with the restoration process, contact Zerops support.
## Support
For advanced configurations or custom requirements:
- Join our [Discord community](https://discord.gg/zerops)
- Contact support via [email](mailto:support@zerops.io)

----------------------------------------

# Nginx > Faq

  Question: How do I enable SEO optimization with prerender.io?
Answer: 
    Zerops provides built-in prerender.io support. Simply set the `PRERENDER_TOKEN` environment variable with your prerender.io service token. See our [prerender.io documentation](/nginx/how-to/env-variables#prerenderio-support) for details.
  

----------------------------------------

# Nginx > How To > Build Pipeline

export const languages = [
    { name: "Node.js", link: "/nodejs/how-to/build-pipeline" },
    { name: "PHP", link: "/php/how-to/build-pipeline" },
    { name: "Python", link: "/python/how-to/build-pipeline" },
    { name: "Go", link: "/go/how-to/build-pipeline" },
    { name: ".NET", link: "/dotnet/how-to/build-pipeline" },
    { name: "Rust", link: "/rust/how-to/build-pipeline" },
    { name: "Java", link: "/java/how-to/build-pipeline" },
]
Zerops provides a customizable build and runtime environment for your static content.
Zerops supports different build environments:
If you just need to deploy your static content, use the [manual deploy](/nginx/how-to/trigger-pipeline#manual-deploy-using-zerops-cli) via Zerops CLI.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: nodejs@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - npm i
        - npm run build
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - dist
        - package.json
        - node_modules
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      cache: node_modules
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: nginx@latest
      # OPTIONAL. Customize the runtime Nginx environment by installing additional
      # dependencies to the base Nginx runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Nginx application is started.
      # initCommands:
      #  - rm -rf ./cache
      # OPTIONAL. Customize the folder that will be used as the root of the publicly
      # accessible web server content. Enter the path relative to the /var/www folder.
      documentRoot: public
      # OPTIONAL. Sets the custom Nginx configuration. The file must be deployed in
      # the runtime container. Enter the path to the file relative to the /var/www folder
      siteConfigPath: site_config.tmpl
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Nginx version for your runtime.
Following options are available for Nginx builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: nodejs@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: nginx@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of Nginx, Zerops command line tool and `composer`, `git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: nodejs@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - nginx@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customize your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customized.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
:::info
If no ports are specified, Zerops adds the port TCP 80 automatically.
:::
:::caution
If you want the web server to listen on other port(s) than `:80`, you must [customize](/nginx/how-to/customize-web-server) your web server configuration as well.
:::
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Nginx static service with hostname = "app" and port = 80 from another service of the same project, simply use `app:80`. Read more about [how to access a Nginx static service](/references/networking/internal-access#basic-service-communication).
:::info
Do not use the port **:443**. All the incoming traffic is terminated on the Zerops internal balancer where the SSL certificate is installed and the request is forwarded to your Nginx static service as a **http://** on the port **:80**.
:::
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customizes the Nginx runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Nginx environment contains {data.alpine.default}, the selected
  major version of Nginx, Zerops command line tool and `composer`, `git` and `wget`. To install
  additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Nginx runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/nginx/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
  
When the prepare cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances.
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the
  selected major version of Nginx, Zerops command line tool and `composer`, `git` and `wget`.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the build section of your chosen technology.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Nginx runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Nginx application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Nginx application is started.
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/nginx/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/nginx/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances.
### documentRoot
_OPTIONAL._ Customizes the folder that will be used as the root of the publicly accessible web server content.
:::info
By default, the document root is configured to `/var/www`.
:::
Customize the folder that will be used as the root of the publicly accessible web server content. Enter the path relative to the `/var/www` folder.
E.g. `documentRoot: public` will set the web server document root to `/var/www/public`.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the folder that will be used as the root of the publicly
      # accessible web server content. Enter the path relative to the /var/www folder.
      documentRoot: public
```
### siteConfigPath
_OPTIONAL._ Sets the custom Nginx configuration.
:::info
If you don't set your custom configuratiin Zerops applies the [default](/nginx/how-to/customize-web-server#default-nginx-configuration) configuration.
:::
The file must be deployed in the runtime container. Enter the path to the file relative to the `/var/www` folder.
Read more about the [web server customization](/nginx/how-to/customize-web-server).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/nginx/how-to/env-variables) in Zerops.
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the folder that will be used as the root of the publicly
      # accessible web server content. Enter the path relative to the /var/www folder.
      documentRoot: public
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Nginx application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the folder that will be used as the root of the publicly
      # accessible web server content. Enter the path relative to the /var/www folder.
      documentRoot: public
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/nginx/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/nginx/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Nginx application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/nginx/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Nginx > How To > Controls



----------------------------------------

# Nginx > How To > Create

The Nginx static service contains the Nginx web server optimized for your static content. Nginx static service is highly scalable and customisable to suit both development and production.
## Create Nginx static service using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new Nginx static service:
### Choose Nginx version
Following Nginx versions are currently supported:
:::info
You can [change](/nginx/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app","cache", "gui" etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
- maximum 25 characters
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created. It can't be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as password, tokens, salts, certificates etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting the secret environment variables is optional. You can set them later in Zerops GUI.
Read more about [different types of env variables](/nginx/how-to/env-variables#service-env-variables) in Zerops.
## Create Nginx static service using zCLI
zCLI is the Zerops command-line tool. To create a new Nginx static service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/nginx/how-to/create#create-a-project-description-file)
3. [Create a project with a Nginx and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a yaml format to describe the project infrastructure.
#### Basic example:
Create a directory `my-project`. Create an `description.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in nginx@{version} format
    type: nginx@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Nginx version 8.1 service with default [auto scaling](/nginx/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/nginx/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Nginx static service
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in nginx@{version} format
    type: nginx@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create secret env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain an Nginx static service with `app` hostname. The internal port(s) the service listens on will be defined later in the [zerops.yaml](/nginx/how-to/build-pipeline#ports). Nginx static service will run on version 1.22 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      
      description
      Optional. Description of the new project.
      Maximum 255 characters.
    
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains an Nginx static service but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
        hostname
      
        The unique service identifier.
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
        type
      
        Specifies the service type and version.
        
        See what [nginx service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
        verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        All verticalAutoscaling attributes are optional. Not specified
        attributes will be set to their default values.
      
         - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
         - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
         - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
         - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
        minContainers
      
        Optional. Default = 1. Defines the minimum number of containers
        for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        envSecrets
      
        Optional. Defines one or more secret env variables as a key value
        map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Nginx static service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in nginx@{version} format
    type: nginx@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Nginx static service version 1.22 with default [auto scaling](/nginx/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Nginx > How To > Customize Runtime

## Build Custom Runtime Images
Zerops allows you to build custom runtime images (CRI) when the default base runtime images don't meet your Nginx Static application's requirements. This is an optional phase in the [build and deploy pipeline](/features/pipeline#runtime-prepare-phase-optional).
:::important
You should not include your application code in the custom runtime image, as your built/packaged code is deployed automatically into fresh containers.
:::
## Configuration
### Default Nginx Static Runtime Environment
The default Nginx Static runtime environment contains:
- {data.alpine.default}
- Selected version of Nginx when the runtime service was created
- [zCLI](/references/cli)
- Git
### When You Need a Custom Runtime Image
If your Nginx Static service needs additional tools beyond the default environment (SSL management, monitoring, security tools, etc.), you'll need to build a custom runtime image.
Here are Nginx Static-specific examples of configuring custom runtime images in your `zerops.yml`:
### Basic Nginx Static Setup
    
For complete configuration details, see the [runtime prepare phase configuration guide](/features/pipeline#configuration).
## Process and Caching
### How Runtime Prepare Works
The runtime prepare process follows the same steps for all runtimes. See [how runtime prepare works](/features/pipeline#how-it-works) for the complete process details.
### Caching Behavior
Zerops caches custom runtime images to optimize deployment times. Learn about [custom runtime image caching](/features/pipeline#custom-runtime-image-caching) including when images are cached and reused.
### Build Management
For information about managing builds and deployments, see [managing builds and deployments](/features/pipeline#manage-builds-and-deployments).
:::warning
Shared storage mounts are not available during the runtime prepare phase.
:::
## Troubleshooting
If your `prepareCommands` fail, check the [prepare runtime log](/nginx/how-to/logs#prepare-runtime-log) for specific error messages.

----------------------------------------

# Nginx > How To > Customize Web Server

## Default Nginx configuration
The default Nginx static service has following configuration:
```
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    root {{.DocumentRoot}};
    location / {
        try_files $uri $uri/ /index.html;
    }
    access_log syslog:server=unix:/dev/log,facility=local1,tag=nginx,severity=info default_short;
    error_log syslog:server=unix:/dev/log,facility=local1,tag=nginx,severity=error;
}
```
The configuration contains 2 variables:
- **`{{.DocumentRoot}}`** is replaced by the `run.documentRoot` attribute from the `zerops.yaml`. If the attribute is not specified, the default value `/var/www` is used.
## Customize Nginx configuration
Follow these steps to customize the Nginx configuration in Nginx static service:
1. Create a **.tmpl** file with the Nginx configuration in your repository.
2. Optionally use following variables:
- **`{{.DocumentRoot}}`** is replaced by the `run.documentRoot` attribute from the `zerops.yaml`. If the attribute is not specified, the default value `/var/www` is used.
Example:
```
root {{.DocumentRoot}};
```
- **`{{.Environment.ENV_NAME}}`** is replaced by the [env variable](/nginx/how-to/env-variables) value. The env variable must be either defined in [run.envVariables](/nginx/how-to/build-pipeline#envvariables) in `zerops.yaml` or set as a [secret](/nginx/how-to/env-variables#set-secret-env-variables-in-zerops-gui) or [generated](/nginx/how-to/env-variables#generated-env-variables) env variable in Zerops GUI.
:::caution
Use the **.tmpl** file extension to make Zerops interpret the file as a template. Zerops will replace the supported variables listed above.
:::
3. Check that your Nginx configuration is consistent with Zerops requirements:
- Do not use IP addresses in the `listen` directive
- If you use other ports than `:80` in the `listen` directive, add them to the `run.ports` in your `zerops.yaml` as well.
- Do not use the port **:443**. All the incoming `https://` traffic is terminated on the Zerops internal balancer where the SSL certificate is installed and the request is forwarded to your Nginx static service as a **http://** on the port **:80**.
4. Add the `siteConfigPath` to the run section of your `zerops.yaml`
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: nodejs@latest
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - vendor
        - public
    # ==== how to run your application ====
    run:
      documentRoot: public
      # OPTIONAL. Sets the custom Nginx or Apache configuration. The file must be deployed in the runtime container. Enter the path to the file relative to the /var/www folder
      siteConfigPath: site_config.tmpl
```
5. Ensure that the `build.deployFiles` contains the folder with the `siteConfigPath` or add the path to the Nginx config file to the `deployFiles` list. Zerops will deploy the file to the runtime container(s).
6. [Trigger](/nginx/how-to/trigger-pipeline) the build & deploy pipeline.
### Built-in Prerender.io Support
The default Nginx configuration includes automatic prerender.io support for SEO optimization. When `PRERENDER_TOKEN` is set, Nginx will automatically serve pre-rendered content to search engines and social media crawlers.
See [environment variables](/nginx/how-to/env-variables#prerenderio-support) for configuration details.

----------------------------------------

# Nginx > How To > Delete



----------------------------------------

# Nginx > How To > Deploy Process



----------------------------------------

# Nginx > How To > Env Variables

## Prerender.io Support
Zerops provides built-in prerender.io support for SEO optimization. Configure it using these environment variables:
  
      Variable
      Required
      Description
      Default
    
      PRERENDER_TOKEN
      Yes
      Your prerender.io service token
      -
    
      PRERENDER_HOST
      No
      Prerender service host
      service.prerender.io
    
:::tip
Set `PRERENDER_TOKEN` as a secret environment variable in Zerops GUI for security.
:::
Example in zerops.yaml:
```yaml
zerops:
  - setup: app
    run:
      envVariables:
        PRERENDER_HOST: "custom.prerender.host"
```

----------------------------------------

# Nginx > How To > Filebrowser



----------------------------------------

# Nginx > How To > Logs



----------------------------------------

# Nginx > How To > Scaling



----------------------------------------

# Nginx > How To > Shared Storage



----------------------------------------

# Nginx > How To > Trigger Pipeline



----------------------------------------

# Nginx > How To > Upgrade



----------------------------------------

# Nginx > Overview

The Nginx static service contains the [Nginx ↗](https://nginx.org/) web server optimized for your static content.
## How to start
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Nodejs > Faq

  Question: Why is my Node.js build timing out or hanging on interactive prompts?
Answer: 
    If your build process seems to be hanging or timing out, check your logs for interactive prompts that are waiting for input, such as:
    ```
    ? The modules directory at "/build/source/node_modules" will be removed and reinstalled from scratch. Proceed? (Y/n) ‣ true
    ```
    Set the environment variable `CI: true` to resolve the problem. This allows the installation to proceed automatically without requiring manual confirmation.
  

----------------------------------------

# Nodejs > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Node.js application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: nodejs@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - npm i
        - npm run build
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - dist
        - package.json
        - node_modules
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      cache: node_modules
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: nodejs@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 3000
      # OPTIONAL. Customize the runtime Node.js environment by installing additional
      # dependencies to the base Node.js runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Node.js application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your Node.js application start command
      start: npm start
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Node.js builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: nodejs@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  major version of Node.js, Zerops command line tool, `npm`, `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - nodejs@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customize your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customized.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customizes the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of Node.js defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `npm`, `yarn`, `git` and `npx` tools
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: nodejs@latest
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/nodejs/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: nodejs@latest
      # OPTIONAL. Build your application
      buildCommands:
        - npm i
        - npm run build
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
buildCommands:
  - |
    npm i
    npm run build
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
buildCommands:
  - npm i
  - npm run build
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/nodejs/how-to/logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the --verbose option.
```yaml
buildCommands:
  - npm i --verbose
  - npm run build
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - dist
  - package.json
  - node_modules
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - dist
  - package.json
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: nodejs@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/nodejs/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Node.js version for your runtime.
Following options are available for Node.js builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: nodejs@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: nodejs@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of Node.js, Zerops command line tool, `npm`, `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: nodejs@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - nodejs@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customize your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customized.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Node.js service with hostname = "app" and port = 3000 from another service of the same project, simply use `app:3000`. Read more about [how to access a Node.js service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customises the Node.js runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Node.js environment contains {data.alpine.current} the selected
  major version of Node.js, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools. To install
  additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Node.js runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/nodejs/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
When the custom runtime cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.current}, the
  selected major version of Node.js, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Node.js runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Node.js application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Node.js application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/nodejs/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/nodejs/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        NODE_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/nodejs/how-to/env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your Node.js application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Node.js application start command
      start: npm start
```
We recommend starting your Node.js application using `npm start`.
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Node.js application start command
      start: npm start
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Node.js application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Node.js application start command
      start: npm start
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/nodejs/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/nodejs/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Node.js application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/nodejs/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Nodejs > How To > Build Process



----------------------------------------

# Nodejs > How To > Controls



----------------------------------------

# Nodejs > How To > Create

Zerops provides a powerful Node.js runtime service with extensive build support. The Node.js runtime is highly scalable and customizable to suit your development and production needs. With just a few clicks or commands, you can have a production-ready Node.js environment up and running in no time.
## Create a Node.js service using Zerops GUI
First, set up a project in the Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu under the **Services** section. From there, you can add a new Node.js service:
### Choose a Node.js version
Zerops supports the following Node.js versions:
:::info
You can easily [upgrade](/nodejs/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app", "cache", "gui", etc. Duplicate services with the same name within the same project are not allowed.
#### Limitations:
- Maximum 25 characters
- Must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created and cannot be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as passwords, tokens, salts, certificates, etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting secret environment variables is optional. You can always set them later in the Zerops GUI.
Read more about the [different types of environment variables](/nodejs/how-to/env-variables#service-env-variables) in Zerops.
## Create a Node.js service using zCLI
zCLI is the Zerops command-line tool. To create a new Node.js service via the command line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/nodejs/how-to/create#create-a-project-description-file)
3. [Create a project with a Node.js and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a YAML format to describe the project infrastructure.
#### Basic example:
Create a directory called `my-project`. Inside the `my-project` directory, create a `description.yaml` file with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in nodejs@{version} format
    type: nodejs@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Node.js version 20 service with default [auto scaling](/nodejs/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/nodejs/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Node.js and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in nodejs@{version} format
    type: nodejs@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Node.js service and a [PostgreSQL](/postgresql/overview) service.
Node.js service with "app" hostname, the internal port(s) the service listens on will be defined later in the [zerops.yaml](/nodejs/how-to/build-pipeline#ports). Node.js service will run on version 20 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      
      description
      Optional. Description of the new project.
      Maximum 255 characters.
    
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains Node.js and PostgreSQL services but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
         
        The hostname of the new database will be set to the `hostname` value.
         
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the service type and version.
        
        See what [Node.js service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
      verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
      - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
      - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
      - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
      - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
      minContainers
      
        Optional. Default = 1. Defines the minimum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      envSecrets
      
        Optional. Defines one or more secret env variables as a key value map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Node.js service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in nodejs@{version} format
    type: nodejs@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Node.js service version 20 with default [auto scaling](/nodejs/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Nodejs > How To > Customize Runtime

System packages for processing: When your app processes images, videos, or files (requiring packages like sudo apk add imagemagick, sudo apk add ffmpeg)',
  'Global Node.js tools: When you need CLI tools or utilities available system-wide (like pm2 for process management)',
  'Native dependencies: When your npm packages require system libraries that aren\'t in the default environment',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />

----------------------------------------

# Nodejs > How To > Delete



----------------------------------------

# Nodejs > How To > Deploy Process



----------------------------------------

# Nodejs > How To > Env Variables



----------------------------------------

# Nodejs > How To > Filebrowser



----------------------------------------

# Nodejs > How To > Logs



----------------------------------------

# Nodejs > How To > Scaling



----------------------------------------

# Nodejs > How To > Shared Storage



----------------------------------------

# Nodejs > How To > Trigger Pipeline



----------------------------------------

# Nodejs > How To > Upgrade



----------------------------------------

# Nodejs > Overview

[Node.js ↗](https://nodejs.org/en) is an asynchronous event-driven JavaScript runtime, which is designed to build scalable network applications.
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-nodejs), a **_recipe_**, containing the most simple Node.js web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of Node.js app running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-nodejs/blob/main/zerops-project-import.yaml)):
```yaml
project:
  name: recipe-nodejs
  tags:
    - zerops-recipe
services:
  - hostname: api
    type: nodejs@20
    enableSubdomainAccess: true
    buildFromGit: https://github.com/zeropsio/recipe-nodejs
  - hostname: db
    type: postgresql@16
    mode: NON_HA
    priority: 1
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://helloworld-24-8080.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
Hello, World!
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
It doesn't matter whether it's your first curious introduction to Zerops, you have already mastered the basics and are looking for a tiny detail or inspiration. Below, choose a section that fits your needs:
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Object Storage > How To > Access

Zerops Object storage is powered by [MinIO](https://min,io), a high-performance, S3 compatible object store. Object storage services are operated on an independent infrastructure separated from your other project services. You can access the object storage from any service hosted in Zerops or remotely over the internet.
## Object storage bucket
Zerops creates one bucket automatically for each new Object storage service.
:::note
Each Object storage service can only contain one bucket. If your application needs multiple buckets, add more Object storage services.
:::
#### Name
Bucket is created with a name based on the selected service name and a random prefix. The name of the bucket cannot be changed later.
#### Access policy
The bucket's access policy was defined when the Object storage service was created. You can [change it] later in Zerops GUI.
#### Quota
The bucket quota size was defined when the Object storage service was created. You can [change it] later in Zerops GUI.
## Copy access details from Zerops GUI
You will find the Object storage access details under the **Access details** button in the project dashboard page.
The same information is available in the service detail page under the **Access & bucket details** menu.
  
### Object storage access parameters
  
      Parameter
      Description
    
      API URL
      URL of the Object storage service
    
      Bucket Name
      Bucket is created with a name based on the selected service name and a random prefix. The name of the bucket is fixed and cannot be changed later.
    
      Access Key ID
      The S3 Access Key ID
    
      Secret Key
      The S3 Secret Key
    
## Use Object storage environment variables
Zerops creates default environment variables for each Object storage service to help you with connection from any runtime services in the same project. To avoid the need to copy Object storage access parameters manually, use environment variables in your runtime service.
### Prefix the environment variable key
All services of the same project can reference environment variables from other services. To use an environment variable from one service in another service in the same project, you must prefix the environment variable key with the service name and underscore.
#### Example
To access the `bucketName` env variable of the `upload` service, use `upload_bucketName` as the env variable key. To access the `secretAccessKey` env variable of the `storage` service, use `storage_secretAccessKey` as the env variable key.
### Object storage environment variables
List of service environment variables is available in Zerops GUI. Go to an Object storage service detail and choose **Environment variables** in the left menu.
  
Zerops creates following environment variables when the Object storage service is created:
  
      Variable
      Description
    
      apiUrl
      URL of the Object storage service
    
      accessKeyId
      The S3 Access Key ID
    
      secretAccessKey
      The S3 Secret Key
    
      bucketName
      Bucket is created with a name based on the selected service name and a random prefix. The name of the bucket is fixed and cannot be changed later.
    
      quotaGBytes
      The bucket quota in GB.
    
      projectId
      ID of the project. Generated by Zerops.
    
      serviceId
      ID of the Object storage service. Generated by Zerops.
    
      hostname
      The name of the Object storage service.
    

----------------------------------------

# Object Storage > How To > Create

Zerops provides a S3 compatible Object storage service to store your files. Zerops Object storage is powered by [MinIO](https://min.io), a high-performance, S3 compatible object store. MinIO is built for large scale AI/ML, data lake and database workloads.
## Create Object storage service using Zerops GUI
First, set up a project in Zerops GUI and add a runtime service. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new Object storage service:
### Set a name
Enter a unique service identifier like `storage`,`s3` etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
maximum 25 characters
must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::note
The name is fixed after the service is created. It can't be changed later.
:::
### Object storage bucket
Zerops creates one bucket automatically for each new Object storage service.
:::note
Each Object storage service can only contain one bucket. If your application needs multiple buckets, add more Object storage services.
:::
#### Name
Bucket will be created with a name based on the given service name and a random prefix. The name of the bucket cannot be changed later.
#### Access policy
Select one of the basic policy templates:
  
      Template
      Description
    
      Public read
      
        Allows anyone:
        
          to read the bucket's location `(s3:GetBucketLocation)`
          to list all bucket's objects `(s3:ListBucket)`
          to get any object of the bucket `(s3:GetObject)`
        
      Public objects read
      
        Allows anyone:
        
          to read the bucket's location `(s3:GetBucketLocation)`
          to get any object of the bucket `(s3:GetObject)`
        
      Public read write
      
        Allows anyone:
        
          to read the bucket's location `(s3:GetBucketLocation)`
          to list all bucket's objects `(s3:ListBucket)`
          to get any object of the bucket `(s3:GetObject)`
          to create a new object in the bucket `(s3:PutObject,s3:ListMultipartUploadParts, s3:AbortMultipartUpload, s3:ListBucketMultipartUploads)`
          to delete any object of the bucket `(s3:DeleteObject)`
        
      Public write
      Allows anyone to create objects in the bucket `(PutObject action)`
    
      Private
      Denies the access to unauthenticated users.
    
Or you can set your own access policy in the [IAM Policy JSON format](https://min.io/docs/minio/linux/administration/identity-access-management/policy-based-access-control.html#policy-document-structure).
#### Example:
```yaml
{
  'Version': '2012-10-17',
  'Statement':
    [
      {
        'Effect': 'Allow',
        'Principal': { 'AWS': ['*'] },
        'Action': ['s3:GetBucketLocation', 's3:ListBucket'],
        'Resource': ['arn:aws:s3:::{{.BucketName}}'],
      },
      {
        'Effect': 'Allow',
        'Principal': { 'AWS': ['*'] },
        'Action': ['s3:GetObject'],
        'Resource': ['arn:aws:s3:::{{.BucketName}}/*'],
      },
    ],
}
```
:::tip
The `{{ .BucketName }}` variable will be replaced by the bucket name.
:::
The bucket's policy can be changed later in Zerops GUI.
#### Quota
Set the bucket quota size in GB. The quota must be set manually. It can be changed later in Zerops GUI. Zerops doesn't support Object storage autoscaling. You can set the bucket quota from 1 to 100 GB.
  
## Create Object storage using zCLI
zCLI is the Zerops command-line tool. To create a new Object storage service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](#create-a-project-description-file)
3. Create a project and an Object storage service
### Create a project description file
Zerops uses a yaml format file to describe the project infrastructure.
#### Example
Create a directory `my-project`. Create a `description.yaml` file inside the directory with the following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with an Object storage
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: upload
    # service type
    type: objectstorage
    # Object storage size in GB
    objectStorageSize: 73
    # Choose object storage policy from a predefined list
    objectStoragePolicy: public-write
    # Or define a custom policy
    objectStorageRawPolicy:
```
The yaml file describes your future project infrastructure. The project will contain one Object storage service named `upload`. The bucket quota will be set to 73 GB and the bucket access policy will be set to `public-write`.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      Maximum 255 characters
    
      description
      Optional. Description of the new project.
      
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains only Object storage service but you can create a description.yaml with different types of services.
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
         
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the Object storage type objectstorage and version.
        
        Set type: `objectstorage`
         
        Limitations:
        
        Currently `objectstorage` or `object-storage` is available.
      
      objectStorageSize
      
        The size of the bucket quota in GB.
         
        Limitations:
        
        Set a whole number between 1 and 100.
      
      objectStoragePolicy
      
        Optional. Either `objectStoragePolicy` or `objectStorageRawPolicy` is required.
         
        Set one of allowed values:
        
          `public-read`
          `public-objects-read`
          `public-read-write`
          `public-write`
          `private`
        
        Read more about the basic policy templates.
      
      objectStorageRawPolicy
      
        Optional. Either `objectStoragePolicy` or `objectStorageRawPolicy` is required.
         
        Set your own access policy in the IAM Policy JSON format.
         
        The `{{ .BucketName }}` variable will be replaced by the bucket name.
      
Zerops creates one bucket automatically for each new Object storage service.
:::note
Each Object storage service can only contain one bucket. If your application needs multiple buckets, add more Object storage services.
:::
Bucket will be created with a name based on the given service name and a random prefix. The name of the bucket cannot be changed later.
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Object service to an existing project
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# array of project services
services:
  - # service name
    hostname: upload
    # service type
    type: objectstorage
    # Object storage size in GB
    objectStorageSize: 73
    # Choose object storage policy from a predefined list
    objectStoragePolicy: public-write
    # Or define a custom policy
    objectStorageRawPolicy:
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Object storage service named upload will be created. The bucket quota will be set to 73 GB and the bucket access policy will be set to `public-write`.
The content of the `services:` section of `import.yaml` is identical to the [project description file]. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the `import.yaml` file is 100 kB.
#### Example
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```bash
# array of project services
services:
  -
    # service name
    hostname: storage
    # service type
    type: objectstorage
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Object storage service in the single container mode with default auto scaling configuration will be added to your project. Hostname of the new service will be set to `storage`.
The content of the `services:` section of `import.yaml` is identical to the [project description file](#create-a-project-description-file). The `import.yaml` never contains the `project:` section because the project already exists.

----------------------------------------

# Object Storage > How To > Curl File

This guide explains how to download a single file from a private Object Storage bucket using cURL and a bash script with Zerops object storage.
## Prerequisites
- Access to Zerops Object Storage
- Storage credentials (`ACCESS_KEY_ID` and `SECRET_ACCESS_KEY`)
- Bash environment
- OpenSSL and cURL installed
:::caution
Store your storage credentials securely and never commit them to version control.
:::
## Script
Save this script as `download-storage.sh`:
```bash
#!/bin/bash
server="${3:-storage-prg1.zerops.io}"
file_path=$2
bucket=$1
set -eu pipefail
contentType="application/octet-stream"
dateValue=`date -R`
signature_string="GET\n\n${contentType}\n${dateValue}\n/${bucket}/${file_path}"
signature_hash=`echo -en ${signature_string} | openssl sha1 -hmac ${SECRET_ACCESS_KEY} -binary | base64`
curl -sSo ${file_path} \
  -H "Date: ${dateValue}" \
  -H "Content-Type: ${contentType}" \
  -H "Authorization: AWS ${ACCESS_KEY_ID}:${signature_hash}" \
  "https://${server}/${bucket}/${file_path}"
```
## Usage
1. Make the script executable:
```bash
chmod +x download-storage.sh
```
2. Set your storage credentials as environment variables:
```bash
export ACCESS_KEY_ID=your-access-key
export SECRET_ACCESS_KEY=your-secret-key
```
3. Run the script:
```bash
./download-storage.sh my-bucket file.pdf
```
## Troubleshooting
- **Permission Denied**: Check your `ACCESS_KEY_ID` and `SECRET_ACCESS_KEY`
- **File Not Found**: Verify bucket name and file path
- **Script Error**: Ensure the script has execute permissions

----------------------------------------

# Object Storage > How To > Delete



----------------------------------------

# Object Storage > How To > Update Bucket

Zerops creates one bucket automatically for each new Object storage service.
:::note
Each Object storage service can only contain one bucket. If your application needs multiple buckets, add more Object storage services.
:::
To change the bucket size or the access policy, go to the **Access & bucket details** in the Object service detail in Zerops GUI, scroll down and click on the **Configure bucket quota size and access policy** button.
  
### Quota
Set the bucket quota size in GB. The quota must be set manually. It can be changed later in Zerops GUI. Zerops doesn't support Object storage autoscaling. You can set the bucket quota from 1 to 100 GB.
### Access policy
Zerops creates one bucket automatically for each new Object storage service.
:::note
Each Object storage service can only contain one bucket. If your application needs multiple buckets, add more Object storage services.
:::
#### Name
Bucket will be created with a name based on the given service name and a random prefix. The name of the bucket cannot be changed later.
#### Access policy
Select one of the basic policy templates:
| Template                   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| <b>Public read</b>         | Allows anyone:<ul><li>to read the bucket's location `(s3:GetBucketLocation)`</li><li>to list all bucket's objects `(s3:ListBucket)`</li><li>to get any object of the bucket `(s3:GetObject)`</li></ul>                                                                                                                                                                                                                                        |
| <b>Public objects read</b> | Allows anyone:<ul><li>to read the bucket's location `(s3:GetBucketLocation)`</li><li>to get any object of the bucket `(s3:GetObject)`</li></ul>                                                                                                                                                                                                                                                                                                          |
| <b>Public read write</b>   | Allows anyone:<ul><li>to read the bucket's location `(s3:GetBucketLocation)`</li><li>to list all bucket's objects `(s3:ListBucket)`</li><li>to get any object of the bucket `(s3:GetObject)`</li><li>to create a new object in the bucket `(s3:PutObject,s3:ListMultipartUploadParts, s3:AbortMultipartUpload, s3:ListBucketMultipartUploads)`</li><li>to delete any object of the bucket `(s3:DeleteObject)`</li></ul> |
| <b>Public write</b>        | Allows anyone to create objects in the bucket `(PutObject action)`                                                                                                                                                                                                                                                                                                                                                                                                  |
| <b>Private</b>             | Denies the access to unauthenticated users.                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| <b>Private</b>             | Denies the access to unauthenticated users.                                                                                                                                                                                                                                                                                                                                                                                                                                    |
Or you can set your own access policy in the [IAM Policy JSON format](https://min.io/docs/minio/linux/administration/identity-access-management/policy-based-access-control.html#policy-document-structure).
#### Example:
```yaml
{
  'Version': '2012-10-17',
  'Statement':
    [
      {
        'Effect': 'Allow',
        'Principal': { 'AWS': ['*'] },
        'Action': ['s3:GetBucketLocation', 's3:ListBucket'],
        'Resource': ['arn:aws:s3:::{{.BucketName}}'],
      },
      {
        'Effect': 'Allow',
        'Principal': { 'AWS': ['*'] },
        'Action': ['s3:GetObject'],
        'Resource': ['arn:aws:s3:::{{.BucketName}}/*'],
      },
    ],
}
```
:::tip
The `{{ .BucketName }}` variable will be replaced by the bucket name.
:::

----------------------------------------

# Object Storage > Overview

Zerops Object storage is powered by [MinIO ↗](https://min.io/), a high-performance, open-source S3 compatible object store. MinIO is built for large scale AI/ML, data lake and database workloads.
## Feature Highlights
## Popular Guides
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!

----------------------------------------

# Php > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your PHP application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: php-apache@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - composer install
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - vendor
        - public
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      # cache: vendor
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: php-apache@latest
      # OPTIONAL. Customize the runtime PHP environment by installing additional
      # dependencies to the base PHP runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your PHP application is started.
      # initCommands:
      #  - rm -rf ./cache
      # OPTIONAL. Customize the folder that will be used as the root of the publicly
      # accessible web server content. Enter the path relative to the /var/www folder.
      documentRoot: public
      # OPTIONAL. Sets the custom Nginx or Apache configuration. The file must be deployed in
      # the runtime container. Enter the path to the file relative to the /var/www folder
      siteConfigPath: site_config.tmpl
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for PHP builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: php-apache@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  major version of PHP, Zerops command line tool, `composer`, `git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - php-apache@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customise your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customises the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of PHP defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `composer`, `git` and `wget`
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: php-apache@latest
      # OPTIONAL. Customise the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/php/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: php-apache@latest
      # OPTIONAL. Build your application
      buildCommands:
        - composer install
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
buildCommands:
  - |
    composer install --optimize-autoloader --no-dev
    php artisan env
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
buildCommands:
  - composer install --optimize-autoloader --no-dev
  - php artisan env
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/php/how-to/logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the verbose option.
```yaml
buildCommands:
  - composer install -v
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - vendor
  - public
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - public
  - file.txt
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: php-apache@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        PHP_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/php/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current PHP version for your runtime.
Following options are available for PHP builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: php-apache@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: php-apache@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of PHP, Zerops command line tool and `composer`, `git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: php-apache@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - php-apache@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customise your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
:::info
If no ports are specified, Zerops adds the port TCP 80 automatically.
:::
:::caution
If you want the web server to listen on other port(s) than `:80`, you must [customize](/php/how-to/customize-web-server) your web server configuration as well.
:::
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a PHP service with hostname = "app" and port = 80 from another service of the same project, simply use `app:80`. Read more about [how to access a PHP service](/references/networking/internal-access#basic-service-communication).
:::info
Do not use the port **:443**. All the incoming traffic is terminated on the Zerops internal balancer where the SSL certificate is installed and the request is forwarded to your PHP+Nginx / PHP+Apache service as a **http://** on the port **:80**.
:::
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customises the PHP runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base PHP environment contains {data.alpine.default}, the selected
  major version of PHP, Zerops command line tool and `composer`, `git` and `wget`. To install
  additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base PHP runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/php/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
  
When the prepare cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the
  selected major version of PHP, Zerops command line tool and `composer`, `git` and `wget`.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base PHP runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your PHP application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your PHP application is started.
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/php/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/php/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### documentRoot
_OPTIONAL._ Customizes the folder that will be used as the root of the publicly accessible web server content.
:::info
By default, the document root is configured to `/var/www`.
:::
Customize the folder that will be used as the root of the publicly accessible web server content. Enter the path relative to the `/var/www` folder.
E.g. `documentRoot: public` will set the web server document root to `/var/www/public`.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the folder that will be used as the root of the publicly
      # accessible web server content. Enter the path relative to the /var/www folder.
      documentRoot: public
```
### siteConfigPath
_OPTIONAL._ Sets the custom Nginx or Apache configuration.
:::info
By default, the default [nginx](/php/how-to/customize-web-server#default-nginx-configuration) or [Apache](/php/how-to/customize-web-server#default-apache-configuration) web server configuration is set.
:::
The file must be deployed in the runtime container. Enter the path to the file relative to the `/var/www` folder.
Read more about the [web server customization](/php/how-to/customize-web-server).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        PHP_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/php/how-to/env-variables) in Zerops.
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the folder that will be used as the root of the publicly
      # accessible web server content. Enter the path relative to the /var/www folder.
      documentRoot: public
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your PHP application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the folder that will be used as the root of the publicly
      # accessible web server content. Enter the path relative to the /var/www folder.
      documentRoot: public
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/php/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/php/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your PHP application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/php/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Php > How To > Build Process



----------------------------------------

# Php > How To > Controls



----------------------------------------

# Php > How To > Create

Zerops provides 2 PHP services with an included web server: **PHP+Nginx** and **PHP+Apache**. PHP runtime is highly scalable and customisable to suit both development and production.
## Create PHP service using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new PHP service:
### Choose PHP version
Following PHP versions are currently supported:
:::info
You can [change](/php/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app","cache", "gui" etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
- maximum 25 characters
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created. It can't be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as password, tokens, salts, certificates etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting the secret environment variables is optional. You can set them later in Zerops GUI.
Read more about [different types of env variables](/php/how-to/env-variables#service-env-variables) in Zerops.
## Create PHP service using zCLI
zCLI is the Zerops command-line tool. To create a new PHP service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/php/how-to/create#create-a-project-description-file)
3. [Create a project with a PHP and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a yaml format to describe the project infrastructure.
#### Basic example:
Create a directory `my-project`. Create an `description.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in php-apache@{version} or php-nginx@{version} format
    type: php-nginx@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one PHP version 8.1 service with default [auto scaling](/php/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/php/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a PHP and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in php-apache@{version} or php-nginx@{version} format
    type: php-nginx@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create secret env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a PHP service and a [PostgreSQL](/postgresql/overview) service.
PHP service with "app" hostname, the internal port(s) the service listens on will be defined later in the [zerops.yaml](/php/how-to/build-pipeline#ports). PHP service will run on version 8.1 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      
      description
      Optional. Description of the new project.
      Maximum 255 characters.
    
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains PHP and PostgreSQL services but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
         
        The hostname of the new service will be set to the `hostname` value.
         
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the service type and version.
        
        See what [PHP service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
      verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
      - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
      - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
      - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
      - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
      minContainers
      
        Optional. Default = 1. Defines the minimum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      envSecrets
      
        Optional. Defines one or more secret env variables as a key value map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add PHP service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in php-apache@{version} or php-nginx@{version} format
    type: php-nginx@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one PHP service version 8.1 with default [auto scaling](/php/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Php > How To > Customize Runtime

System packages for processing: When your app processes images, videos, or files (requiring packages like sudo apk add --no-cache imagemagick)',
  'PHP extensions: When you need additional PHP extensions not included by default',
  'Native dependencies: When your Composer packages require system libraries that aren\'t in the default environment',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />
## Overwrite php.ini files
You can override PHP configuration directives by setting environment variables in your `zerops.yaml` file.
Here's an example of how to adjust PHP's `post_max_size` directive:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    run:
      # REQUIRED. Sets the base technology for the build environment:
      base: php-nginx@8.3
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        PHP_INI_post_max_size: 10M
```

----------------------------------------

# Php > How To > Customize Web Server

## PHP + Nginx
### Default Nginx configuration
The default PHP+Nginx service has following Nginx configuration:
```
server {
    listen 80;
    listen [::]:80;
    server_name _;
    # Be sure that you set up the correct document root!
    root {{.DocumentRoot}};
    location ~ \.php {
        try_files _ @backend;
    }
    location / {
        # use this for pretty url
        try_files $uri /$uri /index.html /index.php$is_args$args;
    }
    location @backend {
        fastcgi_pass unix:{{.PhpSocket}};
        fastcgi_split_path_info ^(.+\.php)(/.*)$;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;
        fastcgi_param DOCUMENT_ROOT $realpath_root;
        internal;
    }
    access_log syslog:server=unix:/dev/log,facility=local1,tag=nginx,severity=info default_short;
    error_log syslog:server=unix:/dev/log,facility=local1,tag=nginx,severity=error;
}
```
The configuration contains 2 variables:
- **`{{.DocumentRoot}}`** is replaced by the `run.documentRoot` attribute from the `zerops.yaml`. If the attribute is not specified, the default value `/var/www` is used.
- **`{{.PhpSocket}}`** is replaced by a path to the PHP socket based on the PHP version.
### Customize Nginx configuration
Follow these steps to customize the Nginx configuration in PHP+Nginx service:
1. Create a **.tmpl** file with the Apache configuration in your repository.
2. Optionally use following variables:
- **`{{.DocumentRoot}}`** is replaced by the `run.documentRoot` attribute from the `zerops.yaml`. If the attribute is not specified, the default value `/var/www` is used.
Example:
```
root {{.DocumentRoot}};
```
- **`{{.PhpSocket}}`** is replaced by a path to the PHP socket based on the PHP version.
Example:
```
fastcgi_pass unix:{{.PhpSocket}};
```
- **`{{.Environment.ENV_NAME}}`** is replaced by the [env variable](/php/how-to/env-variables) value. The env variable must be either defined in [run.envVariables](/php/how-to/build-pipeline#envvariables-1) in `zerops.yaml` or set as a [secret](/php/how-to/env-variables#set-secret-env-variables-in-zerops-gui) or [generated](/php/how-to/env-variables#generated-env-variables) env variable in Zerops GUI.
:::caution
Use the **.tmpl** file extension to make Zerops interpret the file as a template. Zerops will replace the supported variables listed above.
:::
3. Check that your Nginx configuration is consistent with Zerops requirements:
- Do not use IP addresses in the `listen` directive
- If you use other ports than `:80` in the `listen` directive, add them to the `run.ports` in your `zerops.yaml` as well.
- Do not use the port **:443**. All the incoming `https://` traffic is terminated on the Zerops internal balancer where the SSL certificate is installed and the request is forwarded to your PHP+Nginx service as a **http://** on the port **:80**.
4. Add the `siteConfigPath` to the run section of your `zerops.yaml`
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: php-nginx@latest
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - vendor
        - public
    # ==== how to run your application ====
    run:
      documentRoot: public
      # OPTIONAL. Sets the custom Nginx or Apache configuration. The file must be deployed in the runtime container. Enter the path to the file relative to the /var/www folder
      siteConfigPath: site_config.tmpl
```
5. Ensure that the `build.deployFiles` contains the folder with the `siteConfigPath` or add the path to the Nginx config file to the `deployFiles` list. Zerops will deploy the file to the runtime container(s).
6. [Trigger](/php/how-to/trigger-pipeline) the build & deploy pipeline.
## PHP + Apache
### Default Apache configuration
The default PHP+Apache service has following Apache configuration:
```
    ServerName localhost
    DocumentRoot {{.DocumentRoot}}
    DirectoryIndex index.htm index.html index.shtml index.php index.phtml
    
        Options -Indexes
        Options FollowSymLinks
        AllowOverride All
        Require all granted
    
            SetHandler "proxy:unix:{{.PhpSocket}}|fcgi://localhost/"
        
    ErrorLog  "| /usr/bin/logger -tapache -plocal1.err"
    CustomLog "| /usr/bin/logger -tapache -plocal1.notice" combined
```
The configuration contains 2 variables:
- **`{{.DocumentRoot}}`** is replaced by the `run.documentRoot` attribute from the `zerops.yaml`. If the attribute is not specified, the default value `/var/www` is used.
- **`{{.PhpSocket}}`** is replaced by a path to the PHP socket based on the PHP version.
### Customize Apache configuration
Follow these steps to customize the Apache configuration in PHP+Apache service:
1. Create a **.tmpl** file with the Nginx configuration in your repository.
2. Optionally use following variables:
- **`{{.DocumentRoot}}`** is replaced by the `run.documentRoot` attribute from the `zerops.yaml`. If the attribute is not specified, the default value `/var/www` is used.
Example:
```
DocumentRoot {{.DocumentRoot}};
```
- **`{{.PhpSocket}}`** is replaced by a path to the PHP socket based on the PHP version.
Example:
```
    SetHandler "proxy:unix:{{.PhpSocket}}|fcgi://localhost/"
```
- **`{{.Environment.ENV_NAME}}`** is replaced by the [env variable](/php/how-to/env-variables) value. The env variable must be either defined in [run.envVariables](/php/how-to/build-pipeline#envvariables-1) in `zerops.yaml` or set as a [secret](/php/how-to/env-variables#set-secret-env-variables-in-zerops-gui) or [generated](/php/how-to/env-variables#generated-env-variables) env variable in Zerops GUI.
:::caution
Use the **.tmpl** file extension to make Zerops interpret the file as a template. Zerops will replace the supported variables listed above.
:::
3. Check that your Apache configuration is consistent with Zerops requirements:
- Do not use IP addresses in the `` directive
- If you use other ports than `:80` in the `` directive, add them to the `run.ports` in your `zerops.yaml` as well.
  Do not use the port **:443**. All the incoming `https://` traffic is terminated on the Zerops internal balancer where the SSL certificate is installed and the request is forwarded to your PHP+Apache service as a **http://** on the port **:80**.
4. Add the `siteConfigPath` to the run section of your `zerops.yaml`.
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: php-apache@latest
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - vendor
        - public
    # ==== how to run your application ====
    run:
      documentRoot: public
      # OPTIONAL. Sets the custom Nginx or Apache configuration. The file must be deployed in the runtime container. Enter the path to the file relative to the /var/www folder
      siteConfigPath: site_config.tmpl
```
5. Ensure that the `build.deployFiles` contains the folder with the `siteConfigPath` or add the path to the Apache config file to the `deployFiles` list. Zerops will deploy the file to the runtime container(s).
6. [Trigger](/php/how-to/trigger-pipeline) the build & deploy pipeline.

----------------------------------------

# Php > How To > Delete



----------------------------------------

# Php > How To > Deploy Process



----------------------------------------

# Php > How To > Env Variables



----------------------------------------

# Php > How To > Filebrowser



----------------------------------------

# Php > How To > Logs



----------------------------------------

# Php > How To > Scaling



----------------------------------------

# Php > How To > Shared Storage



----------------------------------------

# Php > How To > Trigger Pipeline



----------------------------------------

# Php > How To > Upgrade



----------------------------------------

# Php > Overview

[PHP ↗](https://www.php.net/), a popular general-purpose scripting language that is especially suited to web development.
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-php-hello-world), a **_recipe_**, containing the most simple PHP web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of PHP running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-php-hello-world/blob/main/import-project/description.yaml)):
```yaml
project:
  name: my-first-project
services:
  - hostname: helloworld
    type: php-apache@8.1+2.4
    minContainers: 1
    maxContainers: 3
    buildFromGit: https://github.com/zeropsio/recipe-php-hello-world@main
    enableSubdomainAccess: true
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://helloworld-24-8080.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
Hello, World!
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Postgresql > Faq

  Question: Why is my connection to PostgreSQL from third-party software failing?
Answer: 
    *One possible cause:* 
    The connection string in Zerops always starts with `postgresql://`. While the official PostgreSQL documentation
    states that both `postgresql://` and `postgres://` URIs are valid, some software requires the shorter `postgres://`
    version.
    
    To resolve this, create your own environment variable with the correct URI. For example, if your PostgreSQL service is named `db`, use the following format:
    
    ```
    postgres://${db_user}:${db_password}@${db_hostname}:${db_port}
    ```
  

----------------------------------------

# Postgresql > How To > Backup

Zerops provides automated data backup for PostgreSQL services with full encryption and flexible management options.
For general backup information including configuration, scheduling, and management options, see the [Zerops Backups](/features/backup) documentation, which covers:
- Backup scheduling and retention policies
- Tagging system and storage quotas
- Manual backup creation and CLI tools
- Security and encryption details
This page focuses on PostgreSQL-specific backup details.
## PostgreSQL Backup Format
PostgreSQL backups are created using `pg_dump` and stored in `.zip` format:
- **Format**: `.zip` (containing per-schema `.dump` files)
- **Tooling**: `pg_dump`
- **Compression**: Custom format (`-Fc`), schema files named `schemaName.dump`
- **Storage**: Encrypted and stored in isolated object storage
## Restoring PostgreSQL Backups
To restore a PostgreSQL backup:
1. **Download** the backup file (`.zip`) from the Zerops UI
2. **Extract** the zip file to access the individual schema dump files
3. **Prepare** your target environment (clean existing data or use a new instance)
4. **Restore** using PostgreSQL native tools. Follow the [official PostgreSQL backup documentation](https://www.postgresql.org/docs/current/backup-dump.html) for detailed restore procedures, or use web-based management tools like phpMyAdmin or Adminer as described in [PostgreSQL Management](/postgresql/how-to/manage).
For assistance with the restoration process, contact Zerops support.
## High Availability
For PostgreSQL services running in High Availability mode:
- Backups are created on a randomly selected healthy node
- Other nodes remain operational during the backup process
- Manual backups typically run on the primary node
## Best Practices
- Always create a manual backup with a protected tag before database migrations or major schema changes
- Test your restore process periodically in a non-production environment
- Monitor your backup storage usage in the Project Overview
- Use descriptive tags like `pre-migration-v2` for important snapshots
- Consider the order of schema restoration if you have dependencies between schemas
For additional best practices and troubleshooting, refer to the [main backup documentation](/features/backup).

----------------------------------------

# Postgresql > How To > Connect

This guide covers how to connect to your PostgreSQL database in Zerops, both from services within the same project and from outside the Zerops environment.
## Connection Options Overview
Zerops provides several ways to connect to PostgreSQL:
1. **Internal connections** - Between services in the same Zerops project (via private network)
2. **Remote connections**:
   - **VPN access** - From your local machine via Zerops VPN
   - **Direct IP access** - Enables external applications to connect using TLS encryption by opening public ports on IPv6 (available by default) or IPv4 (requires add-on activation if not already enabled)
## Connection Details
You'll find internal PostgreSQL connection details in two places in the Zerops GUI:
1. Under the **Access details** button in the project dashboard
2. In the service detail page under the **Peek access details** button
### Connection Parameters
  
      Parameter
      Internal Connection
      Direct IP Access (TLS)
    
      Hostname/IP
      Service hostname
      Public IP address
    
      Port
      5432
      6432
    
      User
      Identical to the service hostname
      Same as internal
    
      Password
      Randomly generated during service creation
      Same as internal
    
      Port env variable
      `port`
      `portTls`
    
      Connection string env variable
      `connectionString`
      `connectionTlsString`
    
:::warning
Zerops creates a system user named `zps` with full privileges for maintenance purposes. Do not delete, change the password, or remove privileges from this user, as it will disrupt Zerops' ability to maintain the database cluster.
:::
:::info
For more information about default PostgreSQL setup, users, and databases, see [Manage PostgreSQL Users and Databases](/postgresql/how-to/manage).
:::
## Connect from Services in the Same Project
All services within a Zerops project share a dedicated private network. There are two ways to implement connections between services in the same project:
### Method 1: Direct Connection Parameters
You can directly use the connection parameters from Access Details:
```
host = database1
port = 5432
user = database1
password = ********** (find under Access Details)
```
### Method 2: Environment Variables (Recommended)
For better maintainability, Zerops creates environment variables for each PostgreSQL service that you can use in your application configuration. List of service environment variables is available in Zerops GUI. Go to a PostgreSQL service detail and choose **Environment variables**.
To use variables from one service in another, prefix the variable name with the service hostname and underscore - to access the `connectionString` variable of `postgresql1`, use `postgresql1_connectionString`.
For more details on how to use environment variables, and instructions for adding your own custom variables, see the [Environment Variables](/features/env-variables) documentation.
:::caution Important notes
- When changing passwords, update both the database user password and the environment variable separately - they don't automatically synchronize.
- While both `postgresql://` and `postgres://` URI formats are valid, Zerops uses the `postgresql://` format. If your software requires `postgres://`, create a custom environment variable with this format.
- Do not use SSL/TLS protocols for internal connections. Security is assured by the project's private network.
:::
## Connect Remotely
Zerops offers two methods for connecting to your PostgreSQL database from outside the Zerops environment:
### Method 1: Connect via Zerops VPN
You can securely connect to PostgreSQL from your local workstation via Zerops VPN:
1. [Install & set up zCLI](/references/cli)
2. [Start the Zerops VPN](/references/networking/vpn#start-vpn)
3. Use the connection details from Access Details in the PostgreSQL service detail in Zerops GUI
4. When finished, [stop the Zerops VPN](/references/networking/vpn#stop-vpn)
:::warning Important notes
* Do not use SSL/TLS protocols when connecting over VPN. Security is provided by the VPN tunnel.
* If your connection over VPN doesn't work, try adding `.zerops` suffix to the service hostname (e.g., `database1.zerops`). For additional help, check the [VPN troubleshooting page](/references/networking/vpn#troubleshooting).
:::
### Method 2: Connect via Direct IP Access
Direct IP Access uses [pgBouncer](https://www.pgbouncer.org/) for connection pooling and TLS termination.
Internally, port `5432` is available without SSL. Externally, connections are secured with TLS through pgBouncer (port `6432`) before being routed to your PostgreSQL service.
#### Enable external access
1. Navigate to your PostgreSQL service in the Zerops GUI and choose the **Public Access through IP Addresses** section
2. Choose either IPv6 (available by default) or IPv4 (requires the [unique IPv4](/references/networking/public-access#ipv4-configuration) add-on)
3. Open one or more ports and point them to your PostgreSQL service (the system will direct them through pgBouncer)
   - Choose any port from 10-65435 (except 80 and 443)
   - Select destination service and internal port
   - Each public port can be mapped to any internal service port
   - Multiple public ports can point to the same internal port if needed
   - Port configurations can be set independently for IPv4 and IPv6
4. Optionally enable firewall protection for additional security
5. Click the **Publish X IP access change(s)** button to apply your settings
For database management tools and how to manage users and databases, see [Manage PostgreSQL Users and Databases](/postgresql/how-to/manage).

----------------------------------------

# Postgresql > How To > Control



----------------------------------------

# Postgresql > How To > Create

## Create PostgreSQL using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new PostgreSQL service:
### Choose PostgreSQL version
Following PostgreSQL versions are currently supported:
### Set a hostname
Enter a unique service identifier like `postgresql`, `sql`, `db` etc.
#### Limitations:
- Duplicate services with the same name within the same project are not allowed
- Maximum 25 characters
- Must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created and cannot be changed later.
:::
### Configure auto scaling
Zerops automatically scales PostgreSQL services based on actual database usage. Configure the scaling parameters to match your database needs and control costs.
**CPU Mode**: Choose between shared (cost-effective) or dedicated (consistent performance).
**Resource Limits**: Set minimum and maximum resources for CPU, RAM, and disk to control costs and ensure performance.
**Deployment Mode**: Choose the reliability configuration for your PostgreSQL service:
- **Highly Available**: Multiple containers with redundancy across different physical machines. Recommended for production environments.
- **Single Container**: One container suitable for development and non-critical environments.
:::warning
Deployment mode cannot be changed after service creation.
:::
:::tip Learn More
For detailed scaling configuration, deployment mode details, and troubleshooting, see:
- [How Zerops scales PostgreSQL](/postgresql/how-to/scale) - Database-specific scaling guide
- [Automatic Scaling and High Availability](/features/scaling-ha) - Complete technical details
:::
## Create PostgreSQL using zCLI
zCLI is the Zerops command-line tool. To create a new PostgreSQL service via the command line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](#create-a-project-description-file)
3. Create a project and a PostgreSQL service
### Create a project description file
Zerops uses a YAML format file to describe the project infrastructure.
#### Basic example
Create a directory `my-project`. Create a `description.yaml` file inside the directory with the following content:
```yaml
# Basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: postgresql1
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"NON_HA"
    mode: NON_HA
```
The YAML file describes your future project infrastructure. The project will contain one PostgreSQL service in the single container mode with default [auto scaling](/postgresql/how-to/scale) configuration. The hostname will be set to `postgresql1`.
#### Full example
Create a directory `my-project`. Create a `description.yaml` file inside the directory with the following content:
```yaml
# Basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # first service hostname
    hostname: postgresql1
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"NON_HA"
    mode: HA
    # optional: vertical auto-scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
  - # second service hostname
    hostname: postgresql2
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The YAML file describes your future project infrastructure. The project will contain two PostgreSQL services.
The hostname of the first service will be set to `postgresql1`. The [high availability](/features/scaling-ha#highly-available-ha-mode) mode will be chosen and the custom [auto scaling configuration](/postgresql/how-to/scale) will be set.
The hostname of the second service will be set to `postgresql2`. The [single container](/features/scaling-ha#single-container-mode) mode will be chosen and the default [auto scaling configuration](/postgresql/how-to/scale) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      
      description
      Optional. Description of the new project.
      Maximum 255 characters.
    
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in the `services:` section is required. You can create a project with multiple services. The example above contains only PostgreSQL services but you can create a `description.yaml` with [different types] of services.
  
      Parameter
      Description
    
        hostname
      
        The unique service identifier.
        
        The hostname of the new database will be set to the `hostname` value. 
        
        Limitations:
        
- duplicate services with the same name in the same project are
        forbidden
        
        - maximum 25 characters
        
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
      
        type
      
        Specifies the service type and version.
        
        See what [PostgreSQL service types](/references/import-yaml/type-list#database-services) are currently supported.
      
        mode
      
        Defines the operation mode of the PostgreSQL service.
        
        HA
        
        Creates a PostgreSQL cluster with 3 database containers and 2 free
        database proxies. This mode is suited for production.
        
        Zerops always keeps the 3 database containers on different physical
        machines. All your data is stored redundantly in 3 identical copies. In
        case of a failure of a container or the underlying physical machine,
        Zerops automatically disconnects the failed container from the cluster,
        creates a new container and syncs all data from the remaining 2 copies.
        Finally, the broken container is automatically deleted.
        
        NON_HA
        
        Zerops will create a PostgreSQL database installed in a single
        container. Useful for non-essential data or dev environments.
        
        Your data is stored only in a single container. If the container or the
        the underlying physical machine fails, your data since the last backup are
        lost. Zerops doesn't provide any automatic repairs of a single node
        PostgreSQL services.
      
        verticalAutoscaling
      
        Optional. Defines custom vertical auto-scaling parameters.
        All verticalAutoscaling attributes are optional. Not specified
        attributes will be set to their default values.
      
         - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
         - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
         - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
         - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
:::caution
The PostgreSQL service **hostname** and **mode** are fixed after the service is created. They can't be changed later.
:::
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project will be created.
      --working-dir string   Sets a custom working directory. The default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
The maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add PostgreSQL service to an existing project
#### Example
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```bash
# array of project services
services:
  -
    # service name
    hostname: postgresql1
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"NON_HA"
    mode: NON_HA
```
The YAML file describes the list of one or more services that you want to add to your existing project. In the example above, one PostgreSQL service in the [single container](/features/scaling-ha#single-container-mode) with default [auto scaling](/postgresql/how-to/scale) configuration will be added to your project. The hostname of the new service will be set to `postgresql1`.
The content of the `services:` section of `import.yaml` is identical to the [project description file](#create-a-project-description-file). The `import.yaml` never contains the `project:` section because the project already exists.
When your `import.yaml` is ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command will be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
The maximum size of the `import.yaml` file is 100 kB.

----------------------------------------

# Postgresql > How To > Delete



----------------------------------------

# Postgresql > How To > Export Import Data

## Use Adminer or phpMyAdmin to export or import data
* [Adminer ↗](https://www.adminer.org) - an open source full-featured database management tool written in PHP
* [phpMyAdmin ↗](https://www.phpmyadmin.net) - a free software tool written in PHP, intended to handle the administration of PostgreSQL over the Web
1. [Install the tools to Zerops](/postgresql/how-to/manage#installing-management-tools)
2. Use their standard export or import functions
## Use a database management tool on your workstation to export or import data
Do you already use a database management tool that supports PostgreSQL on your workstation? Connect it securely to PostgreSQL from your local workspace via Zerops VPN.
Zerops VPN client is included into zCLI, the Zerops command-line tool. To start the VPN connection, read [how to connect to PostgreSQL remotely](/postgresql/how-to/connect#connect-remotely).
:::caution
Do not use SSL/TLS protocols when connecting to PostgreSQL over VPN. Zerops PostgreSQL is not configured to support these protocols. The security is assured by the VPN.
:::
Once the connection to PostgreSQL is established, use the standard export or import functions of your favourite management tool.
## Use psql CLI to export or import data
If you are using the [psql ↗](https://www.postgresql.org/docs/current/app-psql.html) command-line client to manage your PostgreSQL on your local workspace, you can connect it securely to PostgreSQL via Zerops VPN.
Zerops VPN client is included into zCLI, the Zerops command-line tool. To start the VPN connection, read [how to connect to PostgreSQL remotely](/postgresql/how-to/connect#connect-remotely).
Once the VPN session is established, you have the secured connection to the project's private network in Zerops. You can access all project services locally by using their hostname. The only difference is that no [environment variables](/postgresql/how-to/connect#method-2-environment-variables-recommended) are available when connected through VPN. To connect to PostgreSQL in Zerops you have to copy the [access details](/postgresql/how-to/connect#connection-details) manually from Zerops GUI.
Use [psql ↗](https://www.postgresql.org/docs/current/app-psql.html) command to connect to PostgreSQL in Zerops:
```sh
psql -h [hostname] -U [user] -p [password] -d [database_name]
```
:::caution
Do not use SSL/TLS protocols when connecting to PostgreSQL over VPN. Zerops PostgreSQL is not configured to support these protocols. The security is assured by the VPN.
:::
To export your database data and structure, use the [pg_dump ↗](https://www.postgresql.org/docs/current/backup-dump.html) command.
```sh
pg_dump [database_name] > dumpfilename.sql
```
To import your database data and structure, use the `mysql` command.
```sh
mysql [database_name] < dumpfilename.sql
```

----------------------------------------

# Postgresql > How To > Manage

This guide covers how to manage your PostgreSQL databases in Zerops, including default setup, database management tools, plugins, and best practices.
## Default Database and User
Zerops creates a default database and user automatically when a new PostgreSQL service is [created](/postgresql/how-to/create).
### Database
- **Name**: Identical to the service hostname
- **Encoding**: `utf8mb4`
### DB User
- **Username**: Identical to the service hostname
- **Password**: Generated randomly
:::info
For connection methods and environment variables, see the [Connect to PostgreSQL in Zerops](/postgresql/how-to/connect) page.
:::
:::caution Important notes
- When changing passwords, update both the database user password and the environment variable separately - they don't automatically synchronize.
- While both `postgresql://` and `postgres://` URI formats are valid, Zerops uses the `postgresql://` format. If your software requires `postgres://`, create a custom environment variable with this format.
- Do not use SSL/TLS protocols for internal connections. Security is assured by the project's private network.
:::
## Database Management Tools
You can use any PostgreSQL management tool of your choice to administer your databases in Zerops. For convenience, Zerops provides ready-to-use recipes for two popular web-based database management tools:
* [AdminerEvo](https://github.com/adminerevo/adminerevo) - developed by the AdminerEvo community and is a continuation of the [Adminer](https://www.adminer.org) project by Jakub Vrána
* [phpMyAdmin](https://www.phpmyadmin.net) - a popular free database administration tool that works with both MySQL and PostgreSQL databases
### Installing Management Tools
You can install these tools with a simple one-click import in Zerops:
1. In Zerops GUI, open your project and select **Import services** from the left menu
2. Copy and paste one of the following YAML configurations:
### Accessing Management Tools
After installation, you can access these tools via VPN:
1. [Start the Zerops VPN](/references/networking/vpn)
2. Type `http://adminerevo` or `http://phpmyadmin` in your browser
:::tip
Try `http://adminerevo.zerops` or `http://phpmyadmin.zerops` if you encounter any connection issues.
:::
:::caution
Do not use https when connecting to management tools via VPN.
:::
## Database Tools on Your Workstation
You can use various database management tools from your local workstation to connect to your PostgreSQL database in Zerops:
1. **Establish a secure tunnel** using the [Zerops VPN](/references/networking/vpn) to create an encrypted connection to your Zerops project
2. **Obtain the [connection details](/postgresql/how-to/connect#connection-details)** from Zerops GUI
    - Environment variables are not available through VPN connections
3. Connect with your **preferred database tool**
    - Do not use SSL/TLS (security is provided by the VPN)
    - **Desktop Database Tools** - popular GUI tools like pgAdmin, DBeaver, DataGrip, or any other PostgreSQL-compatible client will work with Zerops
    - **Command Line with psql** - connect using the standard PostgreSQL command-line client with the credential obtained above:
        ```sh
        psql -h [hostname] -U [user] -d [database_name]
        ```
:::tip
    Try `{hostname}.zerops` instead of just `{hostname}` if you encounter any connection issues.
:::
## How to install and manage PostgreSQL plugins
### Viewing available plugins
You can list all available PostgreSQL plugins by running the following query *(superuser privileges not required)*:
```sql
SELECT * FROM pg_available_extensions ORDER BY name;
```
### Installing plugins (requires superuser)
1. **Connect with superuser credentials**:
   - Use the `superUser` (user `postgres`) and `superUserPassword` environment variables from your PostgreSQL service
2. **Switch to your service database**:
   When logging in as the superuser, you're initially in the `postgres` database, not your service database.
3. **Install required extensions**:
   ```sql
   CREATE EXTENSION pg_stat_statements;
   CREATE EXTENSION vector;
   CREATE EXTENSION postgis;
   ```
:::warning
Currently, it is not possible to add new plugins that are not already listed in `pg_available_extensions`.
:::
When working with text search functionality, you'll need to reference the correct `stop`, `dict`, and `affix` files when creating dictionaries in your database. These files are essential for proper text search configuration.
Zerops PostgreSQL includes the following dictionary files:
**Stop word files** - used to remove common words that don't add significant meaning:
```
czech.stop
danish.stop
dutch.stop
english.stop
finnish.stop
french.stop
german.stop
hungarian.stop
italian.stop
nepali.stop
norwegian.stop
polish.stop
portuguese.stop
russian.stop
slovak.stop
spanish.stop
swedish.stop
turkish.stop
```
**Dictionary and affix files** - used for stemming and word normalization:
```
cs_CZ.affix
cs_CZ.dict
en_US.affix
en_US.dict
pl_PL.affix
pl_PL.dict
sk_SK.affix
sk_SK.dict
```
**Special rules file:**
```
unaccent.rules
```
For more information on text search dictionaries, refer to the [PostgreSQL documentation](https://www.postgresql.org/docs/16/textsearch-dictionaries.html).

----------------------------------------

# Postgresql > How To > Scale

Zerops automatically scales your PostgreSQL service based on actual database usage. When your database needs more power, resources increase. When demand drops, resources scale down to reduce costs.
:::tip Read More
For complete scaling details across all services, see [Automatic Scaling and High Availability](/features/scaling-ha).
:::
## How PostgreSQL scaling works
PostgreSQL services use **vertical scaling** to adjust CPU, RAM, and disk resources within containers based on usage patterns. Unlike runtime services, PostgreSQL does not use horizontal scaling (adding/removing containers). Instead, PostgreSQL services use deployment modes for high availability.
## Configure scaling
You can configure scaling settings:
- **During service creation** - Set initial scaling parameters when [creating](/postgresql/how-to/create) your PostgreSQL service
- **During import** - Define scaling configuration in your YAML import file using `verticalAutoscaling` parameters
- **After service creation** - Navigate to your PostgreSQL service and select **Automatic scaling configuration** to modify settings
### Basic settings
  
**CPU Mode**: Choose between shared (cost-effective, variable performance) or dedicated (consistent performance, higher cost). You can change CPU mode once per hour. See [pricing](https://zerops.io/#pricing) for costs.
**Resource limits**: Configure minimum and maximum resources for your PostgreSQL service:
- **Lower the maximum** to control costs and prevent over-scaling
- **Raise the minimum** when you need guaranteed baseline performance
- **Set minimum = maximum** to disable automatic scaling for that specific resource
**Deployment mode**: Choose the reliability configuration for your PostgreSQL service:
- **Single Container**: One container with vertical scaling only. Suitable for development environments.
- **Highly Available**: Multiple containers with built-in redundancy. Recommended for production environments.
:::warning
Deployment mode cannot be changed after service creation.
:::
When a container fails in HA mode, Zerops automatically replaces it with a new container on a different physical machine and synchronizes data from healthy copies.
### Advanced settings
**Start CPU cores**: Determines how many CPU cores are allocated during database startup. Increase this value if your PostgreSQL service starts slowly or requires more processing power during initialization.
**RAM thresholds**: Help prevent out-of-memory crashes by maintaining buffer space:
- **Absolute (GB)**: Maintains this amount of free RAM at all times
- **Percentage**: Keeps this percentage of total RAM free
Consider increasing these values if your database experiences memory-related issues.
  
:::info Read More
For detailed technical parameters and scaling behavior, see [Automatic Scaling and High Availability](/features/scaling-ha#resource-scaling-behavior).
:::
## Monitor usage
Navigate to your PostgreSQL service and select **Service containers & Overview** to view:
- CPU, RAM, and disk usage over time
- Historical scaling events
- Container health status
## Technical details
Zerops monitors database usage and automatically adjusts resources based on predefined thresholds and timing parameters. The scaling behavior follows the same principles as other services in the platform.
For complete technical specifications including:
- Resource monitoring intervals and thresholds
- Scale-up and scale-down timing parameters
- Scaling increments and steps
- Detailed scaling behavior patterns
See [Resource Scaling Behavior](/features/scaling-ha#resource-scaling-behavior) in the general scaling documentation.
## Common issues
**Out of memory errors**
- Increase minimum free RAM settings in your scaling configuration
- Consider raising the minimum RAM allocation
- Check for memory-intensive queries or operations
**Higher than expected costs**
- Consider lowering your maximum resource limits
- Review scaling patterns in the monitoring dashboard
**Slow database startup**
- Increase the "Start CPU cores" setting
- Consider switching to dedicated CPU mode for consistent performance
*Need help? Join our [Discord community](https://discord.gg/zerops) for assistance!*

----------------------------------------

# Postgresql > Overview

[PostgreSQL ↗](https://www.postgresql.org/) is a powerful, open source object-relational database system with over 35 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.
## Feature Highlights
### Connect to PostgreSQL service
### Others
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Python > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Python application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: python@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - app.py
      # OPTIONAL. Copy files from build container to runtime container.
      addToRunPrepare:
        - requirements.txt
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      # cache: file.txt
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: python@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 8000
      # OPTIONAL. Customize the runtime Python environment by installing additional
      # dependencies to the base Python runtime environment.
      # prepareCommands:
      #   - python3 -m pip install --ignore-installed -r requirements.txt
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Python application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your Python application start command
      start: python3 app.py
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Python builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: python@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  major version of Python, Zerops command line tool, `pip` and `git`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - python@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customize your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customized.
:::
:::note
Changing the OS setting will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache behavior.
:::
### prepareCommands
_OPTIONAL._ Customizes the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of Python defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `pip` and `git`
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: python@latest
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - apt install python3-pip # already installed for Python services
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/python/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Run prepare commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
prepareCommands:
  - |
    apt update
    apt install python3-pip # already installed for Python services
```
#### Run prepare commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
prepareCommands:
  - apt update
  - apt install python3-pip # already installed for Python services
```
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - app.py
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - app.py
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: python@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        PYTHON_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/python/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Python version for your runtime.
Following options are available for Python builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: python@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: python@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of Python, Zerops command line tool, `pip` and `git`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: python@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - python@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customize your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Python service with hostname = "app" and port = 8000 from another service of the same project, simply use `app:8000`. Read more about [how to access a Python service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customises the Python runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Python environment contains {data.alpine.default}, the selected
  major version of Python, Zerops command line tool, `pip` and `git`. To install additional packages or tools add one or more
  prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Python runtime environment.
      prepareCommands:
        - python3 -m pip install --ignore-installed -r requirements.txt
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/python/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
When the prepare cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build:prepareCommands](#preparecommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default} the
  selected major version of Python, Zerops command line tool, `pip` and `git`.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare:
        - requirements.txt
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Python runtime environment.
      prepareCommands:
        - python3 -m pip install --ignore-installed -r requirements.txt
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Python application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Python application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/python/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/python/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build:prepareCommands](#preparecommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        PYTHON_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/python/how-to/env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your Python application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Python application start command
      start: app.py
```
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Python application start command
      start: app.py
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Python application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Python application start command
      start: app.py
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/python/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/python/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Python application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/python/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Python > How To > Build Process



----------------------------------------

# Python > How To > Controls



----------------------------------------

# Python > How To > Create

Zerops provides a Python runtime service with extensive build support. Python runtime is highly scalable and customisable to suit both development and production.
## Create Python service using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new Python service:
### Choose Python version
Following Python versions are currently supported:
:::info
You can [change](/python/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app","cache", "gui" etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
- maximum 25 characters
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created. It can't be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as password, tokens, salts, certificates etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting the secret environment variables is optional. You can set them later in Zerops GUI.
Read more about [different types of env variables](/python/how-to/env-variables#service-env-variables) in Zerops.
## Create Python service using zCLI
zCLI is the Zerops command-line tool. To create a new Python service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/python/how-to/create#create-a-project-description-file)
3. [Create a project with a Python and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a yaml format to describe the project infrastructure.
#### Basic example:
Create a directory `my-project`. Create an `description.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in python@{version} format
    type: python@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Python version 3.12 service with default [auto scaling](/python/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/python/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Python and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in python@{version} format
    type: python@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create secret env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Python service and a [PostgreSQL](/postgresql/overview) service.
Python service with "app" hostname, the internal port(s) the service listens on will be defined later in the zerops.yaml. Python service will run on version 3.12 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      
      description
      Optional. Description of the new project.
      Maximum 255 characters.
    
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains Python and PostgreSQL services but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
         
        The hostname of the new service will be set to the `hostname` value.
         
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the service type and version.
        
        See what [Python service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
      verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
      - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
      - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
      - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
      - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
      minContainers
      
        Optional. Default = 1. Defines the minimum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      envSecrets
      
        Optional. Defines one or more secret env variables as a key value map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Python service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in python@{version} format
    type: python@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Python service version 3.12 with default [auto scaling](/python/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Python > How To > Customize Runtime

System packages for processing: When your app processes images, videos, or files (requiring packages like sudo apk add --no-cache imagemagick)',
  'Python build tools: When you need setuptools, or other tools not included by default',
  'Scientific libraries: When you need NumPy, SciPy, or other packages requiring system dependencies',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />

----------------------------------------

# Python > How To > Delete



----------------------------------------

# Python > How To > Deploy Process



----------------------------------------

# Python > How To > Env Variables



----------------------------------------

# Python > How To > Filebrowser



----------------------------------------

# Python > How To > Logs



----------------------------------------

# Python > How To > Scaling



----------------------------------------

# Python > How To > Shared Storage



----------------------------------------

# Python > How To > Trigger Pipeline



----------------------------------------

# Python > How To > Upgrade



----------------------------------------

# Python > Overview

[Python ↗](https://www.python.org/) is a programming language that lets you work quickly and integrate systems more effectively..
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-python-hello-world), a **_recipe_**, containing the most simple Python web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of Python running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-python-hello-world/blob/main/import-project/description.yaml)):
```yaml
project:
  name: my-first-project
services:
  - hostname: helloworld
    type: python@latest
    minContainers: 1
    maxContainers: 3
    buildFromGit: https://github.com/zeropsio/recipe-python-hello-world@main
    enableSubdomainAccess: true
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://helloworld-24-8080.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
Hello, World!
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Qdrant > Overview

[Qdrant](https://qdrant.tech/) in Zerops provides a fully managed vector database solution designed for AI applications. Focus on building vector search features while we handle infrastructure maintenance, high availability, and data protection.
## Supported Versions
Currently supported Qdrant versions:
Import configuration version:
## Deployment Modes
#### Non-HA Mode
- Single node setup ideal for development and non-production projects
- Simple deployment and management
#### HA Cluster
- Automatically configured with 3 nodes
- Recommended for production environments
- Built-in data replication across nodes
- By default (`automaticClusterReplication=true`), automatically creates replicas of all shards across all three nodes
  - Can be disabled by setting `automaticClusterReplication` to `false`
- Automatic cluster recovery and node replacement in case of failures
## Data Backup
Qdrant backups are created using native snapshotting:
- **Format**: `.snapshot` (compressed)
- **Tooling**: Native snapshotting
- **Source**: Taken from the primary node (leader in HA clusters)
For backup configuration, scheduling, retention policies, and management options, see the [Zerops Backups](/features/backup) documentation.
### Restoring Backups
To restore a Qdrant backup:
1. **Download** the backup file (`.snapshot`) from the Zerops UI
2. **Prepare** your target environment (clean existing collections or use a new instance)
3. **Restore** using the Qdrant API. Use the snapshot restore endpoint to import the snapshot file. Follow the [official Qdrant documentation](https://qdrant.tech/documentation/database-tutorials/create-snapshot/#restore-from-snapshot) for detailed snapshot restore procedures.
For assistance with the restoration process, contact Zerops support.
## Network Architecture & Access
Qdrant can be accessed only from services within the same project, public access is not available.
### API Keys
API key authentication is required for both HTTP and gRPC API calls. Include the key in your request headers. The keys are automatically generated when the Qdrant service is created and can be found in the service's environment variables:
- **`apiKey`:** Full access API key for administrative operations (creating collections, indexing)
- **`readOnlyApiKey`:** Restricted API key for search operations
#### HTTP API
- **Port:** `6333`
- **Connection String:** Available as `connectionString` environment variable or construct using `http://${hostname}:${port}`
#### gRPC API
- **Port:** `6334`
- **gRPC Connection String:** Available as `grpcConnectionString` environment variable or construct using `tcp://${hostname}:${grpcPort}`
## Support
For advanced configurations or custom requirements:
- Join our [Discord community](https://discord.gg/zeropsio)
- Contact support via [email](mailto:support@zerops.io)

----------------------------------------

# Rust > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Rust application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: rust@latest
      # OPTIONAL. Set the operating system for the build environment.
      # os: ubuntu
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Build your application
      buildCommands:
        - cargo b --release
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles:
        - target/release/~app
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      # cache: file.txt
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: rust@latest
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 8080
      # OPTIONAL. Customize the runtime Rust environment by installing additional
      # dependencies to the base Rust runtime environment.
      # prepareCommands:
      #   - sudo apt-get something
      #   - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Rust application is started.
      # initCommands:
      #  - rm -rf ./cache
      # REQUIRED. Your Rust application start command
      start: ./app
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Rust builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: rust@latest
      ...
```
  The base build environment contains {data.alpine.default}, the selected
  major version of Rust, Zerops command line tool, `npm` , `yarn`, `git` and `npx` tools.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - rust@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customize your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### os
_OPTIONAL._ Sets the operating system for the build environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customized.
:::
:::note
Modifying the OS will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### prepareCommands
_OPTIONAL._ Customizes the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.alpine.default}
- selected version of Rust defined in the [base](#base) attribute
- [Zerops command line tool](/references/cli)
- `npm`, `yarn`, `git` and `npx` tools
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: rust@latest
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - cargo b --release
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/rust/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: rust@latest
      # OPTIONAL. Build your application
      buildCommands:
        - cargo b --release
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
#### Run build commands as a single shell instance
Use following syntax to run all commands in the same environment context. For example, if one command changes the current directory, the next command continues in that directory. When one command creates an environment variable, the next command can access it.
```yaml
buildCommands:
  - |
    cargo b --release
```
#### Run build commands as a separate shell instances
When the following syntax is used, each command is triggered in a separate environment context. For example, each shell instance starts in the home directory again. When one command creates an environment variable, it won't be available for the next command.
```yaml
buildCommands:
  - cargo b --release
```
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/rust/how-to/logs#build-log) to troubleshoot the error. If the error log doesn't contain any specific error message, try to run your build with the --verbose option.
```yaml
buildCommands:
  - cargo b --release
```
If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `buildCommands` are finished, the application build is completed and ready for the deploy phase.
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - target/release/~app
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - target/release/~app
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: rust@latest
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        RUST_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/rust/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Rust version for your runtime.
Following options are available for Rust builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: rust@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: rust@latest
      ...
```
  The base runtime environment contains {data.alpine.default}, the
  selected major version of Rust, Zerops command line tool, npm, yarn, git and
  npx tools.
:::info
You can change the base environment when you need to. Just simply modify the zerops.yaml in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: rust@latest
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - rust@latest
      prepareCommands:
        - zsc add go@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customize your build environment use the `prepareCommands` attribute.
### os
_OPTIONAL._ Sets the operating system for the runtime environment.
Following options are available:
- `alpine`
- `ubuntu`
Default value is `alpine`.
We are currently using following os version:
- {data.alpine.default}
- {data.ubuntu.default}
:::caution
The os version is fixed and cannot be customised.
:::
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Rust service with hostname = "app" and port = 8080 from another service of the same project, simply use `app:8080`. Read more about [how to access a Rust service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customises the Rust runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Rust environment contains {data.alpine.default}, the selected
  major version of Rust, Zerops command line tool and `npm` , `yarn`, `git` and `npx` tools. To install additional packages or tools add one or
  more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Rust runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/rust/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
  
When the prepare cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.alpine.default}, the
  selected major version of Rust, Zerops command line tool and `npm`, `yarn`, `git` and `npx` tools.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Rust runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Rust application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Rust application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/rust/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/rust/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        RUST_ENV: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/rust/how-to/env-variables) in Zerops.
### start
_REQUIRED._ Defines the start command for your Rust application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Rust application start command
      start: ./app
```
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Rust application start command
      start: ./app
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Rust application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Rust application start command
      start: ./app
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/rust/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/rust/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Rust application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/rust/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Rust > How To > Build Process



----------------------------------------

# Rust > How To > Controls



----------------------------------------

# Rust > How To > Create

Zerops provides a Rust runtime service with extensive build support. Rust runtime is highly scalable and customisable to suit both development and production.
## Create Rust service using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new Rust service:
### Choose Rust version
Following Rust versions are currently supported:
:::info
You can [change](/rust/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app","cache", "gui" etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
- maximum 25 characters
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created. It can't be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as password, tokens, salts, certificates etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting the secret environment variables is optional. You can set them later in Zerops GUI.
Read more about [different types of env variables](/rust/how-to/env-variables#service-env-variables) in Zerops.
## Create Rust service using zCLI
zCLI is the Zerops command-line tool. To create a new Rust service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/rust/how-to/create#create-a-project-description-file)
3. [Create a project with a Rust and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a yaml format to describe the project infrastructure.
#### Basic example:
Create a directory `my-project`. Create an `description.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in rust@{version} format
    type: rust@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Rust version 18 service with default [auto scaling](/rust/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/rust/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Rust and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in rust@{version} format
    type: rust@latest
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create secret env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Rust service and a [PostgreSQL](/postgresql/overview) service.
Rust service with "app" hostname, the internal port(s) the service listens on will be defined later in the [zerops.yaml](/rust/how-to/build-pipeline#ports). Rust service will run on version 18 with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
      Limitations
    
      name
      The name of the new project. Duplicates are allowed.
      
      description
      Optional. Description of the new project.
      Maximum 255 characters.
    
      tags
      Optional. One or more string tags. Tags do not have a functional meaning, they only provide better orientation in projects.
      
At least one service in `services:` section is required. You can create a project with multiple services. The example above contains Rust and PostgreSQL services but you can create a `description.yaml` with your own combination of [services](/features/infrastructure).
  
      Parameter
      Description
    
        hostname
      
        The unique service identifier.
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
        type
      
        Specifies the service type and version.
        
        See what [Rust service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
        verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        All verticalAutoscaling attributes are optional. Not specified
        attributes will be set to their default values.
      
         - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
         - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
         - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
         - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
        minContainers
      
        Optional. Default = 1. Defines the minimum number of containers
        for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
        
        Limitations:
        
        Current maximum value = 10.
      
        envSecrets
      
        Optional. Defines one or more secret env variables as a key value
        map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Rust service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in rust@{version} format
    type: rust@latest
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Rust service version 18 with default [auto scaling](/rust/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Rust > How To > Customize Runtime

System packages for processing: When your app processes images, videos, or files (requiring packages like sudo apk add --no-cache imagemagick)',
  'Native dependencies: When your Cargo dependencies require system libraries that aren\'t in the default environment',
  'Development tools: When you need debugging tools, profilers, or other development utilities',
  'Different base OS: When you need Ubuntu instead of Alpine for specific compatibility requirements'
]} />

----------------------------------------

# Rust > How To > Delete



----------------------------------------

# Rust > How To > Deploy Process



----------------------------------------

# Rust > How To > Env Variables



----------------------------------------

# Rust > How To > Filebrowser



----------------------------------------

# Rust > How To > Logs



----------------------------------------

# Rust > How To > Scaling



----------------------------------------

# Rust > How To > Shared Storage



----------------------------------------

# Rust > How To > Trigger Pipeline



----------------------------------------

# Rust > How To > Upgrade



----------------------------------------

# Rust > Overview

[Rust ↗](https://www.rust-lang.org/) - a language empowering everyone to build reliable and efficient software.
As said, there is no need for coding yet, we have created a [Github repository ↗](https://github.com/zeropsio/recipe-rust-hello-world), a **_recipe_**, containing the most simple Rust web application. The repo will be used as a source from which the app will be built.
  This is the most bare-bones example of Rust running in Zerops — as few libraries as possible,
  just a simple endpoint with connect, read and write to a Zerops PostgreSQL database.
  
1. Log in/sign up to [Zerops GUI ↗](https://app.zerops.io)
2. In the **Projects** box click on **Import a project** and paste in the following YAML config ([source ↗](https://github.com/zeropsio/recipe-rust-hello-world/blob/main/import-project/description.yaml)):
```yaml
project:
  name: my-first-project
services:
  - hostname: helloworld
    type: rust@latest
    minContainers: 1
    maxContainers: 3
    buildFromGit: https://github.com/zeropsio/recipe-rust-hello-world@main
    enableSubdomainAccess: true
```
3. Click on **Import project** and wait until all pipelines have finished.
**That's it, your application is now up and running! :star: Let's check it works:**
1. A _subdomain_ should have been enabled and visible in the project's **IP addressed & Public Routing Overview** box. Its format should look similar to this `https://helloworld-24-8080.prg1.zerops.app`.
2. Click or the `subdomain` URL to open it in a browser and you should see
```
Hello, World!
```
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## How to start
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you build something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Shared Storage > How To > Backup

Zerops provides automated data backup for Shared Storage services with full encryption and flexible management options.
For general backup information including configuration, scheduling, and management options, see the [Zerops Backups](/features/backup) documentation, which covers:
- Backup scheduling and retention policies
- Tagging system and storage quotas
- Manual backup creation and CLI tools
- Security and encryption details
## Shared Storage Backup Format
Shared Storage backups are created using tar archival:
- **Format**: `.tar.gz` (archive of directory contents)
- **Tooling**: `tar`
- **Content**: Compresses the entire shared volume (`/mnt/`)
- **Storage**: Encrypted and stored in isolated object storage
### Restoring Backups
To restore a Shared Storage backup: Download the backup file (`.tar.gz`) from the Zerops UI, extract the archive, and upload the contents back to your Shared Storage.
## Best Practices
For Shared Storage backups:
- Regularly clean up unnecessary files from your Shared Storage to reduce backup size
- Create manual backups with protected tags before major file operations or migrations
- Consider adjusting your backup frequency for optimal storage usage
- Test your restore process periodically to ensure data integrity
For additional best practices and troubleshooting, refer to the [main backup documentation](/features/backup).

----------------------------------------

# Shared Storage > How To > Connect

This page covers how to connect an existing shared storage to runtime services and how to disconnect services when needed.
## In Zerops GUI
### Connect a new shared storage
When creating a new shared storage service, you can directly select which runtime services it should be connected to. See [Create Shared Storage](/shared-storage/how-to/create) for details about the creation process.
### Connect an existing shared storage
For existing storage, go to the shared storage service detail page and select **Shared storage connections**. Toggle ON any runtime services you wish to connect to this storage.
  
## Disconnect a shared storage in Zerops GUI
To disconnect storage, access the shared storage service detail page, select **Shared storage connections**, and toggle OFF the desired runtime service.

----------------------------------------

# Shared Storage > How To > Create

Shared Storage provides persistent file storage that can be mounted as a POSIX-compatible filesystem to your runtime services. Built on [SeaweedFS ↗](https://github.com/seaweedfs/seaweedfs), it enables reliable data persistence and sharing across services in your infrastructure.
## Create Using Zerops GUI
First, set up a project in Zerops GUI and add a runtime service. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new Shared Storage service:
### Set a Hostname
Enter a unique service identifier like "storage", "files" etc. Duplicate services with the same name in the same project are forbidden.
#### Hostname Limitations:
- Maximum 25 characters
- Must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::note
The hostname is fixed after the service is created. It can't be changed later.
:::
### Connect to Services
Select one or more project's runtime services in the Share with Services block:
  
The new Shared Storage will be connected to the selected runtimes.
:::note
Runtime services can be connected and disconnected at any time even after the shared storage is created.
:::
### Choose Deployment Mode
Choose between **Highly Available** (recommended for production) or **Single Container** (suitable for development) deployment.
:::warning
The Shared Storage deployment mode is fixed after the service is created. It can't be changed later.
See [Technical Details](/shared-storage/tech-details#deployment-modes) for more information about deployment modes.
:::
### Set Auto Scaling Configuration
Configure vertical auto scaling parameters to control resource allocation and costs.
  
:::note
For detailed information about auto scaling capabilities and recommendations, see [Technical Details](/shared-storage/tech-details#auto-scaling-configuration).
:::
## Create Using zCLI
zCLI is the Zerops command-line tool. To create a new Shared Storage service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. Create a project description file
3. Create a project with a runtime and a Shared Storage service
### Choose Your Runtime
export const languages = [
    { name: "Node.js", link: "/nodejs/how-to/shared-storage#create-nodejs-service-with-a-shared-storage-using-zcli" },
    { name: "PHP", link: "/php/how-to/shared-storage#create-php-service-with-a-shared-storage-using-zcli" },
    { name: "Python", link: "/python/how-to/shared-storage#create-python-service-with-a-shared-storage-using-zcli" },
    { name: "Go", link: "/go/how-to/shared-storage#create-go-service-with-a-shared-storage-using-zcli" },
    { name: ".NET", link: "/dotnet/how-to/shared-storage#create-dotnet-service-with-a-shared-storage-using-zcli" },
    { name: "Rust", link: "/rust/how-to/shared-storage#create-rust-service-with-a-shared-storage-using-zcli" }
]

----------------------------------------

# Shared Storage > How To > Manage

Zerops Shared Storage provides several web interfaces to manage, monitor, and troubleshoot your storage. These interfaces are accessible through the [Zerops VPN](/references/networking/vpn) and offer different capabilities for managing your data and monitoring system performance.
## Access Web Interfaces
### Filer UI
* `http://.zerops:8888`
The Filer UI provides a web-based interface for managing files and directories in your Shared Storage:
- Browse the directory structure and create new directories
- Upload new files (up to 64MB) and download existing files
- Rename and delete files and directories
### Master UI
* `http://node-stable-1.db..zerops:9333`
The Master UI provides system status and monitoring information:
- View cluster topology
- Monitor volume servers
- Check system status and health
- View statistics and metrics
### Volume UI
* `http://node-stable-.db..zerops:8080/ui/index.html`
The Volume UI allows you to monitor individual storage volumes:
- View volume status
- Check disk usage
- Monitor I/O operations
- View volume statistics
## Monitoring
Several options are available to help you monitor your Shared Storage:
### Runtime Service Logs
* Navigate to your runtime service detail page → **Runtime Logs** section → filter using the tag `zerops-mount-`
### Shared Storage Logs
* Access from the Shared Storage service detail page → **Runtime Logs** tab → browse or search for relevant information
### System and Volume Status
* Monitor replication status, disk usage, and performance metrics through the Master UI and Volume UI

----------------------------------------

# Shared Storage > How To > Use

Once a Shared Storage is [connected](/shared-storage/how-to/connect) to a runtime service, Zerops will create a new folder `/mnt/[shared storage name]` in the runtime service's filesystem.
For example, `/mnt/teststorage` for a `teststorage` Shared Storage:
  
:::note
The content of this folder is shared among all containers of the connected runtime service.
If you connect multiple runtimes, the content of the folder will be shared among all containers of these services.
:::
## Mount Points and Multiple Volumes
- Multiple storage volumes can be mounted to a single service (e.g., `/mnt/files1`, `/mnt/files2`, etc.)
- Shared storage mount is only available in runtime containers, not during build and prepare runtime phases
- All filesystem operations are automatically logged to runtime logs
For technical details about mount behavior and filesystem capabilities, see the [Technical Details](/shared-storage/tech-details#mount-integration) page.
## Use Cases
Shared Storage is ideal for:
- **Persistent filesystem-based databases**: SQLite, Prometheus DB, etc.
- **Configuration sharing**: Deploy configurations once and share across multiple services
  - Example: Deploy Apache Airflow configurations and DAG files once and share with all worker nodes
- **Alternative to object storage**: For applications that require filesystem semantics rather than object storage
- **Application data**: Store and serve images, documents, and other assets
## Performance Considerations
When using Shared Storage, keep in mind:
- For write-heavy workloads, consider batching operations
- Minimize operations with many small files for better performance
For more detailed information about performance constraints and limitations, see the [Technical Details](/shared-storage/tech-details#performance-considerations) page.
## Troubleshooting
### Common Issues
- The `df` command may show incorrect or misleading information when used with shared storage mounts. Please refer to the Zerops GUI for accurate storage metrics.

----------------------------------------

# Shared Storage > Overview

# Shared Storage
Zerops provides a fully managed and scaled **Shared Storage** service, which can be mounted to your runtime services. It offers:
- Persistent file sharing between containers of the same service or different services
- Standard filesystem operations through a POSIX-compatible interface
- Built-in high-availability configuration
## Documentation Sections
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*
## Popular Guides

----------------------------------------

# Shared Storage > Tech Details

Zerops Shared Storage is built on [SeaweedFS](https://github.com/seaweedfs/seaweedfs), a distributed filesystem optimized for high-volume storage with efficient retrieval.
## Architecture
Shared Storage consists of three main components:
- **Master Server**: Manages metadata and coordinates volume servers
- **Volume Servers**: Store the actual file data
- **Filer**: Provides a POSIX-compatible interface for file operations
An **automatic vacuum process** helps maintain optimal storage performance by reclaiming space from deleted files. This process is triggered when the size of deleted content exceeds 15% (reduced from the default 30%).
### Mount Integration
When connected to a runtime service:
- Storage is mounted at `/mnt/`
- Mount point is owned by the `zerops` user and group (no sudo required)
- All filesystem operations are logged to runtime logs (tagged as `zerops-mount-`)
- Mounting will overwrite any existing content in the mount directory
- Shared storage mount is only available in runtime containers, not during build and prepare runtime phases
## Deployment Modes
Zerops provides Shared Storage in two deployment modes:
### Highly Available
Recommended for production environments where data reliability is critical.
- **Architecture**: 2 volume servers with the master located on one of them
- **Data Durability**: Data and filer metadata are replicated 1:1 across nodes
- **Fault Tolerance**:
    - If a node fails, an automatic repair process begins
    - A new container replaces the failed one
    - Data is automatically replicated to the new container (duration depends on data size)
    - During master node failure, mounted directories become temporarily unavailable until the new master initializes (~30s)
### Single Container
Suitable for development environments or non-critical data storage.
- **Architecture**: Master, volume, and filer server all located on a single container
- **Data Durability**: All data is lost if the container fails
- **Recommended For**: Development environments or temporary data storage
:::warning
The deployment mode is fixed after the service is created and cannot be changed later.
:::
## Filesystem Capabilities
Shared Storage supports standard POSIX filesystem operations:
- Create, read, update, and delete files and directories
- Set permissions (with some limitations)
- Standard file locking operations
- Hard and symbolic links
- Directory listing and traversal
For a complete list of supported features, see the [SeaweedFS FUSE documentation](https://github.com/seaweedfs/seaweedfs/wiki/FUSE-Mount#supported-features).
## Resource Constraints
### Storage Limits
- Maximum storage space: 60GB (can be increased via support request)
- Maximum file size: Unlimited within the 60GB total storage constraint
- Maximum upload size via Filer UI: 64MB
### Memory Usage
- Base memory consumption: ~60MB when idle
- Peak memory usage: ~150MB under higher filesystem loads
- Optimized for low RAM usage (may trade off some performance)
### Performance Considerations
- **Latency**: Higher latency compared to local storage due to network-based distributed architecture
- **Write Performance**: For write-heavy workloads, consider batching operations
- **Small Files**: Minimize operations with many small files for better performance
## Auto Scaling Configuration
Zerops scales Shared Storage services automatically by raising or lowering the hardware resources of each database container.
Vertical auto scaling has the following default configuration:
For most cases, the default parameters will work without issues. If you need to limit the cost of the Shared Storage service, lower the maximal resources. Zerops will never scale above the selected maximums.
When you are experiencing problems with insufficient Shared Storage performance or capacity, increase the minimal resources. Zerops will never scale below the selected minimums.
:::note
You can change the auto scaling parameters later.
:::

----------------------------------------

# Static > Overview

The Static service provides a way to serve static content through a pre-configured Nginx setup. It balances simplicity with the flexibility needed for modern web applications.
  Deploy an Analog app with static hosting in seconds. All you need is a Zerops account.
  
## Quick Start
Add a Static service to your project by including this in your `zerops.yaml`:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    run:
      os: alpine
      base: static
```
## Default Behavior
Every Static service in Zerops comes with built-in defaults optimized for modern web applications, including Single Page Applications. By default, for any incoming request, the service will:
1. Try to serve the exact path (`$uri`)
2. Try with .html extension (`$uri.html`)
3. Look for an index.html in the directory (`$uri/index.html`)
4. Fall back to `/index.html` (suitable for SPAs)
5. Return 404 if none of the above exist
:::important SPAs
Single Page Applications work out of the box without any additional configuration. The built-in fallback to `/index.html` ensures that client-side routing functions properly.
:::
## Routing Configuration
The Static service allows you to configure additional URL routing and redirects through simple YAML configuration, abstracting away the complexity of Nginx configuration.
### Custom Routing Configuration
Configure custom routing beyond the default behavior in the `run.routing` section of your `zerops.yaml`:
```yaml title="zerops.yaml"
run:
  routing:
    redirects:
      # Only needed for custom redirect scenarios
      - from: /special-path/*
        to: /specific-landing-page
        status: 302
```
### Redirect Types
#### Relative Redirects
:::note
Remember that SPA routing is already built into the default behavior. You don't need to add any custom redirects for client-side routing to work.
:::
Use relative redirects to route paths within your application. When both `from` and `to` are relative paths, you can omit the `status` code to create a masked redirect that shows the content of the target page while preserving the original URL:
```yaml title="zerops.yaml"
routing:
  redirects:
    # Masked redirect - URL stays the same but shows content from about-us
    - from: /about
      to: /about-us
    # Standard redirect with status code
    - from: /old-page
      to: /new-page
      status: 301
    # Preserve the path when redirecting between directories
    - from: /blog/*
      to: /articles/
      preservePath: true
      status: 302
    # Preserve both path and query parameters
    - from: /posts/*
      to: /blog/
      preservePath: true
      preserveQuery: true
      status: 302
```
:::caution Important
When using `preservePath` with wildcards, ensure the `to` path ends with a `/` to maintain proper path concatenation. For example, `/blog/*` to `/new-blog/` will correctly redirect `/blog/hello.html` to `/new-blog/hello.html`, while `/new-blog` would result in `/new-bloghello.html`.
:::
#### Absolute Redirects
For redirecting between domains or to external URLs, use absolute redirects by including `http://` or `https://`. When using absolute URLs in either `from` or `to`, you must specify a `status` code:
```yaml title="zerops.yaml"
routing:
  redirects:
    # Redirect an old domain to a new one
    - from: https://old-domain.com/*
      to: https://new-domain.com
      status: 301
      preserveQuery: true  # Optional: maintain query parameters
    # Redirect with path preservation
    - from: https://old-site.com/*
      to: https://new-site.com/
      status: 301
      preservePath: true
```
### Advanced Routing Features
#### Wildcard Matching
Use `*` as a wildcard in your paths:
- **At the end of a path**: Matches any subsequent content
- **At the start of a domain** (after `https://`): Enables regex matching for subdomains
Example of domain management:
```yaml title="zerops.yaml"
run:
  routing:
    redirects:
      # Redirect a specific domain to an article
      - from: https://promo-domain.com/*
        to: https://main-site.com/special-offer
        status: 302
      # Redirect all subdomains to main site
      - from: https://*.old-domain.com/*
        to: https://main-site.com
        status: 302
```
#### Matching Priority
When multiple redirects are configured, they follow Nginx's matching priority system:
1. Exact matches are checked first
2. Simple path matches (without wildcards) are checked next
3. Pattern matches (with wildcards) are checked last
For example:
```yaml title="zerops.yaml"
routing:
  redirects:
    # Exact match for homepage - standard redirect
    - from: /
      to: /home
      status: 302
    # Simple path match - masked redirect
    - from: /about
      to: /about-us
    # Pattern match with path preservation
    - from: /blog/*
      to: /articles/
      preservePath: true
      status: 302
```
In this configuration:
- `/` will redirect to `/home` with a 302 status
- `/about` will show content from `/about-us` but keep the URL as `/about`
- `/blog/post-123.html` will redirect to `/articles/post-123.html`
- Any other path will use the [default behavior](#default-behavior)
### CORS Configuration
You can enable CORS for your static service by adding a `cors` directive:
```yaml title="zerops.yaml"
run:
  routing:
    # Simple case - automatically converted to '*'
    cors: "*"
    # Full syntax with proper quoting
    cors: "'*' always"
```
The `cors` directive sets the following headers:
- `Access-Control-Allow-Origin`
- `Access-Control-Allow-Methods`
- `Access-Control-Allow-Headers`
- `Access-Control-Expose-Headers`
:::note
The `cors` directive has a special case: if you specify just `"*"`, it's automatically converted to `'*'`. For any other values, you need to include the proper Nginx syntax including quotes.
:::
### Custom Headers
For more control over HTTP headers, use the `headers` directive:
```yaml title="zerops.yaml"
run:
  routing:
    headers:
      - for: "/"
        values:
          # All values need proper quoting since they're inserted directly into Nginx
          X-Frame-Options: "'DENY'"
          # Values with internal quotes need proper YAML escaping
          Content-Security-Policy: '"default-src ''self''"'
```
:::important
Header values are inserted directly into the Nginx configuration **without** additional quotes, which means:
1. **All values must include their own quotes** (typically single quotes)
2. If you need single quotes inside your header value, you must escape them in YAML (using double single quotes)
3. To include the `always` directive, add it after your quoted value
4. For complex values, you can use YAML's block scalar notation (`>-`) for better readability
:::
Here are examples for different header scenarios:
```yaml title="zerops.yaml"
headers:
  - for: "/"
    values:
      # Simple header with proper quoting
      X-Frame-Options: "'DENY'"
      # Header with 'always' directive
      X-XSS-Protection: "'1; mode=block' always"
      # Header with internal single quotes - need double single quotes for escaping
      Content-Security-Policy: '"default-src ''self'' https://cdn.example.com"'
      # Complex header with block scalar notation for better readability
      Content-Security-Policy: >-
        "default-src 'self' https://cdn.example.com;
        script-src 'self' 'unsafe-inline';
        img-src * data:" always
```
When this configuration is processed, it translates to the following Nginx directives:
```
add_header X-Frame-Options 'DENY';
add_header X-XSS-Protection '1; mode=block' always;
add_header Content-Security-Policy "default-src 'self' https://cdn.example.com";
add_header Content-Security-Policy "default-src 'self' https://cdn.example.com; script-src 'self' 'unsafe-inline'; img-src * data:" always;
```
:::important Path Handling
When you specify headers for a path that doesn't have an existing location block, the Static service automatically creates a location with the same [default behavior](#default-behavior) as the root path (trying files in order: `$uri`, `$uri.html`, `$uri/index.html`, `/index.html` or returning 404).
If you add headers for a path that already has a location block, your headers will be merged with the existing configuration.
:::
### Combining CORS and Custom Headers
You can use both CORS and custom headers together:
```yaml title="zerops.yaml"
run:
  routing:
    cors: "'*' always"
    headers:
      - for: "/"
        values:
          X-Frame-Options: "'DENY'"
```
The `cors` directive sets default Access-Control headers for all routes, while the `headers` directive allows you to set additional headers for specific paths.
:::important
If you specify Access-Control headers in the `headers` directive, they will override the ones set by `cors` for that specific path.
:::
## Prerender Integration
The Static service includes built-in support for Prerender.io for server-side rendering for search engines and social media crawlers.
### Basic Prerender Setup
1. Set the `PRERENDER_TOKEN` secret variable with your Prerender.io token
2. The service automatically configures necessary rewrites based on user agents
### Custom Prerender Host
If you're using a custom Prerender host, add it to environment variables in `zerops.yaml`:
```yaml title="zerops.yaml"
run:
  envVariables:
  - PRERENDER_HOST=your.prerender.host
```
:::note Default
The default host is `service.prerender.io` if not specified.
:::
## Advanced Configuration
### Switching to Full Nginx
If you need more control over your Nginx configuration:
1. Go to your Static service overview in the UI
2. Click the three vertical dots in the left panel
3. Select **Need to switch to full Nginx service?**
4. Copy the generated Nginx configuration
5. Use this configuration as a starting point for a full Nginx service
:::tip
This allows you to move to a more customizable setup while maintaining your existing routing logic.
:::
## Best Practices
1. **Domain Migration**
   ```yaml title="zerops.yaml"
   routing:
     redirects:
       - from: https://old-domain.com/*
         to: https://new-domain.com
         status: 301
   ```
   Use permanent (301) redirects when permanently moving content to maintain SEO value.
2. **Complex Redirects**
   ```yaml title="zerops.yaml"
   routing:
     redirects:
       - from: /specific-path/*
         to: /specific-landing
         status: 302
       # Additional specific redirects go here
   ```
3. **Security Headers**
   Add security headers to protect your application:
   ```yaml title="zerops.yaml"
   routing:
     headers:
       - for: "/*"
         values:
           X-Frame-Options: "'DENY'"
           X-Content-Type-Options: "'nosniff'"
           # Note the proper quoting for values with single quotes
           Content-Security-Policy: '"default-src ''self''"'
   ```
## Frontend Framework Integration
The Static service works with modern frontend frameworks. It can serve built static files from any framework with options for custom routing and Prerender.io integration if needed.
### Example: Analog App Deployment
Here's a configuration for deploying an [Analog application](https://github.com/zeropsio/recipe-analog-static):
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      base: nodejs@20
      buildCommands:
        - pnpm i
        - pnpm build
      deployFiles:
        - dist/analog/public/~
    run:
      base: static
```
This configuration:
1. Uses Node.js 20 for building the application
2. Installs dependencies with pnpm
3. Builds the application
4. Deploys the resulting static files to the Static service
You can enhance this basic setup with:
- Custom redirects for URL management
- Prerender.io integration for SEO
- Additional routing rules as needed
## Common Configurations
### Multiple Domain Management
```yaml title="zerops.yaml"
run:
  routing:
    redirects:
      # Product-specific domain
      - from: https://product-promo.com/*
        to: https://main-site.com/products
        status: 302
      # Campaign domain
      - from: https://special-offer.com/*
        to: https://main-site.com/campaign
        status: 302
      # Legacy domains and subdomains
      - from: https://*.legacy-domain.com/*
        to: https://main-site.com
        status: 302
```
### Development Setup
```yaml title="zerops.yaml"
run:
  routing:
    # CORS with proper quoting
    cors: "'*' always"
    redirects:
      # API requests
      - from: /api/*
        to: https://api.your-domain.com
        status: 302
```
### Security-Enhanced Configuration
```yaml title="zerops.yaml"
run:
  routing:
    headers:
      # Custom headers for default location
      - for: "/*"
        values:
          X-Frame-Options: "'DENY' always"
          X-Content-Type-Options: "'nosniff' always"
          # Note the proper escaping of single quotes
          Content-Security-Policy: '"default-src ''self''" always'
```

----------------------------------------

# Typesense > Overview

Zerops provides a fully managed [Typesense search engine](https://typesense.org/) service that combines developer productivity with enterprise-grade reliability. The platform handles infrastructure complexity through automated deployment, scaling, and maintenance while providing developers full access to Typesense's native capabilities.
## Supported Versions
Currently supported Typesense version:
Import configuration version:
## Service Configuration
Our Typesense implementation comes with carefully tuned defaults that diverge from the [standard Typesense configuration](https://typesense.org/docs/27.1/api/server-configuration.html#using-command-line-arguments) in the following ways:
```yaml
thread-pool-size: 16
num-collections-parallel-load: 8
```
These defaults are optimized for most common use cases and managed by the platform. If you need to adjust these settings, please contact us through our [support channels](#support).
### Data Persistence
Typesense data is automatically persisted to disk at `/var/lib/typesense`.
This ensures that data remains intact during service restarts (Typesense automatically reloads the persisted data into memory upon startup).
This persistence mechanism works in both HA and non-HA deployment modes, though with different reliability guarantees as detailed below.
### Deployment Modes
:::warning
The choice between HA and non-HA mode must be made during service creation and cannot be changed later. Make sure to carefully consider your requirements before deploying.
:::
#### Non-HA Mode
- Suitable for development and testing
- Data persistence not guaranteed during node failures
- Lower resource requirements
#### HA Mode
- Implements Typesense's native [**Raft consensus**](https://typesense.org/docs/guide/high-availability.html) mechanism for data replication
- Deploys as a **3-node cluster by default** for optimal reliability
  - Scaling configuration of 3-5 or 3-7 nodes for higher workloads is possible upon request (contact [support](#support) to configure custom node ranges)
- Includes **built-in data synchronization** across all nodes
- Features **automatic leader election** to maintain cluster availability
  - Recovery typically takes up to 1 minute during node failures or leader transitions
  - During these periods, requests may temporarily receive `503 Not Ready or Lagging` or `500 Could not find a leader` responses
  - These states automatically resolve once consensus is reestablished
### API Key Management
The master API key is automatically generated and managed by the platform. You can access it through:
- The service access details in the Zerops GUI
- The `apiKey` environment variable in your service configuration
:::warning
Currently, as a security-focused design decision, the master API key cannot be modified after generation.
:::
### CORS Configuration
Your Typesense instance comes with CORS enabled by default, ensuring seamless integration with frontend applications. Browser-based clients can directly access the instance by providing the `X-Typesense-Api-Key` header, maintaining security while enabling straightforward client-side implementation.
## Network Architecture & Access Patterns
### Access Methods
#### HTTPS Access
When using HTTPS access (either through Zerops subdomain or custom domain), traffic is distributed across nodes via our integrated Nginx proxy layer. This provides a single access point that handles load balancing automatically.
For enabling HTTPS access:
1. Configure through the [Zerops access documentation](/features/access)
2. Or use `enableSubdomainAccess: true` when [importing](/references/import#service-configuration) a Typesense service
#### Direct Node Access
Allows to access individual nodes using internal DNS:
1. **Via [Zerops VPN](/references/networking/vpn)**
2. **Internal Project Access** - services within the same project can reach nodes directly
Node addressing patterns:
##### Standard format
**Format:**```node{n}.db.{hostname}.zerops```
- e.g. `node1.db.typesenseha.zerops`, `node2.db.typesenseha.zerops`
##### Stable DNS records
**Format:**```node-stable-{n}.db.{hostname}.zerops```
- **maintain consistent IP mapping** until node retirement (scaling down or failure events)
- e.g. `node-stable-1.db.typesenseha.zerops`, `node-stable-2.db.typesenseha.zerops`
## Quick Start Example
Here's a simple example of using Typesense with the JavaScript client:
```javascript
const client = new TypesenseClient({
  nodes: [{
    host: 'your-service.zerops.dev', // Your Zerops subdomain
    port: '443',
    protocol: 'https'
  }],
  apiKey: process.env.TYPESENSE_API_KEY,
  connectionTimeoutSeconds: 2
})
// Create a collection
await client.collections().create({
  name: 'companies',
  fields: [
    { name: 'company_name', type: 'string' },
    { name: 'num_employees', type: 'int32' },
    { name: 'country', type: 'string', facet: true }
  ],
  default_sorting_field: 'num_employees'
})
// Example search query
const searchResults = await client.collections('companies')
  .documents()
  .search({
    q: 'tech',
    query_by: 'company_name',
    filter_by: 'country:=USA',
    sort_by: 'num_employees:desc'
  })
```
## Best Practices
#### API Key Security
- Never expose the master API key in client-side code
- Generate scoped search-only API keys for frontend applications
- Rotate API keys periodically through your service configuration
#### High Availability
- Implement retry logic in clients for handling temporary unavailability
- Use stable DNS records for direct node access when needed
#### Performance Optimization
- Utilize batch operations for bulk updates
- Configure appropriate timeout values based on your use case
- Consider data volume when designing collection schemas
## Support
For advanced configurations or custom requirements:
- Join our [Discord community](https://discord.gg/zeropsio)
- Contact support via [email](mailto:support@zerops.io)

----------------------------------------

# Ubuntu > How To > Build Pipeline

Zerops provides a customizable build and runtime environment for your Ubuntu application.
## Add zerops.yaml to your repository
Start by adding `zerops.yaml` file to the **root of your repository** and modify it to fit your application:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: ubuntu@24.04
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      # OPTIONAL. Build your application, e.g. with not officially supported version of your favourite technology
      buildCommands:
        - go build -o app main.go
      # REQUIRED. Select which files / folders to deploy after
      # the build has successfully finished
      deployFiles: app
      # OPTIONAL. Which files / folders you want to cache for the next build.
      # Next builds will be faster when the cache is used.
      cache: some_file
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base: ubuntu@24.04
      # OPTIONAL. Sets the internal port(s) your app listens on:
      ports:
        # port number
        - port: 8080
      # OPTIONAL. Customize the runtime Ubuntu environment by installing additional
      # dependencies to the base Ubuntu runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Ubuntu application is started.
      initCommands:
       - rm -rf ./cache
      # REQUIRED. Your Ubuntu application start command
      start: ./app
```
The top-level element is always `zerops`.
### Setup
The first element `setup` contains the **hostname** of your service. A runtime service with the same hostname must exist in Zerops.
Zerops supports the definition of multiple runtime services in a single `zerops.yaml`. This is useful when you use a monorepo. Just add multiple setup elements in your `zerops.yaml`:
```yaml
zerops:
  # definition for app service
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  # definition for api service
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration contains at least the `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Build pipeline configuration
### base
_REQUIRED._ Sets the base technology for the build environment.
Following options are available for Ubuntu builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: ubuntu@24.04
      ...
```
  The base build environment contains {data.ubuntu.default}, Zerops command line tool, `git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the build environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base:
        - ubuntu@24.04
      prepareCommands:
        - zsc add nodejs@latest
      ...
```
See the full list of supported [build base environments](/zerops-yaml/base-list#runtime-services).
To customize your build environment use the [prepareCommands](#preparecommands) attribute.
:::note
Modifying the base technology will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for more details about cache invalidation.
:::
### prepareCommands
_OPTIONAL._ Customizes the build environment by installing additional dependencies or tools to the base build environment.
The base build environment contains:
- {data.ubuntu.default}
- [Zerops command line tool](/references/cli)
- `git` and `wget`
To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: ubuntu@24.04
      # OPTIONAL. Customize the build environment by installing additional packages
      # or tools to the base build environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first build is triggered, Zerops will
1. create a build container
2. download your application code from your repository
3. run the prepare commands in the defined order
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::note
These commands are skipped when using cached environment. Modifying `prepareCommands` will invalidate your build cache. See our [Build Cache Documentation](/features/build-cache) for details about cache invalidation.
:::
#### Command exit code
If any command fails, it returns an exit code other than 0 and the build is canceled. Read the [build log](/ubuntu/how-to/logs#build-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all prepare commands are finished, your custom build environment is ready for the build phase.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### buildCommands
_OPTIONAL._ Defines build commands.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Set the base technology for the build environment:
      base: ubuntu@24.04
      # OPTIONAL. Build your application
      buildCommands:
        - 
      ...
```
Build commands are optional. Zerops triggers each command in the defined order in a dedicated build container.
Before the build commands are triggered the build container contains:
1. base environment defined by the [base](#base) attribute
2. optional customisation of the base environment defined in the [prepareCommands](#preparecommands) attribute
3. your application code
For detailed information about build commands, including how to run commands in single or separate shell instances and command exit code handling, refer to the documentation for your specific technology (e.g., [Node.js](/nodejs/how-to/build-pipeline), [Go](/ubuntu/how-to/build-pipeline), [Python](/python/how-to/build-pipeline), etc.).
### deployFiles
_REQUIRED._ Selects which files or folders will be deployed after the build has successfully finished. To filter out specific files or folders, use `.deployignore` file.
```yaml
# REQUIRED. Select which files / folders to deploy after
# the build has successfully finished
deployFiles:
  - app
```
Determines files or folders produced by your build, which should be deployed to your runtime service containers.
The path starts from the **root directory** of your project (the location of `zerops.yaml`). You must enclose the name in quotes if the folder or the file name contains a space.
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Examples
Deploys a folder, and a file from the project root directory:
```yaml
deployFiles:
  - app
  - file.txt
```
Deploys the whole content of the build container:
```yaml
deployFiles: .
```
Deploys a folder, and a file in a defined path:
```yaml
deployFiles:
  - ./path/to/file.txt
  - ./path/to/dir/
```
#### How to use a wildcard in the path
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/file.txt
```
Deploys all folders that are located in any path that begins with `/path/to/`
```yaml
deployFiles: ./path/to/~/
```
Deploys all folders that are located in any path that begins with `/path/` and ends with `/to/`
```yaml
deployFiles: ./path/~/to/
```
:::note Example
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
:::
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache
_OPTIONAL._ Defines which files or folders will be cached for the next build.
```yaml
# OPTIONAL. Which files / folders you want to cache for the next build.
# Next builds will be faster when the cache is used.
cache: file.txt
```
The cache attribute helps optimize build times by preserving specified files between builds.
The cache attribute supports the [~ wildcard character](#how-to-use-a-wildcard-in-the-path).
Learn more about the [build cache system](/features/build-cache) in Zerops.
### envVariables
_OPTIONAL._ Defines the environment variables for the build environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      base: ubuntu@24.04
        …
      # OPTIONAL. Defines the env variables for the build environment:
      envVariables:
        MODE: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/ubuntu/how-to/env-variables) in Zerops.
## Runtime configuration
### base
_OPTIONAL._ Sets the base technology for the runtime environment.
If you don't specify the `run.base` attribute, Zerops keeps the current Ubuntu version for your runtime.
Following options are available for Ubuntu builds:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: ubuntu@24.04
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
        base: ubuntu@24.04
      ...
```
  The base runtime environment contains {data.ubuntu.default}, Zerops command line tool, `git` and `wget`.
:::info
You can change the base environment when you need to. Just simply modify the `zerops.yaml` in your repository.
:::
If you need to install more technologies to the runtime environment, set multiple values as a yaml array. For example:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      # REQUIRED. Sets the base technology for the build environment:
      base: ubuntu@24.04
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Sets the base technology for the runtime environment:
      base:
        - ubuntu@24.04
      prepareCommands:
        - zsc add nodejs@latest
      ...
```
See the full list of supported [run base environments](/zerops-yaml/base-list).
To customise your build environment use the `prepareCommands` attribute.
### ports
_OPTIONAL._ Specifies one or more internal ports on which your application will listen.
Projects in Zerops represent a group of one or more services. Services can be of different types (runtime services, databases, message brokers, object storage, etc.). All services of the same project share a **dedicated private network**. To connect to a service within the same project, just use the service hostname and its internal port.
For example, to connect to a Ubuntu service with hostname = "app" and port = 8080 from another service of the same project, simply use `app:8080`. Read more about [how to access a Ubuntu service](/references/networking/internal-access#basic-service-communication).
Each port has following attributes:
  
      Parameter
      Description
    
      port
      Defines the port number. You can set any port number between 10 and 65435. Ports outside this interval are reserved for internal Zerops systems.
    
      protocol
      Optional. Defines the protocol. Allowed values are TCP or UDP. Default value is TCP.
    
      httpSupport
      Optional. httpSupport = true is the default setting for TCP protocol. Set httpSupport = false if a web server isn't running on the port. Zerops uses this information for the configuration of public access. httpSupport = true is available only in combination with the TCP protocol.
    
### prepareCommands
_OPTIONAL._ Customises the Ubuntu runtime environment by installing additional dependencies or tools to the runtime base environment.
  The base Ubuntu environment contains {data.ubuntu.default}, Zerops command line tool and `git` and `wget`. To install additional packages or tools add one or more prepare commands:
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Ubuntu runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
When the first deploy with a defined prepare attribute is triggered, Zerops will
1. create a prepare runtime container
2. optionally: [copy selected folders or files from your build container](#copy-folders-or-files-from-your-build-container)
3. run the `prepareCommands` commands in the defined order
#### Command exit code
If any command fails, it returns an exit code other than 0 and the deploy is canceled. Read the [prepare runtime log](/ubuntu/how-to/logs#prepare-runtime-log) to troubleshoot the error. If the command ends successfully, it returns the exit code 0 and Zerops triggers the following command. When all `prepareCommands` commands are finished, your custom runtime environment is ready for the deploy phase.
#### Cache of your custom runtime environment
Some packages or tools can take a long time to install. Therefore, Zerops caches your custom runtime environment after the installation of your custom packages or tools is completed. When the second or following deploy is triggered, Zerops will use the custom runtime cache from the previous deploy if following conditions are met:
1. Content of the [build.addToRunPrepare](#copy-folders-or-files-from-your-build-container) and `run.prepareCommands` attributes didn't change from the previous deploy
2. The custom runtime cache wasn't invalidated in the Zerops GUI.
To invalidate the Zerops runtime cache go to your service detail in Zerops GUI, choose **Service dashboard & runtime containers** from the left menu and click on the **Open pipeline detail** button. Then click on the **Clear runtime prepare cache** button.
When the prepare cache is used, Zerops doesn't create a prepare runtime container and executes the deployment of your application directly.
#### Single or separated shell instances
You can configure your prepare commands to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### Copy folders or files from your build container
  The prepare runtime container contains {data.ubuntu.default}, Zerops command line tool and `git` and `wget`.
The prepare runtime container does not contain your application code nor the built application. If you need to copy some folders or files from the build container to the runtime container (e.g. a configuration file) use the `addToRunPrepare` attribute in the [build section](#build-pipeline-configuration).
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build:
      ...
      addToRunPrepare: ./runtime-config.yaml
    # ==== how to run your application ====
    run:
      # OPTIONAL. Customise the runtime environment by installing additional packages
      # or tools to the base Ubuntu runtime environment.
      prepareCommands:
        - sudo apt-get something
        - curl something else
      ...
```
In the example above Zerops will copy the `runtime-config.yaml` file from your build container **after the build has finished** into the new **prepare runtime** container. The copied files and folders will be available in the `/home/zerops` folder in the new prepare runtime container before the prepare commands are triggered.
### initCommands
_OPTIONAL._ Defines one or more commands to be run each time a new runtime container is started or a container is restarted.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Run one or more commands each time a new runtime container
      # is started or restarted. These commands are triggered before
      # your Ubuntu application is started.
      initCommands:
        - rm -rf ./cache
```
These commands are triggered in the runtime container before your Ubuntu application is started via the [start command](#start).
Use init commands to clean or initialise your application cache or similar operations.
:::caution
The init commands will delay the start of your application each time a new runtime container is started (including the horizontal [scaling](/ubuntu/how-to/scaling) or when a runtime container is restarted).
Do not use the init commands for customising your runtime environment. Use the [run:prepareCommands](#preparecommands-1) attribute instead.
:::
#### Command exit code
If any of the `initCommands` fails, it returns an exit code other than 0, but deploy is **not** canceled. After all init commands are finished, regardless of the status code, the application is started. Read the [runtime log](/ubuntu/how-to/logs#runtime-log) to troubleshoot the error.
#### Single or separated shell instances
You can configure your `initCommands` to be run in a single shell instance or multiple shell instances. The format is identical to [build commands](#buildcommands).
### envVariables
_OPTIONAL._ Defines the environment variables for the runtime environment.
Enter one or more env variables in following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      # OPTIONAL. Defines the env variables for the runtime environment:
      envVariables:
        MODE: production
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
Read more about [environment variables](/ubuntu/how-to/env-variables) in Zerops.
### start
_OPTIONAL._ Defines the start command for your Ubuntu application.
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Your Ubuntu application start command
      start: ./app
```
### health check
_OPTIONAL._ Defines a health check.
`healthCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the health check to request a local URL using a HTTP GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # OPTIONAL. Your Ubuntu application start command
      start: ./app
      # OPTIONAL. Define a health check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      healthCheck:
        httpGet:
          port: 80
          path: /status
```
#### exec
Configures the health check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Ubuntu application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to run your application ====
    run:
      # REQUIRED. Your Ubuntu application start command
      start: ./app
      # OPTIONAL. Define a health check with a shell command.
      healthCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
### crontab
_OPTIONAL._ Defines cron jobs.
Setup cron jobs in the following format:
```yaml
zerops:
  # define hostname of your service
  - setup: app
    # ==== how to run your application ====
    run:
      crontab:
        # REQUIRED. Sets the command to execute:
        - command: ""
        # REQUIRED. Sets the interval time to execute:
          timing: "0 * * * *"
```
Read more about setting up [cron](/zerops-yaml/cron) in Zerops.
## Deploy configuration
### readiness check
_OPTIONAL._ Defines a readiness check. Read more about how the [readiness check works](/ubuntu/how-to/deploy-process#readiness-checks) in Zerops.
`readinessCheck` requires either one `httpGet` object or one `exec` object.
#### httpGet
Configures the readiness check to request a local URL using a http GET method.
Following attributes are available:
  
      Parameter
      Description
    
      port
      Defines the port of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      path
      Defines the URL path of the HTTP GET request.
The readiness check will trigger a GET request on {'http://127.0.0.1:{port}/{path}'}
    
      host
      Optional. The readiness check is triggered from inside of your runtime container so it always uses the localhost 127.0.0.1. If you need to add a host to the request header, specify it in the host attribute.
    
      scheme
      Optional. The readiness check is triggered from inside of your runtime container so no https is required.
If your application requires a https request, set scheme: https
    
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        httpGet:
          port: 80
          path: /status
    # ==== how to run your application ====
    run: ...
```
Read more about how the [readiness check works](/ubuntu/how-to/deploy-process#readiness-checks) in Zerops.
#### exec
Configures the readiness check to run a local command.
Following attributes are available:
  
      Parameter
      Description
    
      command
      
        Defines a local command to be run.
        The command has access to the same environment variables as your Ubuntu application.
        A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example below.
      
**Example:**
```yaml
zerops:
  # hostname of your service
  - setup: app
    # ==== how to build your application ====
    build: ...
    # ==== how to deploy your application ====
    deploy:
      # OPTIONAL. Define a readiness check with a HTTP GET request option.
      # Configures the check on http://127.0.0.1:80/status
      readinessCheck:
        exec:
          command: |
            touch grass
            rm -rf life
            mv /outside/user /home/user
```
Read more about how the [readiness check works](/ubuntu/how-to/deploy-process#readiness-checks) in Zerops.

----------------------------------------

# Ubuntu > How To > Build Process

  
## Build process overview
Zerops starts a temporary build container and performs the following actions:
1. **Installs the build environment** - Sets up base system and  runtime
2. **Downloads your application source code** - From [GitHub ↗](https://www.github.com), [GitLab ↗](https://www.gitlab.com) or via [Zerops CLI](/references/cli)
3. **Optionally customizes the build environment** - Runs prepare commands if configured
4. **Runs the build commands** - Executes your build process
5. **Uploads the application artifact** - Stores build output to internal Zerops storage
6. **Caches selected files** - Preserves specified files for faster future builds
The build container is automatically deleted after the build has finished or failed.
## Build configuration
Configure your  build process in your `zerops.yaml` file according to the full build & deploy  pipeline guide.
## Build environment
### Default  build environment
The default  build environment contains:
- {data.ubuntu.default}
- [zCLI](/references/cli), Zerops command line tool
- 
### Customize build environment
To install additional packages or tools, add one or more build.prepareCommands to your `zerops.yaml`.
:::info
The application code is available in the `/var/www` folder in your build container before the prepare commands are triggered. This allows you to use any file from your application code in your prepare commands (e.g. a configuration file).
:::
### Build hardware resources
All runtime services use the same hardware resources for build containers:
  
      HW resource
      Minimum
      Maximum
    
      CPU cores
      1
      5
    
      RAM
      8 GB
      8 GB
    
      Disk
      1 GB
      100 GB
    
Build containers start with minimum resources and scale vertically up to maximum capacity as needed.
### Build time limit
The time limit for the whole build pipeline is **1 hour**. After 1 hour, Zerops will terminate the build pipeline and delete the build container.
:::info
Build container resources are not charged separately. Limited build time is included in your [project core plan](/company/pricing#project-core-plans), with additional build time available if needed.
:::
## Troubleshooting  builds
:::tip Advanced troubleshooting
For complex build issues that require investigation, you can enable [debug mode](/features/debug-mode) to pause the build process at specific points and inspect the build container state interactively.
:::
### Build and prepare command failures
If any build command or prepare command fails (returns non-zero exit code), the build is canceled. Check the build log to troubleshoot the error.
### Build cache issues
If you encounter unexpected build behavior or dependency issues, the problem might be related to cached build data. While Zerops maintains the build cache to speed up deployments, sometimes you may need to start fresh.
To invalidate the build cache:
1. Go to your service detail in Zerops GUI
2. Choose **Pipelines & CI/CD Settings** from the left menu
3. Click on the **Invalidate build cache** button
This will force Zerops to run the next build clean, including all prepare commands.
Learn more about [build cache behavior](/features/build-cache).
## More resources
For more details about the build and deploy pipeline, including how to cancel builds and manage application versions, see the [general pipeline documentation](/features/pipeline).
## Next steps
- Understand the deployment process
- Learn how to customize the runtime environment
- Explore build and runtime logs

----------------------------------------

# Ubuntu > How To > Controls



----------------------------------------

# Ubuntu > How To > Create

Zerops provides a Ubuntu runtime service with extensive build support. Ubuntu runtime is highly scalable and customisable to suit both development and production.
## Create Ubuntu service using Zerops GUI
First, set up a project in Zerops GUI. Then go to the project dashboard page and choose **Add new service** in the left menu in the **Services** block. Then add a new Ubuntu service:
### Choose Ubuntu version
Following Ubuntu versions are currently supported:
:::info
You can [change](/ubuntu/how-to/upgrade) the major version at any time later.
:::
### Set a hostname
Enter a unique service identifier like "app","cache", "gui" etc. Duplicate services with the same name in the same project are forbidden.
#### Limitations:
- maximum 25 characters
- must contain only lowercase ASCII letters (a-z) or numbers (0-9)
:::caution
The hostname is fixed after the service is created. It can't be changed later.
:::
### Set secret environment variables
Add environment variables with sensitive data, such as password, tokens, salts, certificates etc. These will be securely saved inside Zerops and added to your runtime service upon start.
Setting the secret environment variables is optional. You can set them later in Zerops GUI.
Read more about [different types of env variables](/ubuntu/how-to/env-variables#service-env-variables) in Zerops.
## Create Ubuntu service using zCLI
zCLI is the Zerops command-line tool. To create a new Ubuntu service via the command-line, follow these steps:
1. [Install & setup zCLI](/references/cli)
2. [Create a project description file](/ubuntu/how-to/create#create-a-project-description-file)
3. [Create a project with a Ubuntu and PostgreSQL service](#full-example)
### Create a project description file
Zerops uses a yaml format to describe the project infrastructure.
#### Basic example:
Create a directory `my-project`. Create an `description.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in ubuntu@{version} format
    type: ubuntu@24.04
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes your future project infrastructure. The project will contain one Ubuntu service with default [auto scaling](/ubuntu/how-to/scaling) configuration. Hostname will be set to "app", the internal port(s) the service listens on will be defined later in the [zerops.yaml](/ubuntu/how-to/build-pipeline#ports). Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
#### Full example:
Create a directory my-project. Create an description.yaml file inside the my-project directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
  # optional: project description
  description: A project with a Ubuntu and PostgreSQL database
  # optional: project tags
  tags:
    - DEMO
    - ZEROPS
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in ubuntu@{version} format
    type: ubuntu@24.04
    # optional: vertical auto scaling customization
    verticalAutoscaling:
      cpuMode: DEDICATED
      minCpu: 2
      maxCpu: 5
      minRam: 2
      maxRam: 24
      minDisk: 6
      maxDisk: 50
      startCpuCoreCount: 3
      minFreeRamGB: 0.5
      minFreeRamPercent: 20
    # defines the minimum number of containers for horizontal autoscaling. Max value = 6.
    minContainers: 2
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 4
    # optional: create secret env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
  - # second service hostname
    hostname: db
    # service type and version number in postgresql@{version} format
    type: postgresql@12
    # mode of operation "HA"/"non_HA"
    mode: NON_HA
```
The yaml file describes your future project infrastructure. The project will contain a Ubuntu service and a [PostgreSQL](/postgresql/overview) service.
Ubuntu service with "app" hostname, the internal port(s) the service listens on will be defined later in the zerops.yaml. Ubuntu service will run with a custom vertical and horizontal scaling. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The hostname of the PostgreSQL service will be set to "db". The [single container](/features/scaling-ha#single-container-mode)(/features/scaling-ha#deployment-modes-databases-and-shared-storage) mode will be chosen and the default auto [scaling configuration](/postgresql/how-to/scale#configure-scaling) will be set.
#### Description of description.yaml parameters
The `project:` section is required. Only one project can be defined.
  
      Parameter
      Description
    
      hostname
      
        The unique service identifier.
         
        The hostname of the new database will be set to the `hostname` value.
         
        Limitations:
        
        duplicate services with the same name in the same project are forbidden
        maximum 25 characters
        must contain only lowercase ASCII letters (a-z) or numbers (0-9)
        
      type
      
        Specifies the service type and version.
        
        See what [Ubuntu service types](/references/import-yaml/type-list#runtime-services) are currently supported.
      
      verticalAutoscaling
      
        Optional. Defines custom vertical auto scaling parameters.
        
        All verticalAutoscaling attributes are optional. Not specified attributes will be set to their default values.
      
      - cpuMode
      
        Optional. Accepts `SHARED`, `DEDICATED` values. Default is `SHARED`
      
      - minCpu/maxCpu
      
        Optional. Set the minCpu or maxCpu in CPU cores (integer).
      
      - minRam/maxRam
      
        Optional. Set the minRam or maxRam in GB (float).
      
      - minDisk/maxDisk
      
        Optional. Set the minDisk or maxDisk in GB (float).
      
      minContainers
      
        Optional. Default = 1. Defines the minimum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      maxContainers
      
        Defines the maximum number of containers for horizontal autoscaling.
         
        Limitations:
        
        Current maximum value = 10.
      
      envSecrets
      
        Optional. Defines one or more secret env variables as a key value map. See env variable restrictions.
      
### Create a project based on the description.yaml
When you have your `description.yaml` ready, use the `zcli project project-import` command to create a new project and the service infrastructure.
```sh
Usage:
  zcli project project-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project import command.
      --org-id string        If you have access to more than one organization, you must specify the org ID for which the
                            project is to be created.
      --working-dir string   Sets a custom working directory. Default working directory is the current directory. (default "./")
```
Zerops will create a project and one or more services based on the `description.yaml` content.
Maximum size of the `description.yaml` file is 100 kB.
You don't specify the project name in the `zcli project project-import` command, because the project name is defined in the `description.yaml`.
If you have access to more than one client, you must specify the client ID for which the project is to be created. The `clientID` is located in the Zerops GUI under the client name on the project dashboard page.
  
### Add Ubuntu service to an existing project
#### Example:
Create a directory `my-project` if it doesn't exist. Create an `import.yaml` file inside the `my-project` directory with following content:
```yaml
# basic project data
project:
  # project name
  name: my-project
# array of project services
services:
  - # service name
    hostname: app
    # service type and version number in ubuntu@{version} format
    type: ubuntu@24.04
    # defines the minimum number of containers for horizontal autoscaling
    minContainers: 1
    # defines the maximum number of containers for horizontal autoscaling. Max value = 6.
    maxContainers: 6
    # optional: create env variables
    envSecrets:
      S3_ACCESS_KEY_ID: 'P8cX1vVVb'
      S3_ACCESS_SECRET: 'ogFthuiLYki8XoL73opSCQ'
```
The yaml file describes the list of one or more services that you want to add to your existing project. In the example above, one Ubuntu service version 1 with default [auto scaling](/ubuntu/how-to/scaling) configuration will be added to your project. Hostname of the new service will be set to `app`. Following secret env variables will be configured:
```env
S3_ACCESS_KEY_ID="P8cX1vVVb"
S3_ACCESS_SECRET="ogFthuiLYki8XoL73opSCQ"
```
The content of the `services:` section of `import.yaml` is identical to the project description file. The `import.yaml` never contains the `project:` section because the project already exists.
When you have your `import.yaml` ready, use the `zcli project service-import` command to add one or more services to your existing Zerops project.
```sh
Usage:
  zcli project service-import importYamlPath [flags]
Flags:
  -h, --help                Help for the project service import command.
  -P, --project-id string   If you have access to more than one project, you must specify the project ID for which the
                           command is to be executed.
```
zCLI commands are interactive, when you press enter after `zcli project service-import importYamlPath`, you will be given a list of your projects to choose from.
Maximum size of the import.yaml file is 100 kB.

----------------------------------------

# Ubuntu > How To > Customize Runtime

System packages: Install any packages you need via apt-get, such as imagemagick, ffmpeg, or chromium',
  'Specific language versions: Install versions of Go, Node.js, PHP, Python, or other runtimes that are not available as dedicated Zerops services (e.g., older or cutting-edge versions)',
  'Custom binaries: Add compiled binaries or tools not available in the default repositories',
  'Development tools: Include debugging tools, profilers, or other utilities',
  'Specific libraries: Install dependencies required by your application'
]} />
## Build Custom Runtime Images
Zerops allows you to build custom runtime images (CRI) when the default base runtime images don't meet your application's requirements. This is an optional phase in the [build and deploy pipeline](/features/pipeline#runtime-prepare-phase-optional).
Ubuntu is a versatile base for running anything not explicitly offered as a dedicated Zerops runtime. You can install any packages and tools you need, treating it as a clean OS to customize however you want.
It is also a great option when you need a specific version of a technology (like Go, Node.js, or PHP) that Zerops doesn't support by default—whether it's an older version for legacy projects or a newer release not yet available.
## Configuration
### Default  Runtime Environment
The default  runtime environment contains:
- {data.ubuntu.default}
- [zCLI](/references/cli)
- 
### When You Need a Custom Runtime Image
Since Ubuntu serves as a general-purpose base, you'll likely want to customize it for your specific use case. Common scenarios include:
:::important
You should not include your application code in the custom runtime image, as your built/packaged code is deployed automatically into fresh containers.
:::
Here are examples of configuring custom runtime images in your `zerops.yml`:
### Basic  Setup
### Using Build Files in Runtime Preparation
For complete configuration details, see the [runtime prepare phase configuration guide](/features/pipeline#configuration).
## Process and Caching
### How Runtime Prepare Works
The runtime prepare process follows the same steps for all runtimes. See [how runtime prepare works](/features/pipeline#how-it-works) for the complete process details.
### Caching Behavior
Zerops caches custom runtime images to optimize deployment times. Learn about [custom runtime image caching](/features/pipeline#custom-runtime-image-caching) including when images are cached and reused.
### Build Management
For information about managing builds and deployments, see [managing builds and deployments](/features/pipeline#manage-builds-and-deployments).
:::warning
Shared storage mounts are not available during the runtime prepare phase.
:::
## Troubleshooting
If your `prepareCommands` fail, check the prepare runtime log for specific error messages.

----------------------------------------

# Ubuntu > How To > Delete



----------------------------------------

# Ubuntu > How To > Deploy Process



----------------------------------------

# Ubuntu > How To > Env Variables



----------------------------------------

# Ubuntu > How To > Filebrowser



----------------------------------------

# Ubuntu > How To > Logs



----------------------------------------

# Ubuntu > How To > Scaling



----------------------------------------

# Ubuntu > How To > Shared Storage



----------------------------------------

# Ubuntu > How To > Trigger Pipeline



----------------------------------------

# Ubuntu > How To > Upgrade



----------------------------------------

# Ubuntu > Overview

[Ubuntu ↗](https://ubuntu.com/) is a popular Linux distribution based on Debian, widely used for servers, cloud computing, and containerized applications.
Ubuntu services in Zerops provide a flexible base environment for running applications built with technologies that aren't officially supported by Zerops, or for custom setups requiring full control over the runtime environment.
:::tip
Do you have any questions? Check the step-by-step tutorial, browse the documentation and join our **[Discord](https://discord.com/invite/WDvCZ54)** community to get help from our team and other members.
:::
## Feature Highlights
{" "}
## When in doubt, reach out
Don't know how to start or got stuck during the process? You might not be the first one, visit the FAQ section to find out.
In case you haven't found an answer (and also if you have), we and our community are looking forward to hearing from you on Discord.
Have you built something that others might find useful? Don't hesitate to share your knowledge!
## Popular Guides

----------------------------------------

# Valkey > Overview

Valkey is a powerful, open-source alternative to Redis, offering full compatibility with Redis clients while providing an independent development path focused on community-driven innovation. Deploy and manage Valkey in Zerops' fully managed infrastructure to get instant access to high-performance in-memory data storage.
:::tip
Valkey is our recommended Redis alternative as KeyDB's development has slowed significantly in recent times.
:::
## Supported Versions
Currently supported Valkey versions:
Import configuration version:
## Service Configuration
Zerops offers Valkey in two deployment configurations to meet different availability requirements.
## Deployment Options
### Non-HA Setup
- Single node deployment on port `6379` (non-TLS) and `6380` (TLS)
- No backup mechanism beyond Zerops infrastructure reliability
- Data persists unless the hardware node fails
- Suitable for development or non-critical workloads
### HA (High Availability) Setup
Our HA implementation uses a unique approach to ensure high availability while maintaining compatibility with all Redis clients:
- 3-node configuration (1 master + 2 replicas)
- Access ports:
  - `6379` - read/write operations (non-TLS, routed to master)
  - `6380` - read/write operations over TLS (routed to master)
  - `7000` - read-only operations (non-TLS)
  - `7001` - read-only operations over TLS
- Implementation details:
  - All nodes are configured identically and listen on standard ports
  - First node in the cluster is designated as the master
  - On replica nodes, ports `6379`/`6380` traffic is forwarded to the master
  - Ports `7000`/`7001` are mapped locally to each node for direct replica access
  - When a master fails, a replica is promoted and routing is updated automatically
  - DNS entries are updated for seamless client connection
  - This implementation provides traffic forwarding to master (not natively supported by Valkey)
:::note
Be aware that replica data may lag slightly behind the master due to asynchronous replication.
:::
## Learn More
- [Official Valkey Documentation](https://valkey.io/docs) - Comprehensive guide to Valkey features
## Support
For advanced configurations or custom requirements:
- Join our [Discord community](https://discord.gg/zeropsio)
- Contact support via [email](mailto:support@zerops.io)

----------------------------------------

# Zerops Yaml > Base List

This is a list of all currently supported versions of technologies that can be used for build.base and run.base sections in `zerops.yaml`.
:::note
Versions listed on the same line are aliases of the same underlying version.
:::
## Runtime services
  
      Service Type
      Supported OS
      Versions
    
    Build / Runtime
  
     Bun
     `ubuntu` / `alpine`
     
     Deno
     `ubuntu`
     
     .NET
     `ubuntu` / `alpine`
     
     Elixir
     `ubuntu` / `alpine`
     
     Gleam
     `ubuntu`
     
     Go
     `ubuntu` / `alpine`
     
     Java
     `ubuntu` / `alpine`
     
      Node.js
      `ubuntu` / `alpine`
      
      Python
      `ubuntu` / `alpine`
      
      Rust
      `ubuntu` / `alpine`
      
        &nbsp;
        &nbsp;
        Build
        Runtime
      
      PHP + Apache
      `ubuntu` / `alpine`
      
      PHP + nginx
      `ubuntu` / `alpine`
      
## Static services
  
      Service Type
      Supported OS
      Versions
    
    Build
    Runtime
  
      nginx
      `ubuntu`/`alpine`
      -
      
      static
      `ubuntu`/`alpine`
      -
      
## Containers and virtual machines
  
      Service Type
      Supported OS
      Versions
    
    Build / Runtime
  
    Alpine
    `alpine`
    
      Ubuntu
      `ubuntu`
      

----------------------------------------

# Zerops Yaml > Cron

Cron jobs are scheduled commands that execute automatically inside a service's containers based on defined timing rules.
In Zerops, these jobs are configured in the `run` section of `zerops.yaml` file under the `crontab` key.
## Parameters
### command
*string, REQUIRED*
The shell command to execute at the scheduled time. This can be any valid command.
### timing
*string, REQUIRED*
The schedule for when the task should run, specified in standard cron format using five space-separated fields:
  - Minute (0–59)
  - Hour (0–23)
  - Day of the month (1–31)
  - Month (1–12)
  - Day of the week (0–7; both 0 and 7 represent Sunday)
#### Examples
  - `"0 5 * * *"` – Runs daily at 5:00 AM.
  - `"*/10 * * * *"` – Runs every 10 minutes.
### allContainers
*boolean, REQUIRED*
**Options:**
- `true` – Command runs on all containers.
- `false` – Command runs on only one container.
### workingDir
*string, REQUIRED*
Specifies the directory where the command will be executed. If not set, it defaults to `/var/www`.
## Example Configurations
Here’s a basic example of how to set up a cron job in your service's `zerops.yaml`:
```yaml
run: 
  crontab:
    - command: "date >> /var/log/cron.log"
      timing: "0 * * * *"
```
This configuration logs the current date to `/var/log/cron.log` every hour.
### Running on Multiple Containers
By default, cron jobs run on a single container, even if multiple containers exist for the service. To execute a command across all containers, you can use the `allContainers` parameter:
```yaml
run: 
  crontab:
    - command: "rm -rf /tmp/*"
      timing: "0 0 * * *"
      allContainers: true
```
This example removes temporary files from all containers every day at midnight.
### Custom Working Directory
You can also specify a custom working directory for your commands using the `workingDir` parameter:
```yaml
run: 
  crontab:
    - command: "php artisan schedule:run"
      timing: "* * * * *"
      workingDir: /var/www/html
```
In this case, the command runs every minute in the `/var/www/html` directory.
### Multiple Cronjobs
It is possible to define multiple cron jobs as a YAML object list under the `crontab` key.
```yaml
run:
  crontab:
    - command: ...
      ...
    - command: ...
      ...
```

----------------------------------------

# Zerops Yaml > Specification

export const languages = [
    { name: "Node.js", link: "/nodejs/how-to/build-pipeline" },
    { name: "PHP", link: "/php/how-to/build-pipeline" },
    { name: "Python", link: "/python/how-to/build-pipeline" },
    { name: "Go", link: "/go/how-to/build-pipeline" },
    { name: ".NET", link: "/dotnet/how-to/build-pipeline" },
    { name: "Rust", link: "/rust/how-to/build-pipeline" },
    { name: "Java", link: "/java/how-to/build-pipeline" },
    { name: "Deno", link: "/deno/how-to/build-pipeline" },
    { name: "Bun", link: "/bun/how-to/build-pipeline" },
    { name: "Elixir", link: "/elixir/how-to/build-pipeline" },
    { name: "Gleam", link: "/gleam/how-to/build-pipeline" },
    { name: "Nginx", link: "/nginx/how-to/build-pipeline" }
]
The `zerops.yaml` file is crucial for defining how Zerops should [build and deploy](/features/pipeline) your application.
Add the `zerops.yaml` file to the **root of your repository** and customize it to suit your application's needs.
:::note Parameter Availability
Not all parameters are available for every service type. Most parameters work across different runtime services, but some are specific to certain service types (e.g., documentRoot for webserver services, routing for Static services). This documentation covers zerops.yaml configuration for runtime services.
:::
---
## Basic Structure
```yaml title="zerops.yaml"
zerops:
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Multiple services can be defined in a single `zerops.yaml` (useful for monorepos):
```yaml
zerops:
  - setup: app
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
  - setup: api
    # optional
    build: ...
    # optional
    deploy: ...
    # required
    run: ...
```
Each service configuration requires a `run` section. Optional `build` and `deploy` sections can be added to further customize your process.
## Service Configuration
### setup 
Contains the hostname of your service (must exist in Zerops).
```yaml
setup: app
```
### extends 
The `extends` key allows you to inherit configuration from another service defined in the same `zerops.yaml` file. This is useful for creating environment-specific configurations while maintaining a common base.
```yaml
zerops:
  - setup: base
    build:
      buildCommands:
        - npm run build
      deployFiles: ./dist
    run:
      start: npm start
  - setup: prod
    extends: base
    run:
      envVariables:
        NODE_ENV: production
  - setup: dev
    extends: base
    run:
      envVariables:
        NODE_ENV: development
```
When using `extends`:
- The `extends` value must refer to another service's `setup` value in the same file
- The child service inherits all configuration from the base service
- Configuration is merged at the section level (`build`, `run`, `deploy`)
- You can override specific sections by redefining them
:::tip
Create a base service with common configuration and extend it for environment-specific services to keep your `zerops.yaml` file DRY (Don't Repeat Yourself).
:::
## Build Configuration 
### base 
Sets the base technology for the build environment. [See available options](/zerops-yaml/base-list).
```yaml
build:
  base: nodejs@latest
```
You can specify multiple technologies:
```yaml
build:
  base:
    - nodejs@latest
  prepareCommands:
    - zsc add python@3.9
```
### os 
Sets the operating system for the build environment. Options:
- `alpine` (default)
- `ubuntu` (default for ubuntu service)
Current versions:
- {data.alpine.default}
- {data.ubuntu.default}
```yaml
build:
  os: ubuntu
```
### prepareCommands 
Customizes the build environment by installing additional dependencies or tools.
```yaml
build:
  prepareCommands:
    - sudo apt-get update
    - sudo apt-get install -y some-package
```
### buildCommands 
Defines the commands to build your application.
```yaml
build:
  buildCommands:
    - npm install
    - npm run build
```
#### Running commands in a single shell instance:
```yaml
buildCommands:
  - |
    npm install
    npm run build
```
### deployFiles 
Specifies which files or folders to deploy after a successful build.
```yaml
build:
  deployFiles:
    - dist
    - package.json
    - node_modules
```
The files/folders will be placed into `/var/www` folder in runtime, e.g. `./src/assets/fonts` would result in `/var/www/src/assets/fonts`.
#### Using wildcards:
Zerops supports the `~` character as a wildcard for one or more folders in the path.
Deploys all `file.txt` files that are located in any path that begins with `/path/` and ends with `/to/`.
```yaml
deployFiles: ./path/~/to/file.txt
```
By default, `./src/assets/fonts` deploys to `/var/www/src/assets/fonts`, keeping the full path. Adding `~`, like `./src/assets/~fonts`, shortens it to `/var/www/fonts`
#### .deployignore
Add a `.deployignore` file to the root of your project to specify which files and folders Zerops should ignore during deploy. The syntax follows the same pattern format as `.gitignore`.
To ignore a specific file or directory path, start the pattern with a forward slash (`/`). Without the leading slash, the pattern will match files with that name in any directory.
:::tip
For consistency, it's recommended to configure both your `.gitignore` and `.deployignore` files with the same patterns.
:::
Examples:
```yaml title="zerops.yaml"
zerops:
  - setup: app
    build:
      deployFiles: ./
```
```text title=".deployignore"
/src/file.txt
```
The example above ignores `file.txt` only in the root src directory.
```text title=".deployignore"
src/file.txt
```
This example above ignores `file.txt` in ANY directory named `src`, such as:
- `/src/file.txt`
- `/folder2/folder3/src/file.txt`
- `/src/src/file.txt`
:::note
`.deployignore` file also works with `zcli service deploy` command.
:::
### cache 
Defines which files or folders to cache for subsequent builds.
```yaml
build:
  cache: node_modules
```
For more information, see our detailed [guide on build cache](/features/build-cache), complete with extensive examples.
### addToRunPrepare 
Defines files or folders to be copied from the build container to the prepare runtime container.
### envVariables 
Sets environment variables for the build environment.
```yaml
build:
  envVariables:
    DB_NAME: db
    DB_HOST: db
    DB_USER: db
    DB_PASS: ${db_password}
```
:::info
The `yamlPreprocessor` option in your project & service import YAML allows you to generate random secret values, passwords, and public/private key pairs. For more information, see the [yamlPreprocessor](/references/import-yaml/pre-processor) page.
:::
## Deploy Configuration 
### temporaryShutdown 
Controls the container replacement order during deployment.
```yaml
deploy:
  temporaryShutdown: true
```
- Type: `boolean`
- Default: `false`
**When `false` (default):** New containers are started before old containers are removed, ensuring zero-downtime deployment.
**When `true`:** Old containers are removed before new containers are started, causing temporary downtime but using fewer resources during deployment.
### readinessCheck 
Defines a readiness check for your application. Requires either `httpGet` object or `exec` object.
```yaml
deploy:
  readinessCheck:
    # HTTP GET method example
    httpGet:
      port: 80
      path: /status
      host: my-host.zerops
      scheme: https
    # Common parameters
    failureTimeout: 60
    retryPeriod: 10
```
Readiness checks work similarly to [health checks](#healthcheck-) but are specifically for deployment. They verify if a new deployment is ready to receive traffic.
Available parameters:
#### httpGet and exec
The `httpGet` and `exec` options work the same way as in [health checks](#healthcheck-). See that section for detailed parameter descriptions.
#### Common parameters 
The following parameters can be used with either `httpGet` or `exec` readiness checks:
- **failureTimeout** - Time in seconds until container is marked as failed.
- **retryPeriod** - Time interval in seconds between readiness check attempts (equivalent to `execPeriod` in health checks).
:::tip
Unlike health checks which run continuously, readiness checks only run during deployments to determine when your application is ready to accept traffic.
:::
## Runtime Configuration 
### base 
Sets the base technology for the runtime environment. If not specified, the current version is maintained.
```yaml
run:
  base: nodejs@latest
```
### os 
Sets the operating system for the runtime environment. Options and versions are the same as for the build environment.
### ports 
Specifies the internal ports on which your application will listen.
```yaml
run:
  ports:
    - port: 8080
      protocol: TCP # Optional
      httpSupport: true # Optional
    - port: 8081
      ...
```
Available parameters:
#### port 
Defines the port number on which your application listens. Must be between *10* and *65435*, as ports outside this range are reserved for internal Zerops systems.
#### protocol 
Specifies the network protocol to use:
- Allowed values: `TCP` *(default)* or `UDP`
#### httpSupport 
Indicates whether the port is running a web server:
- Default value: `false`
- Set to `true` if a web server is running on the port
- Only available with TCP protocol
- Used by Zerops for [public access](/features/access) configuration
### prepareCommands 
Customizes the runtime environment by installing additional dependencies or tools.
### initCommands 
Defines commands to run each time a new runtime container starts or restarts.
```yaml
run:
  initCommands:
    - rm -rf ./cache
```
### start 
Defines the start command for your application.
```yaml
run:
  start: npm start
```
### startCommands 
Defines start commands.
Unlike `start`, you can define multiple commands that starts their own processes.
```yaml
run:
  startCommands:
    # start the application
    - command: npm run start:prod
      name: server
    # start the replication
    - command: litestream replicate -config=litestream.yaml
      name: replication
      # restore the database on container init
      initCommands:
        - litestream restore -if-replica-exists -if-db-not-exists -config=litestream.yaml $DB_NAME
```
See [start-commands-example](https://github.com/zeropsio/start-commands-example)
### documentRoot 
Customizes the root folder for publicly accessible web server content (available only for webserver runtimes).
### siteConfigPath 
Sets the custom webserver configuration (available only for webserver runtimes).
### envVariables 
Defines environment variables for the runtime environment.
```yaml
    run:
      base: nodejs@20
      envVariables:
        DB_NAME: db
        DB_HOST: db
        DB_USER: db
        DB_PASS: ${db_password}
```
### envReplace 
Automatically replaces environment variable placeholders in your static files with their actual values during deployment.
```yaml
run:
  envReplace:
    delimiter: "%%"
    target:
      - config/jwt/public.pem
      - config/jwt/private.pem
      - ./config/
```
Available parameters:
#### delimiter 
Characters that wrap your variable names in placeholders (e.g., `%%` means placeholders look like `%%VARIABLE%%`).
- Type: `string` or `array of strings`
- Supports multiple delimiters simultaneously
#### target 
Files or directories to process for variable replacement.
- Type: `string` or `array of strings`
- Can be specific files or directories
:::warning
Directory targets only process files directly in the specified directory, not subdirectories for performance reasons. To process files in subdirectories, specify each subdirectory explicitly in the target array. For example, ./config/ processes only files in the config directory itself, not files in ./config/jwt/ or other subdirectories.
:::
**How it works:**
1. Define placeholders in your files using the specified delimiters
2. Set environment variables with matching names
3. During deployment, Zerops finds and replaces placeholders with actual values
**Example usage:**
```yaml
run:
  envReplace:
    delimiter: "%%"
    target:
      - ./config/
      - ./templates/
      - ./              # Only processes files in root, not subdirectories
```
File content before replacement:
```
# config/jwt/public.pem
%%JWT_PUBLIC_KEY_CONTENT%%
```
Environment variable:
```
JWT_PUBLIC_KEY_CONTENT=-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----
```
The placeholder gets replaced with the actual JWT public key during deployment.
### routing 
Configures URL routing, redirects, and HTTP headers (only for Static services).
```yaml
run:
  routing:
    root: /custom/root
    cors: "'*' always"
    redirects:
      - from: /old-path
        to: /new-path
        status: 301
    headers:
      - for: "/*"
        values:
          X-Frame-Options: "'DENY'"
```
Available parameters:
#### root 
Sets a custom root directory for the service.
- Type: `string`
#### cors 
Enables CORS headers for cross-origin requests.
- Type: `string`
- Sets `Access-Control-Allow-Origin`, `Access-Control-Allow-Methods`, `Access-Control-Allow-Headers`, and `Access-Control-Expose-Headers`
- Special case: `"*"` is automatically converted to `'*'`
#### redirects 
Defines URL redirects and rewrites.
- Type: `array of objects`
- Each redirect object supports:
  - **from**  - Source path to match ([supports wildcards](/static/overview#wildcard-matching) with `*`)
  - **to**  - Destination path
  - **status**  - HTTP status code (required for absolute URLs)
  - **preservePath**  - Preserve path after wildcard match
  - **preserveQuery**  - Preserve query parameters
#### headers 
Sets custom HTTP headers for specific paths.
- Type: `array of objects`
- Each header object supports:
  - **for**  - Path pattern to match
  - **values**  - Object with header name/value pairs
**Example usage:**
```yaml
run:
  routing:
    cors: "'*' always"
    redirects:
      # Permanent redirect
      - from: /old-page
        to: /new-page
        status: 301
      # Wildcard redirect with path preservation
      - from: /blog/*
        to: /articles/
        preservePath: true
        status: 302
    headers:
      - for: "/*"
        values:
          X-Frame-Options: "'DENY'"
          Content-Security-Policy: '"default-src ''self''"'
```
### healthCheck 
Defines a health check for your application.
```yaml
run:
  healthCheck:
    # HTTP GET method example
    httpGet:
      port: 80
      path: /status
      host: my-host.zerops
      scheme: https
    # OR command-based example
    exec:
      command: |
        curl -s http://localhost:8080/status > /tmp/status
        grep -q "OK" /tmp/status
    # Common parameters
    failureTimeout: 60
    disconnectTimeout: 30
    recoveryTimeout: 30
    execPeriod: 10
```
Available parameters:
#### httpGet 
Configures the health check to request a local URL using a HTTP GET method.
- **port**  - Defines the port of the HTTP GET request.
- **path**  - Defines the URL path of the HTTP GET request.
- **host**  - The health check is triggered from inside of your runtime container so it uses the localhost (127.0.0.1). If you need to add a host to the request header, specify it in the host attribute.
- **scheme**  - The health check is triggered from inside of your runtime container so no https is required. If your application requires a https request, set scheme: `https`.
#### exec 
Configures the health check to run a local command.
- **command**  - Defines a local command to be run. The command has access to the same environment variables. A single string is required. If you need to run multiple commands create a shell script or, use a multiline format as in the example above.
#### Common parameters 
The following parameters can be used with either `httpGet` or `exec` health checks:
- **failureTimeout** - Time in seconds until container fails after consecutive health check failures (reset by success).
- **disconnectTimeout** - Time in seconds until container is disconnected and becomes publicly unavailable.
- **recoveryTimeout** - Time in seconds until container is connected and becomes publicly available.
- **execPeriod** - Time interval in seconds between health check attempts.
:::tip
Health checks continuously monitor your running application, while readiness checks verify if a new deployment is ready to receive traffic. For readiness checks, see the [readinessCheck section](#readinesscheck-).
:::
### crontab 
Defines scheduled commands to run as cron jobs within a service.
```yaml
run:
  crontab:
    - command: "date >> /var/log/cron.log"
      timing: "0 * * * *"
      allContainers: false
```
Setup cron jobs. See [examples](/zerops-yaml/cron).
:::note
For more detailed information on specific configurations, refer to the runtime-specific guides linked at the beginning of this document.
:::
*Need help? Join our [Discord community](https://discord.gg/zeropsio).*

----------------------------------------

